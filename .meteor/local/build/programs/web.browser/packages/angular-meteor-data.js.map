{"version":3,"sources":["meteor://ðŸ’»app/packages/angular-meteor-data/.npm/package/node_modules/angular-meteor/dist/angular-meteor.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H","file":"/packages/angular-meteor-data.js","sourcesContent":["/*! angular-meteor v1.3.11 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"jsondiffpatch\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"underscore\", \"jsondiffpatch\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularMeteor\"] = factory(require(\"underscore\"), require(\"jsondiffpatch\"));\n\telse\n\t\troot[\"angularMeteor\"] = factory(root[\"_\"], root[\"jsondiffpatch\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_22__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\t__webpack_require__(1);\n\n\t__webpack_require__(4);\n\n\t__webpack_require__(5);\n\n\t__webpack_require__(6);\n\n\t__webpack_require__(7);\n\n\t__webpack_require__(8);\n\n\t__webpack_require__(9);\n\n\t__webpack_require__(10);\n\n\t__webpack_require__(11);\n\n\t__webpack_require__(12);\n\n\t__webpack_require__(13);\n\n\t__webpack_require__(14);\n\n\t__webpack_require__(15);\n\n\tvar _utils = __webpack_require__(16);\n\n\tvar _mixer = __webpack_require__(17);\n\n\tvar _scope = __webpack_require__(18);\n\n\tvar _core = __webpack_require__(19);\n\n\tvar _viewModel = __webpack_require__(20);\n\n\tvar _reactive = __webpack_require__(21);\n\n\tvar _templates = __webpack_require__(23);\n\n\t// legacy\n\t// lib\n\n\n\tvar name = 'angular-meteor';\n\n\t// new\n\n\texports.default = name;\n\n\n\tangular.module(name, [\n\t// new\n\t_utils.name, _mixer.name, _scope.name, _core.name, _viewModel.name, _reactive.name, _templates.name,\n\n\t// legacy\n\t'angular-meteor.ironrouter', 'angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'angular-meteor.object', 'angular-meteor.user', 'angular-meteor.methods', 'angular-meteor.session', 'angular-meteor.camera']).run([_mixer.Mixer, _core.Core, _viewModel.ViewModel, _reactive.Reactive, function ($Mixer, $$Core, $$ViewModel, $$Reactive) {\n\t  // Load all mixins\n\t  $Mixer.mixin($$Core).mixin($$ViewModel).mixin($$Reactive);\n\t}])\n\n\t// legacy\n\t// Putting all services under $meteor service for syntactic sugar\n\t.service('$meteor', ['$meteorCollection', '$meteorCollectionFS', '$meteorObject', '$meteorMethods', '$meteorSession', '$meteorSubscribe', '$meteorUtils', '$meteorCamera', '$meteorUser', function ($meteorCollection, $meteorCollectionFS, $meteorObject, $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils, $meteorCamera, $meteorUser) {\n\t  var _this = this;\n\n\t  this.collection = $meteorCollection;\n\t  this.collectionFS = $meteorCollectionFS;\n\t  this.object = $meteorObject;\n\t  this.subscribe = $meteorSubscribe.subscribe;\n\t  this.call = $meteorMethods.call;\n\t  this.session = $meteorSession;\n\t  this.autorun = $meteorUtils.autorun;\n\t  this.getCollectionByName = $meteorUtils.getCollectionByName;\n\t  this.getPicture = $meteorCamera.getPicture;\n\n\t  // $meteorUser\n\t  ['loginWithPassword', 'requireUser', 'requireValidUser', 'waitForUser', 'createUser', 'changePassword', 'forgotPassword', 'resetPassword', 'verifyEmail', 'loginWithMeteorDeveloperAccount', 'loginWithFacebook', 'loginWithGithub', 'loginWithGoogle', 'loginWithMeetup', 'loginWithTwitter', 'loginWithWeibo', 'logout', 'logoutOtherClients'].forEach(function (method) {\n\t    _this[method] = $meteorUser[method];\n\t  });\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t'use strict';\n\n\t// https://github.com/DAB0mB/get-updates\n\t/*global\n\t angular, _\n\t */\n\n\t(function () {\n\t  var module = angular.module('getUpdates', []);\n\n\t  var utils = function () {\n\t    var rip = function rip(obj, level) {\n\t      if (level < 1) return {};\n\n\t      return _underscore2.default.reduce(obj, function (clone, v, k) {\n\t        v = _underscore2.default.isObject(v) ? rip(v, --level) : v;\n\t        clone[k] = v;\n\t        return clone;\n\t      }, {});\n\t    };\n\n\t    var toPaths = function toPaths(obj) {\n\t      var keys = getKeyPaths(obj);\n\t      var values = getDeepValues(obj);\n\t      return _underscore2.default.object(keys, values);\n\t    };\n\n\t    var getKeyPaths = function getKeyPaths(obj) {\n\t      var keys = _underscore2.default.keys(obj).map(function (k) {\n\t        var v = obj[k];\n\t        if (!_underscore2.default.isObject(v) || _underscore2.default.isEmpty(v) || _underscore2.default.isArray(v)) return k;\n\n\t        return getKeyPaths(v).map(function (subKey) {\n\t          return k + '.' + subKey;\n\t        });\n\t      });\n\n\t      return _underscore2.default.flatten(keys);\n\t    };\n\n\t    var getDeepValues = function getDeepValues(obj, arr) {\n\t      arr = arr || [];\n\n\t      _underscore2.default.values(obj).forEach(function (v) {\n\t        if (!_underscore2.default.isObject(v) || _underscore2.default.isEmpty(v) || _underscore2.default.isArray(v)) arr.push(v);else getDeepValues(v, arr);\n\t      });\n\n\t      return arr;\n\t    };\n\n\t    var flatten = function flatten(arr) {\n\t      return arr.reduce(function (flattened, v, i) {\n\t        if (_underscore2.default.isArray(v) && !_underscore2.default.isEmpty(v)) flattened.push.apply(flattened, flatten(v));else flattened.push(v);\n\n\t        return flattened;\n\t      }, []);\n\t    };\n\n\t    var setFilled = function setFilled(obj, k, v) {\n\t      if (!_underscore2.default.isEmpty(v)) obj[k] = v;\n\t    };\n\n\t    var assert = function assert(result, msg) {\n\t      if (!result) throwErr(msg);\n\t    };\n\n\t    var throwErr = function throwErr(msg) {\n\t      throw Error('get-updates error - ' + msg);\n\t    };\n\n\t    return {\n\t      rip: rip,\n\t      toPaths: toPaths,\n\t      getKeyPaths: getKeyPaths,\n\t      getDeepValues: getDeepValues,\n\t      setFilled: setFilled,\n\t      assert: assert,\n\t      throwErr: throwErr\n\t    };\n\t  }();\n\n\t  var getDifference = function () {\n\t    var getDifference = function getDifference(src, dst, isShallow) {\n\t      var level;\n\n\t      if (isShallow > 1) level = isShallow;else if (isShallow) level = 1;\n\n\t      if (level) {\n\t        src = utils.rip(src, level);\n\t        dst = utils.rip(dst, level);\n\t      }\n\n\t      return compare(src, dst);\n\t    };\n\n\t    var compare = function compare(src, dst) {\n\t      var srcKeys = _underscore2.default.keys(src);\n\t      var dstKeys = _underscore2.default.keys(dst);\n\n\t      var keys = _underscore2.default.chain([]).concat(srcKeys).concat(dstKeys).uniq().without('$$hashKey').value();\n\n\t      return keys.reduce(function (diff, k) {\n\t        var srcValue = src[k];\n\t        var dstValue = dst[k];\n\n\t        if (_underscore2.default.isDate(srcValue) && _underscore2.default.isDate(dstValue)) {\n\t          if (srcValue.getTime() != dstValue.getTime()) diff[k] = dstValue;\n\t        }\n\n\t        if (_underscore2.default.isObject(srcValue) && _underscore2.default.isObject(dstValue)) {\n\t          var valueDiff = getDifference(srcValue, dstValue);\n\t          utils.setFilled(diff, k, valueDiff);\n\t        } else if (srcValue !== dstValue) {\n\t          diff[k] = dstValue;\n\t        }\n\n\t        return diff;\n\t      }, {});\n\t    };\n\n\t    return getDifference;\n\t  }();\n\n\t  var getUpdates = function () {\n\t    var getUpdates = function getUpdates(src, dst, isShallow) {\n\t      utils.assert(_underscore2.default.isObject(src), 'first argument must be an object');\n\t      utils.assert(_underscore2.default.isObject(dst), 'second argument must be an object');\n\n\t      var diff = getDifference(src, dst, isShallow);\n\t      var paths = utils.toPaths(diff);\n\n\t      var set = createSet(paths);\n\t      var unset = createUnset(paths);\n\t      var pull = createPull(unset);\n\n\t      var updates = {};\n\t      utils.setFilled(updates, '$set', set);\n\t      utils.setFilled(updates, '$unset', unset);\n\t      utils.setFilled(updates, '$pull', pull);\n\n\t      return updates;\n\t    };\n\n\t    var createSet = function createSet(paths) {\n\t      var undefinedKeys = getUndefinedKeys(paths);\n\t      return _underscore2.default.omit(paths, undefinedKeys);\n\t    };\n\n\t    var createUnset = function createUnset(paths) {\n\t      var undefinedKeys = getUndefinedKeys(paths);\n\t      var unset = _underscore2.default.pick(paths, undefinedKeys);\n\n\t      return _underscore2.default.reduce(unset, function (result, v, k) {\n\t        result[k] = true;\n\t        return result;\n\t      }, {});\n\t    };\n\n\t    var createPull = function createPull(unset) {\n\t      var arrKeyPaths = _underscore2.default.keys(unset).map(function (k) {\n\t        var split = k.match(/(.*)\\.\\d+$/);\n\t        return split && split[1];\n\t      });\n\n\t      return _underscore2.default.compact(arrKeyPaths).reduce(function (pull, k) {\n\t        pull[k] = null;\n\t        return pull;\n\t      }, {});\n\t    };\n\n\t    var getUndefinedKeys = function getUndefinedKeys(obj) {\n\t      return _underscore2.default.keys(obj).filter(function (k) {\n\t        var v = obj[k];\n\t        return _underscore2.default.isUndefined(v);\n\t      });\n\t    };\n\n\t    return getUpdates;\n\t  }();\n\n\t  module.value('getUpdates', getUpdates);\n\t})();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _underscore = __webpack_require__(3);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tif (typeof _underscore2.default === 'undefined') {\n\t  if (typeof Package.underscore === 'undefined') {\n\t    throw new Error('underscore is missing');\n\t  }\n\t}\n\n\texports.default = _underscore2.default || Package.underscore._;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t'use strict'; /*global\n\t               angular, _, Package\n\t               */\n\n\tvar _module = angular.module('diffArray', ['getUpdates']);\n\n\t_module.factory('diffArray', ['getUpdates', function (getUpdates) {\n\t  var LocalCollection = Package.minimongo.LocalCollection;\n\t  var idStringify = LocalCollection._idStringify || Package['mongo-id'].MongoID.idStringify;\n\t  var idParse = LocalCollection._idParse || Package['mongo-id'].MongoID.idParse;\n\n\t  // Calculates the differences between `lastSeqArray` and\n\t  // `seqArray` and calls appropriate functions from `callbacks`.\n\t  // Reuses Minimongo's diff algorithm implementation.\n\t  // XXX Should be replaced with the original diffArray function here:\n\t  // https://github.com/meteor/meteor/blob/devel/packages/observe-sequence/observe_sequence.js#L152\n\t  // When it will become nested as well, tracking here: https://github.com/meteor/meteor/issues/3764\n\t  function diffArray(lastSeqArray, seqArray, callbacks, preventNestedDiff) {\n\t    preventNestedDiff = !!preventNestedDiff;\n\n\t    var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges || Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n\n\t    var oldObjIds = [];\n\t    var newObjIds = [];\n\t    var posOld = {}; // maps from idStringify'd ids\n\t    var posNew = {}; // ditto\n\t    var posCur = {};\n\t    var lengthCur = lastSeqArray.length;\n\n\t    _underscore2.default.each(seqArray, function (doc, i) {\n\t      newObjIds.push({ _id: doc._id });\n\t      posNew[idStringify(doc._id)] = i;\n\t    });\n\n\t    _underscore2.default.each(lastSeqArray, function (doc, i) {\n\t      oldObjIds.push({ _id: doc._id });\n\t      posOld[idStringify(doc._id)] = i;\n\t      posCur[idStringify(doc._id)] = i;\n\t    });\n\n\t    // Arrays can contain arbitrary objects. We don't diff the\n\t    // objects. Instead we always fire 'changedAt' callback on every\n\t    // object. The consumer of `observe-sequence` should deal with\n\t    // it appropriately.\n\t    diffFn(oldObjIds, newObjIds, {\n\t      addedBefore: function addedBefore(id, doc, before) {\n\t        var position = before ? posCur[idStringify(before)] : lengthCur;\n\n\t        _underscore2.default.each(posCur, function (pos, id) {\n\t          if (pos >= position) posCur[id]++;\n\t        });\n\n\t        lengthCur++;\n\t        posCur[idStringify(id)] = position;\n\n\t        callbacks.addedAt(id, seqArray[posNew[idStringify(id)]], position, before);\n\t      },\n\n\t      movedBefore: function movedBefore(id, before) {\n\t        var prevPosition = posCur[idStringify(id)];\n\t        var position = before ? posCur[idStringify(before)] : lengthCur - 1;\n\n\t        _underscore2.default.each(posCur, function (pos, id) {\n\t          if (pos >= prevPosition && pos <= position) posCur[id]--;else if (pos <= prevPosition && pos >= position) posCur[id]++;\n\t        });\n\n\t        posCur[idStringify(id)] = position;\n\n\t        callbacks.movedTo(id, seqArray[posNew[idStringify(id)]], prevPosition, position, before);\n\t      },\n\t      removed: function removed(id) {\n\t        var prevPosition = posCur[idStringify(id)];\n\n\t        _underscore2.default.each(posCur, function (pos, id) {\n\t          if (pos >= prevPosition) posCur[id]--;\n\t        });\n\n\t        delete posCur[idStringify(id)];\n\t        lengthCur--;\n\n\t        callbacks.removedAt(id, lastSeqArray[posOld[idStringify(id)]], prevPosition);\n\t      }\n\t    });\n\n\t    _underscore2.default.each(posNew, function (pos, idString) {\n\t      if (!_underscore2.default.has(posOld, idString)) return;\n\n\t      var id = idParse(idString);\n\t      var newItem = seqArray[pos] || {};\n\t      var oldItem = lastSeqArray[posOld[idString]];\n\t      var updates = getUpdates(oldItem, newItem, preventNestedDiff);\n\n\t      if (!_underscore2.default.isEmpty(updates)) callbacks.changedAt(id, updates, pos, oldItem);\n\t    });\n\t  }\n\n\t  diffArray.shallow = function (lastSeqArray, seqArray, callbacks) {\n\t    return diffArray(lastSeqArray, seqArray, callbacks, true);\n\t  };\n\n\t  diffArray.deepCopyChanges = function (oldItem, newItem) {\n\t    var setDiff = getUpdates(oldItem, newItem).$set;\n\n\t    _underscore2.default.each(setDiff, function (v, deepKey) {\n\t      setDeep(oldItem, deepKey, v);\n\t    });\n\t  };\n\n\t  diffArray.deepCopyRemovals = function (oldItem, newItem) {\n\t    var unsetDiff = getUpdates(oldItem, newItem).$unset;\n\n\t    _underscore2.default.each(unsetDiff, function (v, deepKey) {\n\t      unsetDeep(oldItem, deepKey);\n\t    });\n\t  };\n\n\t  // Finds changes between two collections\n\t  diffArray.getChanges = function (newCollection, oldCollection, diffMethod) {\n\t    var changes = { added: [], removed: [], changed: [] };\n\n\t    diffMethod(oldCollection, newCollection, {\n\t      addedAt: function addedAt(id, item, index) {\n\t        changes.added.push({ item: item, index: index });\n\t      },\n\n\t      removedAt: function removedAt(id, item, index) {\n\t        changes.removed.push({ item: item, index: index });\n\t      },\n\n\t      changedAt: function changedAt(id, updates, index, oldItem) {\n\t        changes.changed.push({ selector: id, modifier: updates });\n\t      },\n\n\t      movedTo: function movedTo(id, item, fromIndex, toIndex) {\n\t        // XXX do we need this?\n\t      }\n\t    });\n\n\t    return changes;\n\t  };\n\n\t  var setDeep = function setDeep(obj, deepKey, v) {\n\t    var split = deepKey.split('.');\n\t    var initialKeys = _underscore2.default.initial(split);\n\t    var lastKey = _underscore2.default.last(split);\n\n\t    initialKeys.reduce(function (subObj, k, i) {\n\t      var nextKey = split[i + 1];\n\n\t      if (isNumStr(nextKey)) {\n\t        if (subObj[k] === null) subObj[k] = [];\n\t        if (subObj[k].length == parseInt(nextKey)) subObj[k].push(null);\n\t      } else if (subObj[k] === null || !isHash(subObj[k])) {\n\t        subObj[k] = {};\n\t      }\n\n\t      return subObj[k];\n\t    }, obj);\n\n\t    var deepObj = getDeep(obj, initialKeys);\n\t    deepObj[lastKey] = v;\n\t    return v;\n\t  };\n\n\t  var unsetDeep = function unsetDeep(obj, deepKey) {\n\t    var split = deepKey.split('.');\n\t    var initialKeys = _underscore2.default.initial(split);\n\t    var lastKey = _underscore2.default.last(split);\n\t    var deepObj = getDeep(obj, initialKeys);\n\n\t    if (_underscore2.default.isArray(deepObj) && isNumStr(lastKey)) return !!deepObj.splice(lastKey, 1);else return delete deepObj[lastKey];\n\t  };\n\n\t  var getDeep = function getDeep(obj, keys) {\n\t    return keys.reduce(function (subObj, k) {\n\t      return subObj[k];\n\t    }, obj);\n\t  };\n\n\t  var isHash = function isHash(obj) {\n\t    return _underscore2.default.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n\t  };\n\n\t  var isNumStr = function isNumStr(str) {\n\t    return str.match(/^\\d+$/);\n\t  };\n\n\t  return diffArray;\n\t}]);\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tangular.module('angular-meteor.settings', []).constant('$angularMeteorSettings', {\n\t  suppressWarnings: true\n\t});\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tangular.module('angular-meteor.ironrouter', []).run(['$compile', '$document', '$rootScope', function ($compile, $document, $rootScope) {\n\t  var Router = (Package['iron:router'] || {}).Router;\n\t  if (!Router) return;\n\n\t  var isLoaded = false;\n\n\t  // Recompile after iron:router builds page\n\t  Router.onAfterAction(function (req, res, next) {\n\t    Tracker.afterFlush(function () {\n\t      if (isLoaded) return;\n\t      $compile($document)($rootScope);\n\t      if (!$rootScope.$$phase) $rootScope.$apply();\n\t      isLoaded = true;\n\t    });\n\t  });\n\t}]);\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }; /*global\n\t                                                                                                                                                                                                                                                   angular, _, Tracker, EJSON, FS, Mongo\n\t                                                                                                                                                                                                                                                   */\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t'use strict';\n\n\tvar angularMeteorUtils = angular.module('angular-meteor.utils', ['angular-meteor.settings']);\n\n\tangularMeteorUtils.service('$meteorUtils', ['$q', '$timeout', '$angularMeteorSettings', function ($q, $timeout, $angularMeteorSettings) {\n\n\t  var self = this;\n\n\t  this.autorun = function (scope, fn) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.utils.autorun] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.6/autorun. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n\t    // wrapping around Deps.autorun\n\t    var comp = Tracker.autorun(function (c) {\n\t      fn(c);\n\t      // this is run immediately for the first call\n\t      // but after that, we need to $apply to start Angular digest\n\t      if (!c.firstRun) $timeout(angular.noop, 0);\n\t    });\n\n\t    // stop autorun when scope is destroyed\n\t    scope.$on('$destroy', function () {\n\t      comp.stop();\n\t    });\n\n\t    // return autorun object so that it can be stopped manually\n\t    return comp;\n\t  };\n\n\t  // Borrowed from angularFire\n\t  // https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\n\t  this.stripDollarPrefixedKeys = function (data) {\n\t    if (!_underscore2.default.isObject(data) || data instanceof Date || data instanceof File || EJSON.toJSONValue(data).$type === 'oid' || (typeof FS === 'undefined' ? 'undefined' : _typeof(FS)) === 'object' && data instanceof FS.File) return data;\n\n\t    var out = _underscore2.default.isArray(data) ? [] : {};\n\n\t    _underscore2.default.each(data, function (v, k) {\n\t      if (typeof k !== 'string' || k.charAt(0) !== '$') out[k] = self.stripDollarPrefixedKeys(v);\n\t    });\n\n\t    return out;\n\t  };\n\n\t  // Returns a callback which fulfills promise\n\t  this.fulfill = function (deferred, boundError, boundResult) {\n\t    return function (err, result) {\n\t      if (err) deferred.reject(boundError == null ? err : boundError);else if (typeof boundResult == \"function\") deferred.resolve(boundResult == null ? result : boundResult(result));else deferred.resolve(boundResult == null ? result : boundResult);\n\t    };\n\t  };\n\n\t  // creates a function which invokes method with the given arguments and returns a promise\n\t  this.promissor = function (obj, method) {\n\t    return function () {\n\t      var deferred = $q.defer();\n\t      var fulfill = self.fulfill(deferred);\n\t      var args = _underscore2.default.toArray(arguments).concat(fulfill);\n\t      obj[method].apply(obj, args);\n\t      return deferred.promise;\n\t    };\n\t  };\n\n\t  // creates a $q.all() promise and call digestion loop on fulfillment\n\t  this.promiseAll = function (promises) {\n\t    var allPromise = $q.all(promises);\n\n\t    allPromise.finally(function () {\n\t      // calls digestion loop with no conflicts\n\t      $timeout(angular.noop);\n\t    });\n\n\t    return allPromise;\n\t  };\n\n\t  this.getCollectionByName = function (string) {\n\t    return Mongo.Collection.get(string);\n\t  };\n\n\t  this.findIndexById = function (collection, doc) {\n\t    var foundDoc = _underscore2.default.find(collection, function (colDoc) {\n\t      // EJSON.equals used to compare Mongo.ObjectIDs and Strings.\n\t      return EJSON.equals(colDoc._id, doc._id);\n\t    });\n\n\t    return _underscore2.default.indexOf(collection, foundDoc);\n\t  };\n\t}]);\n\n\tangularMeteorUtils.run(['$rootScope', '$meteorUtils', function ($rootScope, $meteorUtils) {\n\t  Object.getPrototypeOf($rootScope).$meteorAutorun = function (fn) {\n\t    return $meteorUtils.autorun(this, fn);\n\t  };\n\t}]);\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, Meteor\n\t */\n\n\t'use strict';\n\n\tvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', ['angular-meteor.settings']);\n\n\tangularMeteorSubscribe.service('$meteorSubscribe', ['$q', '$angularMeteorSettings', function ($q, $angularMeteorSettings) {\n\n\t  var self = this;\n\n\t  this._subscribe = function (scope, deferred, args) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.subscribe] Please note that this module is deprecated since 1.3.0 and will be removed in 1.4.0! Replace it with the new syntax described here: http://www.angular-meteor.com/api/1.3.6/subscribe. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n\t    var subscription = null;\n\t    var lastArg = args[args.length - 1];\n\n\t    // User supplied onStop callback\n\t    // save it for later use and remove\n\t    // from subscription arguments\n\t    if (angular.isObject(lastArg) && angular.isFunction(lastArg.onStop)) {\n\t      var _onStop = lastArg.onStop;\n\n\t      args.pop();\n\t    }\n\n\t    args.push({\n\t      onReady: function onReady() {\n\t        deferred.resolve(subscription);\n\t      },\n\t      onStop: function onStop(err) {\n\t        if (!deferred.promise.$$state.status) {\n\t          if (err) deferred.reject(err);else deferred.reject(new Meteor.Error(\"Subscription Stopped\", \"Subscription stopped by a call to stop method. Either by the client or by the server.\"));\n\t        } else if (_onStop)\n\t          // After promise was resolved or rejected\n\t          // call user supplied onStop callback.\n\t          _onStop.apply(this, Array.prototype.slice.call(arguments));\n\t      }\n\t    });\n\n\t    subscription = Meteor.subscribe.apply(scope, args);\n\n\t    return subscription;\n\t  };\n\n\t  this.subscribe = function () {\n\t    var deferred = $q.defer();\n\t    var args = Array.prototype.slice.call(arguments);\n\t    var subscription = null;\n\n\t    self._subscribe(this, deferred, args);\n\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n\tangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe', function ($rootScope, $q, $meteorSubscribe) {\n\t  Object.getPrototypeOf($rootScope).$meteorSubscribe = function () {\n\t    var deferred = $q.defer();\n\t    var args = Array.prototype.slice.call(arguments);\n\n\t    var subscription = $meteorSubscribe._subscribe(this, deferred, args);\n\n\t    this.$on('$destroy', function () {\n\t      subscription.stop();\n\t    });\n\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t'use strict'; /*global\n\t               angular, _, Tracker, check, Match, Mongo\n\t               */\n\n\tvar angularMeteorCollection = angular.module('angular-meteor.collection', ['angular-meteor.stopper', 'angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray', 'angular-meteor.settings']);\n\n\t// The reason angular meteor collection is a factory function and not something\n\t// that inherit from array comes from here:\n\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\n\t// We went with the direct extensions approach.\n\tangularMeteorCollection.factory('AngularMeteorCollection', ['$q', '$meteorSubscribe', '$meteorUtils', '$rootScope', '$timeout', 'diffArray', '$angularMeteorSettings', function ($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, diffArray, $angularMeteorSettings) {\n\n\t  function AngularMeteorCollection(curDefFunc, collection, diffArrayFunc, autoClientSave) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorCollection] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorCollection. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n\t    var data = [];\n\t    // Server backup data to evaluate what changes come from client\n\t    // after each server update.\n\t    data._serverBackup = [];\n\t    // Array differ function.\n\t    data._diffArrayFunc = diffArrayFunc;\n\t    // Handler of the cursor observer.\n\t    data._hObserve = null;\n\t    // On new cursor autorun handler\n\t    // (autorun for reactive variables).\n\t    data._hNewCurAutorun = null;\n\t    // On new data autorun handler\n\t    // (autorun for cursor.fetch).\n\t    data._hDataAutorun = null;\n\n\t    if (angular.isDefined(collection)) {\n\t      data.$$collection = collection;\n\t    } else {\n\t      var cursor = curDefFunc();\n\t      data.$$collection = $meteorUtils.getCollectionByName(cursor.collection.name);\n\t    }\n\n\t    _underscore2.default.extend(data, AngularMeteorCollection);\n\t    data._startCurAutorun(curDefFunc, autoClientSave);\n\n\t    return data;\n\t  }\n\n\t  AngularMeteorCollection._startCurAutorun = function (curDefFunc, autoClientSave) {\n\t    var self = this;\n\n\t    self._hNewCurAutorun = Tracker.autorun(function () {\n\t      // When the reactive func gets recomputated we need to stop any previous\n\t      // observeChanges.\n\t      Tracker.onInvalidate(function () {\n\t        self._stopCursor();\n\t      });\n\n\t      if (autoClientSave) self._setAutoClientSave();\n\t      self._updateCursor(curDefFunc(), autoClientSave);\n\t    });\n\t  };\n\n\t  AngularMeteorCollection.subscribe = function () {\n\t    $meteorSubscribe.subscribe.apply(this, arguments);\n\t    return this;\n\t  };\n\n\t  AngularMeteorCollection.save = function (docs, useUnsetModifier) {\n\t    // save whole collection\n\t    if (!docs) docs = this;\n\t    // save single doc\n\t    docs = [].concat(docs);\n\n\t    var promises = docs.map(function (doc) {\n\t      return this._upsertDoc(doc, useUnsetModifier);\n\t    }, this);\n\n\t    return $meteorUtils.promiseAll(promises);\n\t  };\n\n\t  AngularMeteorCollection._upsertDoc = function (doc, useUnsetModifier) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var createFulfill = _underscore2.default.partial($meteorUtils.fulfill, deferred, null);\n\n\t    // delete $$hashkey\n\t    doc = $meteorUtils.stripDollarPrefixedKeys(doc);\n\t    var docId = doc._id;\n\t    var isExist = collection.findOne(docId);\n\n\t    // update\n\t    if (isExist) {\n\t      // Deletes _id property (from the copy) so that\n\t      // it can be $set using update.\n\t      delete doc._id;\n\t      var modifier = useUnsetModifier ? { $unset: doc } : { $set: doc };\n\t      // NOTE: do not use #upsert() method, since it does not exist in some collections\n\t      collection.update(docId, modifier, createFulfill(function () {\n\t        return { _id: docId, action: 'updated' };\n\t      }));\n\t    }\n\t    // insert\n\t    else {\n\t        collection.insert(doc, createFulfill(function (id) {\n\t          return { _id: id, action: 'inserted' };\n\t        }));\n\t      }\n\n\t    return deferred.promise;\n\t  };\n\n\t  // performs $pull operations parallely.\n\t  // used for handling splice operations returned from getUpdates() to prevent conflicts.\n\t  // see issue: https://github.com/Urigo/angular-meteor/issues/793\n\t  AngularMeteorCollection._updateDiff = function (selector, update, callback) {\n\t    callback = callback || angular.noop;\n\t    var setters = _underscore2.default.omit(update, '$pull');\n\t    var updates = [setters];\n\n\t    _underscore2.default.each(update.$pull, function (pull, prop) {\n\t      var puller = {};\n\t      puller[prop] = pull;\n\t      updates.push({ $pull: puller });\n\t    });\n\n\t    this._updateParallel(selector, updates, callback);\n\t  };\n\n\t  // performs each update operation parallely\n\t  AngularMeteorCollection._updateParallel = function (selector, updates, callback) {\n\t    var self = this;\n\t    var done = _underscore2.default.after(updates.length, callback);\n\n\t    var next = function next(err, affectedDocsNum) {\n\t      if (err) return callback(err);\n\t      done(null, affectedDocsNum);\n\t    };\n\n\t    _underscore2.default.each(updates, function (update) {\n\t      self.$$collection.update(selector, update, next);\n\t    });\n\t  };\n\n\t  AngularMeteorCollection.remove = function (keyOrDocs) {\n\t    var keys;\n\n\t    // remove whole collection\n\t    if (!keyOrDocs) {\n\t      keys = _underscore2.default.pluck(this, '_id');\n\t    }\n\t    // remove docs\n\t    else {\n\t        keyOrDocs = [].concat(keyOrDocs);\n\n\t        keys = _underscore2.default.map(keyOrDocs, function (keyOrDoc) {\n\t          return keyOrDoc._id || keyOrDoc;\n\t        });\n\t      }\n\n\t    // Checks if all keys are correct.\n\t    check(keys, [Match.OneOf(String, Mongo.ObjectID)]);\n\n\t    var promises = keys.map(function (key) {\n\t      return this._removeDoc(key);\n\t    }, this);\n\n\t    return $meteorUtils.promiseAll(promises);\n\t  };\n\n\t  AngularMeteorCollection._removeDoc = function (id) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var fulfill = $meteorUtils.fulfill(deferred, null, { _id: id, action: 'removed' });\n\t    collection.remove(id, fulfill);\n\t    return deferred.promise;\n\t  };\n\n\t  AngularMeteorCollection._updateCursor = function (cursor, autoClientSave) {\n\t    var self = this;\n\t    // XXX - consider adding an option for a non-orderd result for faster performance\n\t    if (self._hObserve) self._stopObserving();\n\n\t    self._hObserve = cursor.observe({\n\t      addedAt: function addedAt(doc, atIndex) {\n\t        self.splice(atIndex, 0, doc);\n\t        self._serverBackup.splice(atIndex, 0, doc);\n\t        self._setServerUpdateMode();\n\t      },\n\n\t      changedAt: function changedAt(doc, oldDoc, atIndex) {\n\t        diffArray.deepCopyChanges(self[atIndex], doc);\n\t        diffArray.deepCopyRemovals(self[atIndex], doc);\n\t        self._serverBackup[atIndex] = self[atIndex];\n\t        self._setServerUpdateMode();\n\t      },\n\n\t      movedTo: function movedTo(doc, fromIndex, toIndex) {\n\t        self.splice(fromIndex, 1);\n\t        self.splice(toIndex, 0, doc);\n\t        self._serverBackup.splice(fromIndex, 1);\n\t        self._serverBackup.splice(toIndex, 0, doc);\n\t        self._setServerUpdateMode();\n\t      },\n\n\t      removedAt: function removedAt(oldDoc) {\n\t        var removedIndex = $meteorUtils.findIndexById(self, oldDoc);\n\n\t        if (removedIndex != -1) {\n\t          self.splice(removedIndex, 1);\n\t          self._serverBackup.splice(removedIndex, 1);\n\t          self._setServerUpdateMode();\n\t        } else {\n\t          // If it's been removed on client then it's already not in collection\n\t          // itself but still is in the _serverBackup.\n\t          removedIndex = $meteorUtils.findIndexById(self._serverBackup, oldDoc);\n\n\t          if (removedIndex != -1) {\n\t            self._serverBackup.splice(removedIndex, 1);\n\t          }\n\t        }\n\t      }\n\t    });\n\n\t    self._hDataAutorun = Tracker.autorun(function () {\n\t      cursor.fetch();\n\t      if (self._serverMode) self._unsetServerUpdateMode(autoClientSave);\n\t    });\n\t  };\n\n\t  AngularMeteorCollection._stopObserving = function () {\n\t    this._hObserve.stop();\n\t    this._hDataAutorun.stop();\n\t    delete this._serverMode;\n\t    delete this._hUnsetTimeout;\n\t  };\n\n\t  AngularMeteorCollection._setServerUpdateMode = function (name) {\n\t    this._serverMode = true;\n\t    // To simplify server update logic, we don't follow\n\t    // updates from the client at the same time.\n\t    this._unsetAutoClientSave();\n\t  };\n\n\t  // Here we use $timeout to combine multiple updates that go\n\t  // each one after another.\n\t  AngularMeteorCollection._unsetServerUpdateMode = function (autoClientSave) {\n\t    var self = this;\n\n\t    if (self._hUnsetTimeout) {\n\t      $timeout.cancel(self._hUnsetTimeout);\n\t      self._hUnsetTimeout = null;\n\t    }\n\n\t    self._hUnsetTimeout = $timeout(function () {\n\t      self._serverMode = false;\n\t      // Finds updates that was potentially done from the client side\n\t      // and saves them.\n\t      var changes = diffArray.getChanges(self, self._serverBackup, self._diffArrayFunc);\n\t      self._saveChanges(changes);\n\t      // After, continues following client updates.\n\t      if (autoClientSave) self._setAutoClientSave();\n\t    }, 0);\n\t  };\n\n\t  AngularMeteorCollection.stop = function () {\n\t    this._stopCursor();\n\t    this._hNewCurAutorun.stop();\n\t  };\n\n\t  AngularMeteorCollection._stopCursor = function () {\n\t    this._unsetAutoClientSave();\n\n\t    if (this._hObserve) {\n\t      this._hObserve.stop();\n\t      this._hDataAutorun.stop();\n\t    }\n\n\t    this.splice(0);\n\t    this._serverBackup.splice(0);\n\t  };\n\n\t  AngularMeteorCollection._unsetAutoClientSave = function (name) {\n\t    if (this._hRegAutoBind) {\n\t      this._hRegAutoBind();\n\t      this._hRegAutoBind = null;\n\t    }\n\t  };\n\n\t  AngularMeteorCollection._setAutoClientSave = function () {\n\t    var self = this;\n\n\t    // Always unsets auto save to keep only one $watch handler.\n\t    self._unsetAutoClientSave();\n\n\t    self._hRegAutoBind = $rootScope.$watch(function () {\n\t      return self;\n\t    }, function (nItems, oItems) {\n\t      if (nItems === oItems) return;\n\n\t      var changes = diffArray.getChanges(self, oItems, self._diffArrayFunc);\n\t      self._unsetAutoClientSave();\n\t      self._saveChanges(changes);\n\t      self._setAutoClientSave();\n\t    }, true);\n\t  };\n\n\t  AngularMeteorCollection._saveChanges = function (changes) {\n\t    var self = this;\n\n\t    // Saves added documents\n\t    // Using reversed iteration to prevent indexes from changing during splice\n\t    var addedDocs = changes.added.reverse().map(function (descriptor) {\n\t      self.splice(descriptor.index, 1);\n\t      return descriptor.item;\n\t    });\n\n\t    if (addedDocs.length) self.save(addedDocs);\n\n\t    // Removes deleted documents\n\t    var removedDocs = changes.removed.map(function (descriptor) {\n\t      return descriptor.item;\n\t    });\n\n\t    if (removedDocs.length) self.remove(removedDocs);\n\n\t    // Updates changed documents\n\t    changes.changed.forEach(function (descriptor) {\n\t      self._updateDiff(descriptor.selector, descriptor.modifier);\n\t    });\n\t  };\n\n\t  return AngularMeteorCollection;\n\t}]);\n\n\tangularMeteorCollection.factory('$meteorCollectionFS', ['$meteorCollection', 'diffArray', '$angularMeteorSettings', function ($meteorCollection, diffArray, $angularMeteorSettings) {\n\t  function $meteorCollectionFS(reactiveFunc, autoClientSave, collection) {\n\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorCollectionFS] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/files. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    return new $meteorCollection(reactiveFunc, autoClientSave, collection, diffArray.shallow);\n\t  }\n\n\t  return $meteorCollectionFS;\n\t}]);\n\n\tangularMeteorCollection.factory('$meteorCollection', ['AngularMeteorCollection', '$rootScope', 'diffArray', function (AngularMeteorCollection, $rootScope, diffArray) {\n\t  function $meteorCollection(reactiveFunc, autoClientSave, collection, diffFn) {\n\t    // Validate parameters\n\t    if (!reactiveFunc) {\n\t      throw new TypeError('The first argument of $meteorCollection is undefined.');\n\t    }\n\n\t    if (!(angular.isFunction(reactiveFunc) || angular.isFunction(reactiveFunc.find))) {\n\t      throw new TypeError('The first argument of $meteorCollection must be a function or ' + 'a have a find function property.');\n\t    }\n\n\t    if (!angular.isFunction(reactiveFunc)) {\n\t      collection = angular.isDefined(collection) ? collection : reactiveFunc;\n\t      reactiveFunc = _underscore2.default.bind(reactiveFunc.find, reactiveFunc);\n\t    }\n\n\t    // By default auto save - true.\n\t    autoClientSave = angular.isDefined(autoClientSave) ? autoClientSave : true;\n\t    diffFn = diffFn || diffArray;\n\t    return new AngularMeteorCollection(reactiveFunc, collection, diffFn, autoClientSave);\n\t  }\n\n\t  return $meteorCollection;\n\t}]);\n\n\tangularMeteorCollection.run(['$rootScope', '$meteorCollection', '$meteorCollectionFS', '$meteorStopper', function ($rootScope, $meteorCollection, $meteorCollectionFS, $meteorStopper) {\n\t  var scopeProto = Object.getPrototypeOf($rootScope);\n\t  scopeProto.$meteorCollection = $meteorStopper($meteorCollection);\n\t  scopeProto.$meteorCollectionFS = $meteorStopper($meteorCollectionFS);\n\t}]);\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t'use strict'; /*global\n\t                angular, _, Mongo\n\t              */\n\n\tvar angularMeteorObject = angular.module('angular-meteor.object', ['angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'getUpdates', 'diffArray', 'angular-meteor.settings']);\n\n\tangularMeteorObject.factory('AngularMeteorObject', ['$q', '$meteorSubscribe', '$meteorUtils', 'diffArray', 'getUpdates', 'AngularMeteorCollection', '$angularMeteorSettings', function ($q, $meteorSubscribe, $meteorUtils, diffArray, getUpdates, AngularMeteorCollection, $angularMeteorSettings) {\n\n\t  // A list of internals properties to not watch for, nor pass to the Document on update and etc.\n\t  AngularMeteorObject.$$internalProps = ['$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', '$$scope', 'bind', 'save', 'reset', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject', '_auto', '_setAutos', '_eventEmitter', '_serverBackup', '_updateDiff', '_updateParallel', '_getId'];\n\n\t  function AngularMeteorObject(collection, selector, options) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorObject] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorObject. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    // Make data not be an object so we can extend it to preserve\n\t    // Collection Helpers and the like\n\t    var helpers = collection._helpers;\n\t    var data = _underscore2.default.isFunction(helpers) ? Object.create(helpers.prototype) : {};\n\t    var doc = collection.findOne(selector, options);\n\t    var collectionExtension = _underscore2.default.pick(AngularMeteorCollection, '_updateParallel');\n\t    _underscore2.default.extend(data, doc);\n\t    _underscore2.default.extend(data, AngularMeteorObject);\n\t    _underscore2.default.extend(data, collectionExtension);\n\n\t    // Omit options that may spoil document finding\n\t    data.$$options = _underscore2.default.omit(options, 'skip', 'limit');\n\t    data.$$collection = collection;\n\t    data.$$id = data._getId(selector);\n\t    data._serverBackup = doc || {};\n\n\t    return data;\n\t  }\n\n\t  AngularMeteorObject.getRawObject = function () {\n\t    return angular.copy(_underscore2.default.omit(this, this.$$internalProps));\n\t  };\n\n\t  AngularMeteorObject.subscribe = function () {\n\t    $meteorSubscribe.subscribe.apply(this, arguments);\n\t    return this;\n\t  };\n\n\t  AngularMeteorObject.save = function (custom) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var createFulfill = _underscore2.default.partial($meteorUtils.fulfill, deferred, null);\n\t    var oldDoc = collection.findOne(this.$$id);\n\t    var mods;\n\n\t    // update\n\t    if (oldDoc) {\n\t      if (custom) mods = { $set: custom };else {\n\t        mods = getUpdates(oldDoc, this.getRawObject());\n\t        // If there are no updates, there is nothing to do here, returning\n\t        if (_underscore2.default.isEmpty(mods)) {\n\t          return $q.when({ action: 'updated' });\n\t        }\n\t      }\n\n\t      // NOTE: do not use #upsert() method, since it does not exist in some collections\n\t      this._updateDiff(mods, createFulfill({ action: 'updated' }));\n\t    }\n\t    // insert\n\t    else {\n\t        if (custom) mods = _underscore2.default.clone(custom);else mods = this.getRawObject();\n\n\t        mods._id = mods._id || this.$$id;\n\t        collection.insert(mods, createFulfill({ action: 'inserted' }));\n\t      }\n\n\t    return deferred.promise;\n\t  };\n\n\t  AngularMeteorObject._updateDiff = function (update, callback) {\n\t    var selector = this.$$id;\n\t    AngularMeteorCollection._updateDiff.call(this, selector, update, callback);\n\t  };\n\n\t  AngularMeteorObject.reset = function (keepClientProps) {\n\t    var self = this;\n\t    var options = this.$$options;\n\t    var id = this.$$id;\n\t    var doc = this.$$collection.findOne(id, options);\n\n\t    if (doc) {\n\t      // extend SubObject\n\t      var docKeys = _underscore2.default.keys(doc);\n\t      var docExtension = _underscore2.default.pick(doc, docKeys);\n\t      var clientProps;\n\n\t      _underscore2.default.extend(self, docExtension);\n\t      _underscore2.default.extend(self._serverBackup, docExtension);\n\n\t      if (keepClientProps) {\n\t        clientProps = _underscore2.default.intersection(_underscore2.default.keys(self), _underscore2.default.keys(self._serverBackup));\n\t      } else {\n\t        clientProps = _underscore2.default.keys(self);\n\t      }\n\n\t      var serverProps = _underscore2.default.keys(doc);\n\t      var removedKeys = _underscore2.default.difference(clientProps, serverProps, self.$$internalProps);\n\n\t      removedKeys.forEach(function (prop) {\n\t        delete self[prop];\n\t        delete self._serverBackup[prop];\n\t      });\n\t    } else {\n\t      _underscore2.default.keys(this.getRawObject()).forEach(function (prop) {\n\t        delete self[prop];\n\t      });\n\n\t      self._serverBackup = {};\n\t    }\n\t  };\n\n\t  AngularMeteorObject.stop = function () {\n\t    if (this.unregisterAutoDestroy) this.unregisterAutoDestroy();\n\n\t    if (this.unregisterAutoBind) this.unregisterAutoBind();\n\n\t    if (this.autorunComputation && this.autorunComputation.stop) this.autorunComputation.stop();\n\t  };\n\n\t  AngularMeteorObject._getId = function (selector) {\n\t    var options = _underscore2.default.extend({}, this.$$options, {\n\t      fields: { _id: 1 },\n\t      reactive: false,\n\t      transform: null\n\t    });\n\n\t    var doc = this.$$collection.findOne(selector, options);\n\n\t    if (doc) return doc._id;\n\t    if (selector instanceof Mongo.ObjectID) return selector;\n\t    if (_underscore2.default.isString(selector)) return selector;\n\t    return new Mongo.ObjectID();\n\t  };\n\n\t  return AngularMeteorObject;\n\t}]);\n\n\tangularMeteorObject.factory('$meteorObject', ['$rootScope', '$meteorUtils', 'getUpdates', 'AngularMeteorObject', function ($rootScope, $meteorUtils, getUpdates, AngularMeteorObject) {\n\t  function $meteorObject(collection, id, auto, options) {\n\t    // Validate parameters\n\t    if (!collection) {\n\t      throw new TypeError(\"The first argument of $meteorObject is undefined.\");\n\t    }\n\n\t    if (!angular.isFunction(collection.findOne)) {\n\t      throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\n\t    }\n\n\t    var data = new AngularMeteorObject(collection, id, options);\n\t    // Making auto default true - http://stackoverflow.com/a/15464208/1426570\n\t    data._auto = auto !== false;\n\t    _underscore2.default.extend(data, $meteorObject);\n\t    data._setAutos();\n\t    return data;\n\t  }\n\n\t  $meteorObject._setAutos = function () {\n\t    var self = this;\n\n\t    this.autorunComputation = $meteorUtils.autorun($rootScope, function () {\n\t      self.reset(true);\n\t    });\n\n\t    // Deep watches the model and performs autobind\n\t    this.unregisterAutoBind = this._auto && $rootScope.$watch(function () {\n\t      return self.getRawObject();\n\t    }, function (item, oldItem) {\n\t      if (item !== oldItem) self.save();\n\t    }, true);\n\n\t    this.unregisterAutoDestroy = $rootScope.$on('$destroy', function () {\n\t      if (self && self.stop) self.pop();\n\t    });\n\t  };\n\n\t  return $meteorObject;\n\t}]);\n\n\tangularMeteorObject.run(['$rootScope', '$meteorObject', '$meteorStopper', function ($rootScope, $meteorObject, $meteorStopper) {\n\t  var scopeProto = Object.getPrototypeOf($rootScope);\n\t  scopeProto.$meteorObject = $meteorStopper($meteorObject);\n\t}]);\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t'use strict'; /*global\n\t               angular, _, Package, Meteor\n\t               */\n\n\tvar angularMeteorUser = angular.module('angular-meteor.user', ['angular-meteor.utils', 'angular-meteor.core', 'angular-meteor.settings']);\n\n\t// requires package 'accounts-password'\n\tangularMeteorUser.service('$meteorUser', ['$rootScope', '$meteorUtils', '$q', '$angularMeteorSettings', function ($rootScope, $meteorUtils, $q, $angularMeteorSettings) {\n\n\t  var pack = Package['accounts-base'];\n\t  if (!pack) return;\n\n\t  var self = this;\n\t  var Accounts = pack.Accounts;\n\n\t  this.waitForUser = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.waitForUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n\t    var deferred = $q.defer();\n\n\t    $meteorUtils.autorun($rootScope, function () {\n\t      if (!Meteor.loggingIn()) deferred.resolve(Meteor.user());\n\t    }, true);\n\n\t    return deferred.promise;\n\t  };\n\n\t  this.requireUser = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) {\n\t      console.warn('[angular-meteor.requireUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    }\n\n\t    var deferred = $q.defer();\n\n\t    $meteorUtils.autorun($rootScope, function () {\n\t      if (!Meteor.loggingIn()) {\n\t        if (Meteor.user() === null) deferred.reject(\"AUTH_REQUIRED\");else deferred.resolve(Meteor.user());\n\t      }\n\t    }, true);\n\n\t    return deferred.promise;\n\t  };\n\n\t  this.requireValidUser = function (validatorFn) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.requireValidUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n\t    return self.requireUser(true).then(function (user) {\n\t      var valid = validatorFn(user);\n\n\t      if (valid === true) return user;else if (typeof valid === \"string\") return $q.reject(valid);else return $q.reject(\"FORBIDDEN\");\n\t    });\n\t  };\n\n\t  this.loginWithPassword = $meteorUtils.promissor(Meteor, 'loginWithPassword');\n\t  this.createUser = $meteorUtils.promissor(Accounts, 'createUser');\n\t  this.changePassword = $meteorUtils.promissor(Accounts, 'changePassword');\n\t  this.forgotPassword = $meteorUtils.promissor(Accounts, 'forgotPassword');\n\t  this.resetPassword = $meteorUtils.promissor(Accounts, 'resetPassword');\n\t  this.verifyEmail = $meteorUtils.promissor(Accounts, 'verifyEmail');\n\t  this.logout = $meteorUtils.promissor(Meteor, 'logout');\n\t  this.logoutOtherClients = $meteorUtils.promissor(Meteor, 'logoutOtherClients');\n\t  this.loginWithFacebook = $meteorUtils.promissor(Meteor, 'loginWithFacebook');\n\t  this.loginWithTwitter = $meteorUtils.promissor(Meteor, 'loginWithTwitter');\n\t  this.loginWithGoogle = $meteorUtils.promissor(Meteor, 'loginWithGoogle');\n\t  this.loginWithGithub = $meteorUtils.promissor(Meteor, 'loginWithGithub');\n\t  this.loginWithMeteorDeveloperAccount = $meteorUtils.promissor(Meteor, 'loginWithMeteorDeveloperAccount');\n\t  this.loginWithMeetup = $meteorUtils.promissor(Meteor, 'loginWithMeetup');\n\t  this.loginWithWeibo = $meteorUtils.promissor(Meteor, 'loginWithWeibo');\n\t}]);\n\n\tangularMeteorUser.run(['$rootScope', '$angularMeteorSettings', '$$Core', function ($rootScope, $angularMeteorSettings, $$Core) {\n\n\t  var ScopeProto = Object.getPrototypeOf($rootScope);\n\t  _underscore2.default.extend(ScopeProto, $$Core);\n\n\t  $rootScope.autorun(function () {\n\t    if (!Meteor.user) return;\n\t    $rootScope.currentUser = Meteor.user();\n\t    $rootScope.loggingIn = Meteor.loggingIn();\n\t  });\n\t}]);\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t'use strict'; /*global\n\t               angular, _, Meteor\n\t               */\n\n\tvar angularMeteorMethods = angular.module('angular-meteor.methods', ['angular-meteor.utils', 'angular-meteor.settings']);\n\n\tangularMeteorMethods.service('$meteorMethods', ['$q', '$meteorUtils', '$angularMeteorSettings', function ($q, $meteorUtils, $angularMeteorSettings) {\n\t  this.call = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteor.call] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/methods. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n\t    var deferred = $q.defer();\n\t    var fulfill = $meteorUtils.fulfill(deferred);\n\t    var args = _underscore2.default.toArray(arguments).concat(fulfill);\n\t    Meteor.call.apply(this, args);\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, Session\n\t */\n\n\t'use strict';\n\n\tvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils', 'angular-meteor.settings']);\n\n\tangularMeteorSession.factory('$meteorSession', ['$meteorUtils', '$parse', '$angularMeteorSettings', function ($meteorUtils, $parse, $angularMeteorSettings) {\n\t  return function (session) {\n\n\t    return {\n\n\t      bind: function bind(scope, model) {\n\t        if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.session.bind] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://www.angular-meteor.com/api/1.3.0/session. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n\t        var getter = $parse(model);\n\t        var setter = getter.assign;\n\t        $meteorUtils.autorun(scope, function () {\n\t          setter(scope, Session.get(session));\n\t        });\n\n\t        scope.$watch(model, function (newItem, oldItem) {\n\t          Session.set(session, getter(scope));\n\t        }, true);\n\t      }\n\t    };\n\t  };\n\t}]);\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, Package\n\t */\n\n\t'use strict';\n\n\tvar angularMeteorCamera = angular.module('angular-meteor.camera', ['angular-meteor.utils', 'angular-meteor.settings']);\n\n\t// requires package 'mdg:camera'\n\tangularMeteorCamera.service('$meteorCamera', ['$q', '$meteorUtils', '$angularMeteorSettings', function ($q, $meteorUtils, $angularMeteorSettings) {\n\t  if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t  var pack = Package['mdg:camera'];\n\t  if (!pack) return;\n\n\t  var MeteorCamera = pack.MeteorCamera;\n\n\t  this.getPicture = function (options) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n\t    options = options || {};\n\t    var deferred = $q.defer();\n\t    MeteorCamera.getPicture(options, $meteorUtils.fulfill(deferred));\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular\n\t */\n\n\t'use strict';\n\n\tvar angularMeteorStopper = angular.module('angular-meteor.stopper', ['angular-meteor.subscribe']);\n\n\tangularMeteorStopper.factory('$meteorStopper', ['$q', '$meteorSubscribe', function ($q, $meteorSubscribe) {\n\t  function $meteorStopper($meteorEntity) {\n\t    return function () {\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var meteorEntity = $meteorEntity.apply(this, args);\n\n\t      angular.extend(meteorEntity, $meteorStopper);\n\t      meteorEntity.$$scope = this;\n\n\t      this.$on('$destroy', function () {\n\t        meteorEntity.stop();\n\t        if (meteorEntity.subscription) meteorEntity.subscription.stop();\n\t      });\n\n\t      return meteorEntity;\n\t    };\n\t  }\n\n\t  $meteorStopper.subscribe = function () {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    this.subscription = $meteorSubscribe._subscribe(this.$$scope, $q.defer(), args);\n\t    return this;\n\t  };\n\n\t  return $meteorStopper;\n\t}]);\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.utils = exports.name = undefined;\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar name = exports.name = 'angular-meteor.utilities';\n\tvar utils = exports.utils = '$$utils';\n\n\tangular.module(name, [])\n\n\t/*\n\t  A utility service which is provided with general utility functions\n\t */\n\t.service(utils, ['$rootScope', function ($rootScope) {\n\t  var self = this;\n\n\t  // Checks if an object is a cursor\n\t  this.isCursor = function (obj) {\n\t    return obj instanceof Meteor.Collection.Cursor;\n\t  };\n\n\t  // Cheecks if an object is a scope\n\t  this.isScope = function (obj) {\n\t    return obj instanceof $rootScope.constructor;\n\t  };\n\n\t  // Checks if an object is a view model\n\t  this.isViewModel = function (obj) {\n\t    return _underscore2.default.isObject(obj) && obj.$$dependencies;\n\t  };\n\n\t  // Checks if two objects are siblings\n\t  this.areSiblings = function (obj1, obj2) {\n\t    return _underscore2.default.isObject(obj1) && _underscore2.default.isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t  };\n\n\t  // Binds function into a scpecified context. If an object is provided, will bind every\n\t  // value in the object which is a function. If a tap function is provided, it will be\n\t  // called right after the function has been invoked.\n\t  this.bind = function (fn, context, tap) {\n\t    tap = _underscore2.default.isFunction(tap) ? tap : angular.noop;\n\t    if (_underscore2.default.isFunction(fn)) return bindFn(fn, context, tap);\n\t    if (_underscore2.default.isObject(fn)) return bindObj(fn, context, tap);\n\t    return fn;\n\t  };\n\n\t  function bindFn(fn, context, tap) {\n\t    return function () {\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\n\t      var result = fn.apply(context, args);\n\t      tap.call(context, {\n\t        result: result,\n\t        args: args\n\t      });\n\t      return result;\n\t    };\n\t  }\n\n\t  function bindObj(obj, context, tap) {\n\t    return _underscore2.default.keys(obj).reduce(function (bound, k) {\n\t      bound[k] = self.bind(obj[k], context, tap);\n\t      return bound;\n\t    }, {});\n\t  }\n\t}]);\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Mixer = exports.name = undefined;\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\tvar name = exports.name = 'angular-meteor.mixer';\n\tvar Mixer = exports.Mixer = '$Mixer';\n\n\tangular.module(name, [])\n\n\t/*\n\t  A service which lets us apply mixins into Scope.prototype.\n\t  The flow is simple. Once we define a mixin, it will be stored in the `$Mixer`,\n\t  and any time a `ChildScope` prototype is created\n\t  it will be extended by the `$Mixer`.\n\t  This concept is good because it keeps our code\n\t  clean and simple, and easy to extend.\n\t  So any time we would like to define a new behaviour to our scope,\n\t  we will just use the `$Mixer` service.\n\t */\n\t.service(Mixer, function () {\n\t  var _this = this;\n\n\t  // Used to store method's caller\n\t  var caller = undefined;\n\n\t  this._mixins = [];\n\t  // Apply mixins automatically on specified contexts\n\t  this._autoExtend = [];\n\t  this._autoConstruct = [];\n\n\t  // Adds a new mixin\n\t  this.mixin = function (mixin) {\n\t    if (!_underscore2.default.isObject(mixin)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\n\t    _this._mixins = _underscore2.default.union(_this._mixins, [mixin]);\n\t    // Apply mixins to stored contexts\n\t    _this._autoExtend.forEach(function (context) {\n\t      return _this._extend(context);\n\t    });\n\t    _this._autoConstruct.forEach(function (context) {\n\t      return _this._construct(context);\n\t    });\n\t    return _this;\n\t  };\n\n\t  // Removes a mixin. Useful mainly for test purposes\n\t  this._mixout = function (mixin) {\n\t    _this._mixins = _underscore2.default.without(_this._mixins, mixin);\n\t    return _this;\n\t  };\n\n\t  // Invoke function mixins with the provided context and arguments\n\t  this._construct = function (context) {\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\n\t    _this._mixins.filter(_underscore2.default.isFunction).forEach(function (mixin) {\n\t      mixin.call.apply(mixin, [context].concat(args));\n\t    });\n\n\t    return context;\n\t  };\n\n\t  // Extend prototype with the defined mixins\n\t  this._extend = function (obj, options) {\n\t    var _$defaults = _underscore2.default.defaults({}, options, {\n\t      pattern: /.*/ });\n\n\t    var pattern = _$defaults.pattern;\n\t    var context = _$defaults.context;\n\t    // The patterns of the keys which will be filtered\n\n\n\t    var mixins = _this._mixins.map(function (mixin) {\n\t      // Filtering the keys by the specified pattern\n\t      var keys = _underscore2.default.keys(mixin).filter(function (k) {\n\t        return k.match(pattern);\n\t      }).filter(function (k) {\n\t        return _underscore2.default.isFunction(mixin[k]);\n\t      });\n\n\t      return keys.reduce(function (boundMixin, methodName) {\n\t        var methodHandler = mixin[methodName];\n\n\t        // Note that this is not an arrow function so we can conserve the conetxt\n\t        boundMixin[methodName] = function () {\n\t          // Storing original caller so we will know who actually called the\n\t          // method event though it is bound to another context\n\t          var methodContext = context || this;\n\t          var recentCaller = caller;\n\t          caller = this;\n\n\t          try {\n\t            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t              args[_key2] = arguments[_key2];\n\t            }\n\n\t            return methodHandler.apply(methodContext, args);\n\t          } finally {\n\t            // No matter what happens, restore variable to the previous one\n\t            caller = recentCaller;\n\t          }\n\t        };\n\n\t        return boundMixin;\n\t      }, {});\n\t    });\n\n\t    return _underscore2.default.extend.apply(_underscore2.default, [obj].concat(_toConsumableArray(mixins)));\n\t  };\n\n\t  // Caller property can not be set\n\t  Object.defineProperty(this, 'caller', {\n\t    configurable: true,\n\t    enumerable: true,\n\n\t    get: function get() {\n\t      return caller;\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.name = undefined;\n\n\tvar _mixer = __webpack_require__(17);\n\n\tvar name = exports.name = 'angular-meteor.scope';\n\n\tangular.module(name, [_mixer.name]).run(['$rootScope', _mixer.Mixer, function ($rootScope, $Mixer) {\n\t  var Scope = $rootScope.constructor;\n\t  var $new = $rootScope.$new;\n\n\t  // Apply extensions whether a mixin in defined.\n\t  // Note that this way mixins which are initialized later\n\t  // can be applied on rootScope.\n\t  $Mixer._autoExtend.push(Scope.prototype);\n\t  $Mixer._autoConstruct.push($rootScope);\n\n\t  Scope.prototype.$new = function () {\n\t    var scope = $new.apply(this, arguments);\n\t    // Apply constructors to newly created scopes\n\t    return $Mixer._construct(scope);\n\t  };\n\t}]);\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Core = exports.name = undefined;\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tvar _utils = __webpack_require__(16);\n\n\tvar _mixer = __webpack_require__(17);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\tvar name = exports.name = 'angular-meteor.core';\n\tvar Core = exports.Core = '$$Core';\n\n\tangular.module(name, [_utils.name, _mixer.name])\n\n\t/*\n\t  A mixin which provides us with core Meteor functions.\n\t */\n\t.factory(Core, ['$q', _utils.utils, _mixer.Mixer, function ($q, $$utils, $Mixer) {\n\t  function $$Core() {}\n\n\t  // Calls Meteor.autorun() which will be digested after each run and automatically destroyed\n\t  $$Core.autorun = function (fn) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t    fn = this.$bindToContext($Mixer.caller, fn);\n\n\t    if (!_underscore2.default.isFunction(fn)) {\n\t      throw Error('argument 1 must be a function');\n\t    }\n\t    if (!_underscore2.default.isObject(options)) {\n\t      throw Error('argument 2 must be an object');\n\t    }\n\n\t    var computation = Tracker.autorun(fn, options);\n\t    // Reset to a function that will also stop the listener we just added\n\t    computation.stop = this.$$autoStop(computation);\n\t    return computation;\n\t  };\n\n\t  // Calls Meteor.subscribe() which will be digested after each invokation\n\t  // and automatically destroyed\n\t  $$Core.subscribe = function (subName, fn, cb) {\n\t    fn = this.$bindToContext($Mixer.caller, fn || angular.noop);\n\t    cb = cb ? this.$bindToContext($Mixer.caller, cb) : angular.noop;\n\n\t    // Additional callbacks specific for this library\n\t    // onStart - right after Meteor.subscribe()\n\t    var hooks = {\n\t      onStart: angular.noop\n\t    };\n\n\t    if (!_underscore2.default.isString(subName)) {\n\t      throw Error('argument 1 must be a string');\n\t    }\n\t    if (!_underscore2.default.isFunction(fn)) {\n\t      throw Error('argument 2 must be a function');\n\t    }\n\t    if (!_underscore2.default.isFunction(cb) && !_underscore2.default.isObject(cb)) {\n\t      throw Error('argument 3 must be a function or an object');\n\t    }\n\n\t    if (_underscore2.default.isObject(cb)) {\n\t      for (var hook in hooks) {\n\t        if (hooks.hasOwnProperty(hook) && cb[hook]) {\n\t          // Don't use any of additional callbacks in Meteor.subscribe\n\t          hooks[hook] = cb[hook];\n\t          delete cb[hook];\n\t        }\n\t      }\n\t    }\n\n\t    var result = {};\n\n\t    var computation = this.autorun(function () {\n\t      var _Meteor;\n\n\t      var args = fn();\n\t      if (angular.isUndefined(args)) args = [];\n\n\t      if (!_underscore2.default.isArray(args)) {\n\t        throw Error('reactive function\\'s return value must be an array');\n\t      }\n\n\t      var subscription = (_Meteor = Meteor).subscribe.apply(_Meteor, [subName].concat(_toConsumableArray(args), [cb]));\n\n\t      hooks.onStart();\n\n\t      result.ready = subscription.ready.bind(subscription);\n\t      result.subscriptionId = subscription.subscriptionId;\n\t    });\n\n\t    // Once the computation has been stopped,\n\t    // any subscriptions made inside will be stopped as well\n\t    result.stop = computation.stop.bind(computation);\n\t    return result;\n\t  };\n\n\t  // Calls Meteor.call() wrapped by a digestion cycle\n\t  $$Core.callMethod = function () {\n\t    var _Meteor2;\n\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\n\t    var fn = args.pop();\n\t    if (_underscore2.default.isFunction(fn)) fn = this.$bindToContext($Mixer.caller, fn);\n\t    return (_Meteor2 = Meteor).call.apply(_Meteor2, args.concat([fn]));\n\t  };\n\n\t  // Calls Meteor.apply() wrapped by a digestion cycle\n\t  $$Core.applyMethod = function () {\n\t    var _Meteor3;\n\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\n\t    var fn = args.pop();\n\t    if (_underscore2.default.isFunction(fn)) fn = this.$bindToContext($Mixer.caller, fn);\n\t    return (_Meteor3 = Meteor).apply.apply(_Meteor3, args.concat([fn]));\n\t  };\n\n\t  // Stops a process once the scope has been destroyed\n\t  $$Core.$$autoStop = function (stoppable) {\n\t    var removeListener = undefined;\n\t    var baseStop = stoppable.stop.bind(stoppable);\n\n\t    // Once the process has been stopped the destroy event listener will be removed\n\t    // to avoid memory leaks and unexpected behaviours\n\t    var stop = function stop() {\n\t      removeListener();\n\t      return baseStop.apply(undefined, arguments);\n\t    };\n\n\t    removeListener = this.$on('$destroy', stop);\n\t    return stop;\n\t  };\n\n\t  // Digests scope only if there is no phase at the moment\n\t  $$Core.$$throttledDigest = function () {\n\t    var isDigestable = !this.$$destroyed && !this.$$phase && !this.$root.$$phase;\n\n\t    if (isDigestable) this.$digest();\n\t  };\n\n\t  // Creates a promise only that the digestion cycle will be called at its fulfillment\n\t  $$Core.$$defer = function () {\n\t    var deferred = $q.defer();\n\t    // Once promise has been fulfilled, digest\n\t    deferred.promise = deferred.promise.finally(this.$$throttledDigest.bind(this));\n\t    return deferred;\n\t  };\n\n\t  // Binds an object or a function to the provided context and digest it once it is invoked\n\t  $$Core.$bindToContext = function (context, fn) {\n\t    if (_underscore2.default.isFunction(context)) {\n\t      fn = context;\n\t      context = this;\n\t    }\n\n\t    return $$utils.bind(fn, context, this.$$throttledDigest.bind(this));\n\t  };\n\n\t  return $$Core;\n\t}]);\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.reactive = exports.ViewModel = exports.name = undefined;\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tvar _utils = __webpack_require__(16);\n\n\tvar _mixer = __webpack_require__(17);\n\n\tvar _core = __webpack_require__(19);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar name = exports.name = 'angular-meteor.view-model';\n\tvar ViewModel = exports.ViewModel = '$$ViewModel';\n\tvar reactive = exports.reactive = '$reactive';\n\n\tangular.module(name, [_utils.name, _mixer.name, _core.name])\n\n\t/*\n\t  A mixin which lets us bind a view model into a scope.\n\t  Note that only a single view model can be bound,\n\t  otherwise the scope might behave unexpectedly.\n\t  Mainly used to define the controller as the view model,\n\t  and very useful when wanting to use Angular's `controllerAs` syntax.\n\t */\n\t.factory(ViewModel, [_utils.utils, _mixer.Mixer, function ($$utils, $Mixer) {\n\t  function $$ViewModel() {}\n\n\t  // Gets an object, wraps it with scope functions and returns it\n\t  $$ViewModel.viewModel = function (vm) {\n\t    if (!_underscore2.default.isObject(vm)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\n\t    // Extend view model with mixin functions\n\t    $Mixer._extend(vm, {\n\t      pattern: /^(?!\\$\\$).*$/, // Omitting methods which start with a $$ notation\n\t      context: this // Binding methods to scope\n\t    });\n\n\t    // Apply mixin constructors on scope with view model\n\t    $Mixer._construct(this, vm);\n\t    return vm;\n\t  };\n\n\t  return $$ViewModel;\n\t}])\n\n\t/*\n\t  Illustrates the old API where a view model is created using $reactive service\n\t */\n\t.service(reactive, [_utils.utils, function ($$utils) {\n\t  var Reactive = function () {\n\t    function Reactive(vm) {\n\t      var _this = this;\n\n\t      _classCallCheck(this, Reactive);\n\n\t      if (!_underscore2.default.isObject(vm)) {\n\t        throw Error('argument 1 must be an object');\n\t      }\n\n\t      _underscore2.default.defer(function () {\n\t        if (!_this._attached) {\n\t          console.warn('view model was not attached to any scope');\n\t        }\n\t      });\n\n\t      this._vm = vm;\n\t    }\n\n\t    _createClass(Reactive, [{\n\t      key: 'attach',\n\t      value: function attach(scope) {\n\t        this._attached = true;\n\n\t        if (!$$utils.isScope(scope)) {\n\t          throw Error('argument 1 must be a scope');\n\t        }\n\n\t        var viewModel = scope.viewModel(this._vm);\n\n\t        // Similar to the old/Meteor API\n\t        viewModel.call = viewModel.callMethod;\n\t        viewModel.apply = viewModel.applyMethod;\n\n\t        return viewModel;\n\t      }\n\t    }]);\n\n\t    return Reactive;\n\t  }();\n\n\t  return function (vm) {\n\t    return new Reactive(vm);\n\t  };\n\t}]);\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Reactive = exports.name = undefined;\n\n\tvar _jsondiffpatch = __webpack_require__(22);\n\n\tvar _jsondiffpatch2 = _interopRequireDefault(_jsondiffpatch);\n\n\tvar _underscore = __webpack_require__(2);\n\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\n\tvar _utils = __webpack_require__(16);\n\n\tvar _mixer = __webpack_require__(17);\n\n\tvar _core = __webpack_require__(19);\n\n\tvar _viewModel = __webpack_require__(20);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar name = exports.name = 'angular-meteor.reactive';\n\tvar Reactive = exports.Reactive = '$$Reactive';\n\n\tangular.module(name, [_utils.name, _mixer.name, _core.name, _viewModel.name])\n\n\t/*\n\t  A mixin which enhance our reactive abilities by providing methods\n\t  that are capable of updating our scope reactively.\n\t */\n\t.factory(Reactive, ['$parse', _utils.utils, _mixer.Mixer, function ($parse, $$utils, $Mixer) {\n\t  function $$Reactive() {\n\t    var vm = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];\n\n\t    // Helps us track changes made in the view model\n\t    vm.$$dependencies = {};\n\t  }\n\n\t  // Gets an object containing functions and define their results as reactive properties.\n\t  // Once a return value has been changed the property will be reset.\n\t  $$Reactive.helpers = function (vm, props) {\n\t    var _this = this;\n\n\t    if ($$utils.isViewModel(vm)) {\n\t      if (!_underscore2.default.isObject(props)) {\n\t        throw Error('argument 2 must be an object');\n\t      }\n\t    } else {\n\t      props = vm;\n\t      vm = $Mixer.caller;\n\n\t      if (!_underscore2.default.isObject(props)) {\n\t        throw Error('argument 1 must be an object');\n\t      }\n\t    }\n\n\t    _underscore2.default.each(props, function (v, k) {\n\t      if (!_underscore2.default.isFunction(v)) {\n\t        throw Error('helper \\'' + k + '\\' must be a function');\n\t      }\n\t    });\n\n\t    _underscore2.default.each(props, function (v, k) {\n\t      if (!vm.$$dependencies[k]) {\n\t        // Registers a new dependency to the specified helper\n\t        vm.$$dependencies[k] = new Tracker.Dependency();\n\t      }\n\n\t      _this.$$setFnHelper(vm, k, v);\n\t    });\n\t  };\n\n\t  // Gets a model reactively\n\t  $$Reactive.getReactively = function (vm, k, isDeep) {\n\t    if ($$utils.isViewModel(vm)) {\n\t      if (angular.isUndefined(isDeep)) isDeep = false;\n\n\t      if (!_underscore2.default.isString(k)) {\n\t        throw Error('argument 2 must be a string');\n\t      }\n\t      if (!_underscore2.default.isBoolean(isDeep)) {\n\t        throw Error('argument 3 must be a boolean');\n\t      }\n\t    } else {\n\t      isDeep = angular.isDefined(k) ? k : false;\n\t      k = vm;\n\t      vm = $Mixer.caller;\n\n\t      if (!_underscore2.default.isString(k)) {\n\t        throw Error('argument 1 must be a string');\n\t      }\n\t      if (!_underscore2.default.isBoolean(isDeep)) {\n\t        throw Error('argument 2 must be a boolean');\n\t      }\n\t    }\n\n\t    return this.$$reactivateEntity(vm, k, this.$watch, isDeep);\n\t  };\n\n\t  // Gets a collection reactively\n\t  $$Reactive.getCollectionReactively = function (vm, k) {\n\t    if ($$utils.isViewModel(vm)) {\n\t      if (!_underscore2.default.isString(k)) {\n\t        throw Error('argument 2 must be a string');\n\t      }\n\t    } else {\n\t      k = vm;\n\t      vm = $Mixer.caller;\n\n\t      if (!_underscore2.default.isString(k)) {\n\t        throw Error('argument 1 must be a string');\n\t      }\n\t    }\n\n\t    return this.$$reactivateEntity(vm, k, this.$watchCollection);\n\t  };\n\n\t  // Gets an entity reactively, and once it has been changed the computation will be recomputed\n\t  $$Reactive.$$reactivateEntity = function (vm, k, watcher) {\n\t    if (!vm.$$dependencies[k]) {\n\t      vm.$$dependencies[k] = new Tracker.Dependency();\n\n\t      for (var _len = arguments.length, watcherArgs = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n\t        watcherArgs[_key - 3] = arguments[_key];\n\t      }\n\n\t      this.$$watchEntity.apply(this, [vm, k, watcher].concat(watcherArgs));\n\t    }\n\n\t    vm.$$dependencies[k].depend();\n\t    return $parse(k)(vm);\n\t  };\n\n\t  // Watches for changes in the view model, and if so will notify a change\n\t  $$Reactive.$$watchEntity = function (vm, k, watcher) {\n\t    var _this2 = this;\n\n\t    // Gets a deep property from the caller\n\t    var getVal = _underscore2.default.partial($parse(k), vm);\n\t    var initialVal = getVal();\n\n\t    // Watches for changes in the view model\n\n\t    for (var _len2 = arguments.length, watcherArgs = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t      watcherArgs[_key2 - 3] = arguments[_key2];\n\t    }\n\n\t    watcher.call.apply(watcher, [this, getVal, function (val, oldVal) {\n\t      var hasChanged = val !== initialVal || val !== oldVal;\n\n\t      // Notify if a change has been detected\n\t      if (hasChanged) _this2.$$changed(vm, k);\n\t    }].concat(watcherArgs));\n\t  };\n\n\t  // Invokes a function and sets the return value as a property\n\t  $$Reactive.$$setFnHelper = function (vm, k, fn) {\n\t    var _this3 = this;\n\n\t    var activeObservation = null;\n\t    var lastModel = null;\n\t    var lastModelData = [];\n\n\t    this.autorun(function () /* computation */{\n\t      // Invokes the reactive functon\n\t      var model = fn.apply(vm);\n\n\t      // Ignore notifications made by the following handler\n\t      Tracker.nonreactive(function () {\n\t        // If a cursor, observe its changes and update acoordingly\n\t        if ($$utils.isCursor(model)) {\n\t          var modelData = undefined;\n\n\t          if (angular.isUndefined(vm[k])) {\n\t            _this3.$$setValHelper(vm, k, [], false);\n\t          }\n\n\t          if (activeObservation) {\n\t            lastModelData = lastModel.fetch();\n\t            activeObservation.stop();\n\t            activeObservation = null;\n\t          }\n\n\t          var handle = _this3.$$handleCursor(vm, k, model);\n\n\t          activeObservation = handle.observation;\n\t          modelData = handle.data;\n\n\t          if (lastModelData.length !== 0) {\n\t            var diff = _jsondiffpatch2.default.diff(lastModelData, modelData);\n\t            vm[k] = _jsondiffpatch2.default.patch(lastModelData, diff);\n\t          } else {\n\t            vm[k] = modelData;\n\t          }\n\n\t          lastModel = model;\n\t          lastModelData = modelData;\n\n\t          /* computation.onInvalidate(() => {\n\t            activeObservation.stop();\n\t          });*/\n\t        } else {\n\t            _this3.$$handleNonCursor(vm, k, model);\n\t          }\n\n\t        // Notify change and update the view model\n\t        _this3.$$changed(vm, k);\n\t      });\n\t    });\n\t  };\n\n\t  // Sets a value helper as a setter and a getter which will notify computations once used\n\t  $$Reactive.$$setValHelper = function (vm, k, v) {\n\t    var _this4 = this;\n\n\t    var watch = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\n\t    // If set, reactives property\n\t    if (watch) {\n\t      var isDeep = _underscore2.default.isObject(v);\n\t      this.getReactively(vm, k, isDeep);\n\t    }\n\n\t    Object.defineProperty(vm, k, {\n\t      configurable: true,\n\t      enumerable: true,\n\n\t      get: function get() {\n\t        return v;\n\t      },\n\t      set: function set(newVal) {\n\t        v = newVal;\n\t        _this4.$$changed(vm, k);\n\t      }\n\t    });\n\t  };\n\n\t  // Fetching a cursor and updates properties once the result set has been changed\n\t  $$Reactive.$$handleCursor = function (vm, k, cursor) {\n\t    var _this5 = this;\n\n\t    var data = [];\n\t    // Observe changes made in the result set\n\t    var observation = cursor.observe({\n\t      addedAt: function addedAt(doc, atIndex) {\n\t        if (!observation) {\n\t          data.push(doc);\n\t          return;\n\t        }\n\t        vm[k].splice(atIndex, 0, doc);\n\t        _this5.$$changed(vm, k);\n\t      },\n\t      changedAt: function changedAt(doc, oldDoc, atIndex) {\n\t        var diff = _jsondiffpatch2.default.diff(vm[k][atIndex], doc);\n\t        _jsondiffpatch2.default.patch(vm[k][atIndex], diff);\n\t        _this5.$$changed(vm, k);\n\t      },\n\t      movedTo: function movedTo(doc, fromIndex, toIndex) {\n\t        vm[k].splice(fromIndex, 1);\n\t        vm[k].splice(toIndex, 0, doc);\n\t        _this5.$$changed(vm, k);\n\t      },\n\t      removedAt: function removedAt(oldDoc, atIndex) {\n\t        vm[k].splice(atIndex, 1);\n\t        _this5.$$changed(vm, k);\n\t      }\n\t    });\n\n\t    return {\n\t      observation: observation,\n\t      data: data\n\t    };\n\t  };\n\n\t  $$Reactive.$$handleNonCursor = function (vm, k, data) {\n\t    var v = vm[k];\n\n\t    if (angular.isDefined(v)) {\n\t      delete vm[k];\n\t      v = null;\n\t    }\n\n\t    if (angular.isUndefined(v)) {\n\t      this.$$setValHelper(vm, k, data);\n\t    }\n\t    // Update property if the new value is from the same type\n\t    else if ($$utils.areSiblings(v, data)) {\n\t        var diff = _jsondiffpatch2.default.diff(v, data);\n\t        _jsondiffpatch2.default.patch(v, diff);\n\t        this.$$changed(vm, k);\n\t      } else {\n\t        vm[k] = data;\n\t      }\n\t  };\n\n\t  // Notifies dependency in view model\n\t  $$Reactive.$$depend = function (vm, k) {\n\t    vm.$$dependencies[k].depend();\n\t  };\n\n\t  // Notifies change in view model\n\t  $$Reactive.$$changed = function (vm, k) {\n\t    this.$$throttledDigest();\n\t    vm.$$dependencies[k].changed();\n\t  };\n\n\t  return $$Reactive;\n\t}]);\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar name = exports.name = 'angular-templates';\n\n\ttry {\n\t  angular.module(name);\n\t} catch (e) {\n\t  angular.module(name, []);\n\t}\n\n/***/ }\n/******/ ])\n});\n;"]}