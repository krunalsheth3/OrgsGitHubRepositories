[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/angular_angular-animate/angular-animate.js                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/**                                                                                                                    // 1\n * @license AngularJS v1.4.8                                                                                           // 2\n * (c) 2010-2015 Google, Inc. http://angularjs.org                                                                     // 3\n * License: MIT                                                                                                        // 4\n */                                                                                                                    // 5\n(function(window, angular, undefined) {'use strict';                                                                   // 6\n                                                                                                                       // 7\n/* jshint ignore:start */                                                                                              // 8\nvar noop        = angular.noop;                                                                                        // 9\nvar extend      = angular.extend;                                                                                      // 10\nvar jqLite      = angular.element;                                                                                     // 11\nvar forEach     = angular.forEach;                                                                                     // 12\nvar isArray     = angular.isArray;                                                                                     // 13\nvar isString    = angular.isString;                                                                                    // 14\nvar isObject    = angular.isObject;                                                                                    // 15\nvar isUndefined = angular.isUndefined;                                                                                 // 16\nvar isDefined   = angular.isDefined;                                                                                   // 17\nvar isFunction  = angular.isFunction;                                                                                  // 18\nvar isElement   = angular.isElement;                                                                                   // 19\n                                                                                                                       // 20\nvar ELEMENT_NODE = 1;                                                                                                  // 21\nvar COMMENT_NODE = 8;                                                                                                  // 22\n                                                                                                                       // 23\nvar ADD_CLASS_SUFFIX = '-add';                                                                                         // 24\nvar REMOVE_CLASS_SUFFIX = '-remove';                                                                                   // 25\nvar EVENT_CLASS_PREFIX = 'ng-';                                                                                        // 26\nvar ACTIVE_CLASS_SUFFIX = '-active';                                                                                   // 27\n                                                                                                                       // 28\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';                                                                               // 29\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';                                                                  // 30\n                                                                                                                       // 31\n// Detect proper transitionend/animationend event names.                                                               // 32\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;                         // 33\n                                                                                                                       // 34\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.                                     // 35\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.                           // 36\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`                 // 37\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.                              // 38\n// Register both events in case `window.onanimationend` is not supported because of that,                              // 39\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.                                    // 40\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit                         // 41\n// therefore there is no reason to test anymore for other vendor prefixes:                                             // 42\n// http://caniuse.com/#search=transition                                                                               // 43\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {                                  // 44\n  CSS_PREFIX = '-webkit-';                                                                                             // 45\n  TRANSITION_PROP = 'WebkitTransition';                                                                                // 46\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';                                                           // 47\n} else {                                                                                                               // 48\n  TRANSITION_PROP = 'transition';                                                                                      // 49\n  TRANSITIONEND_EVENT = 'transitionend';                                                                               // 50\n}                                                                                                                      // 51\n                                                                                                                       // 52\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {                                    // 53\n  CSS_PREFIX = '-webkit-';                                                                                             // 54\n  ANIMATION_PROP = 'WebkitAnimation';                                                                                  // 55\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';                                                              // 56\n} else {                                                                                                               // 57\n  ANIMATION_PROP = 'animation';                                                                                        // 58\n  ANIMATIONEND_EVENT = 'animationend';                                                                                 // 59\n}                                                                                                                      // 60\n                                                                                                                       // 61\nvar DURATION_KEY = 'Duration';                                                                                         // 62\nvar PROPERTY_KEY = 'Property';                                                                                         // 63\nvar DELAY_KEY = 'Delay';                                                                                               // 64\nvar TIMING_KEY = 'TimingFunction';                                                                                     // 65\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';                                                                  // 66\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';                                                                             // 67\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;                                                                           // 68\n                                                                                                                       // 69\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;                                                                 // 70\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;                                                           // 71\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;                                                               // 72\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;                                                         // 73\n                                                                                                                       // 74\nvar isPromiseLike = function(p) {                                                                                      // 75\n  return p && p.then ? true : false;                                                                                   // 76\n};                                                                                                                     // 77\n                                                                                                                       // 78\nfunction assertArg(arg, name, reason) {                                                                                // 79\n  if (!arg) {                                                                                                          // 80\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));                            // 81\n  }                                                                                                                    // 82\n  return arg;                                                                                                          // 83\n}                                                                                                                      // 84\n                                                                                                                       // 85\nfunction mergeClasses(a,b) {                                                                                           // 86\n  if (!a && !b) return '';                                                                                             // 87\n  if (!a) return b;                                                                                                    // 88\n  if (!b) return a;                                                                                                    // 89\n  if (isArray(a)) a = a.join(' ');                                                                                     // 90\n  if (isArray(b)) b = b.join(' ');                                                                                     // 91\n  return a + ' ' + b;                                                                                                  // 92\n}                                                                                                                      // 93\n                                                                                                                       // 94\nfunction packageStyles(options) {                                                                                      // 95\n  var styles = {};                                                                                                     // 96\n  if (options && (options.to || options.from)) {                                                                       // 97\n    styles.to = options.to;                                                                                            // 98\n    styles.from = options.from;                                                                                        // 99\n  }                                                                                                                    // 100\n  return styles;                                                                                                       // 101\n}                                                                                                                      // 102\n                                                                                                                       // 103\nfunction pendClasses(classes, fix, isPrefix) {                                                                         // 104\n  var className = '';                                                                                                  // 105\n  classes = isArray(classes)                                                                                           // 106\n      ? classes                                                                                                        // 107\n      : classes && isString(classes) && classes.length                                                                 // 108\n          ? classes.split(/\\s+/)                                                                                       // 109\n          : [];                                                                                                        // 110\n  forEach(classes, function(klass, i) {                                                                                // 111\n    if (klass && klass.length > 0) {                                                                                   // 112\n      className += (i > 0) ? ' ' : '';                                                                                 // 113\n      className += isPrefix ? fix + klass                                                                              // 114\n                            : klass + fix;                                                                             // 115\n    }                                                                                                                  // 116\n  });                                                                                                                  // 117\n  return className;                                                                                                    // 118\n}                                                                                                                      // 119\n                                                                                                                       // 120\nfunction removeFromArray(arr, val) {                                                                                   // 121\n  var index = arr.indexOf(val);                                                                                        // 122\n  if (val >= 0) {                                                                                                      // 123\n    arr.splice(index, 1);                                                                                              // 124\n  }                                                                                                                    // 125\n}                                                                                                                      // 126\n                                                                                                                       // 127\nfunction stripCommentsFromElement(element) {                                                                           // 128\n  if (element instanceof jqLite) {                                                                                     // 129\n    switch (element.length) {                                                                                          // 130\n      case 0:                                                                                                          // 131\n        return [];                                                                                                     // 132\n        break;                                                                                                         // 133\n                                                                                                                       // 134\n      case 1:                                                                                                          // 135\n        // there is no point of stripping anything if the element                                                      // 136\n        // is the only element within the jqLite wrapper.                                                              // 137\n        // (it's important that we retain the element instance.)                                                       // 138\n        if (element[0].nodeType === ELEMENT_NODE) {                                                                    // 139\n          return element;                                                                                              // 140\n        }                                                                                                              // 141\n        break;                                                                                                         // 142\n                                                                                                                       // 143\n      default:                                                                                                         // 144\n        return jqLite(extractElementNode(element));                                                                    // 145\n        break;                                                                                                         // 146\n    }                                                                                                                  // 147\n  }                                                                                                                    // 148\n                                                                                                                       // 149\n  if (element.nodeType === ELEMENT_NODE) {                                                                             // 150\n    return jqLite(element);                                                                                            // 151\n  }                                                                                                                    // 152\n}                                                                                                                      // 153\n                                                                                                                       // 154\nfunction extractElementNode(element) {                                                                                 // 155\n  if (!element[0]) return element;                                                                                     // 156\n  for (var i = 0; i < element.length; i++) {                                                                           // 157\n    var elm = element[i];                                                                                              // 158\n    if (elm.nodeType == ELEMENT_NODE) {                                                                                // 159\n      return elm;                                                                                                      // 160\n    }                                                                                                                  // 161\n  }                                                                                                                    // 162\n}                                                                                                                      // 163\n                                                                                                                       // 164\nfunction $$addClass($$jqLite, element, className) {                                                                    // 165\n  forEach(element, function(elm) {                                                                                     // 166\n    $$jqLite.addClass(elm, className);                                                                                 // 167\n  });                                                                                                                  // 168\n}                                                                                                                      // 169\n                                                                                                                       // 170\nfunction $$removeClass($$jqLite, element, className) {                                                                 // 171\n  forEach(element, function(elm) {                                                                                     // 172\n    $$jqLite.removeClass(elm, className);                                                                              // 173\n  });                                                                                                                  // 174\n}                                                                                                                      // 175\n                                                                                                                       // 176\nfunction applyAnimationClassesFactory($$jqLite) {                                                                      // 177\n  return function(element, options) {                                                                                  // 178\n    if (options.addClass) {                                                                                            // 179\n      $$addClass($$jqLite, element, options.addClass);                                                                 // 180\n      options.addClass = null;                                                                                         // 181\n    }                                                                                                                  // 182\n    if (options.removeClass) {                                                                                         // 183\n      $$removeClass($$jqLite, element, options.removeClass);                                                           // 184\n      options.removeClass = null;                                                                                      // 185\n    }                                                                                                                  // 186\n  }                                                                                                                    // 187\n}                                                                                                                      // 188\n                                                                                                                       // 189\nfunction prepareAnimationOptions(options) {                                                                            // 190\n  options = options || {};                                                                                             // 191\n  if (!options.$$prepared) {                                                                                           // 192\n    var domOperation = options.domOperation || noop;                                                                   // 193\n    options.domOperation = function() {                                                                                // 194\n      options.$$domOperationFired = true;                                                                              // 195\n      domOperation();                                                                                                  // 196\n      domOperation = noop;                                                                                             // 197\n    };                                                                                                                 // 198\n    options.$$prepared = true;                                                                                         // 199\n  }                                                                                                                    // 200\n  return options;                                                                                                      // 201\n}                                                                                                                      // 202\n                                                                                                                       // 203\nfunction applyAnimationStyles(element, options) {                                                                      // 204\n  applyAnimationFromStyles(element, options);                                                                          // 205\n  applyAnimationToStyles(element, options);                                                                            // 206\n}                                                                                                                      // 207\n                                                                                                                       // 208\nfunction applyAnimationFromStyles(element, options) {                                                                  // 209\n  if (options.from) {                                                                                                  // 210\n    element.css(options.from);                                                                                         // 211\n    options.from = null;                                                                                               // 212\n  }                                                                                                                    // 213\n}                                                                                                                      // 214\n                                                                                                                       // 215\nfunction applyAnimationToStyles(element, options) {                                                                    // 216\n  if (options.to) {                                                                                                    // 217\n    element.css(options.to);                                                                                           // 218\n    options.to = null;                                                                                                 // 219\n  }                                                                                                                    // 220\n}                                                                                                                      // 221\n                                                                                                                       // 222\nfunction mergeAnimationOptions(element, target, newOptions) {                                                          // 223\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');                                             // 224\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');                                    // 225\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);                                         // 226\n                                                                                                                       // 227\n  if (newOptions.preparationClasses) {                                                                                 // 228\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);             // 229\n    delete newOptions.preparationClasses;                                                                              // 230\n  }                                                                                                                    // 231\n                                                                                                                       // 232\n  // noop is basically when there is no callback; otherwise something has been set                                     // 233\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;                                    // 234\n                                                                                                                       // 235\n  extend(target, newOptions);                                                                                          // 236\n                                                                                                                       // 237\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {                                                                                              // 239\n    target.domOperation = realDomOperation;                                                                            // 240\n  }                                                                                                                    // 241\n                                                                                                                       // 242\n  if (classes.addClass) {                                                                                              // 243\n    target.addClass = classes.addClass;                                                                                // 244\n  } else {                                                                                                             // 245\n    target.addClass = null;                                                                                            // 246\n  }                                                                                                                    // 247\n                                                                                                                       // 248\n  if (classes.removeClass) {                                                                                           // 249\n    target.removeClass = classes.removeClass;                                                                          // 250\n  } else {                                                                                                             // 251\n    target.removeClass = null;                                                                                         // 252\n  }                                                                                                                    // 253\n                                                                                                                       // 254\n  return target;                                                                                                       // 255\n}                                                                                                                      // 256\n                                                                                                                       // 257\nfunction resolveElementClasses(existing, toAdd, toRemove) {                                                            // 258\n  var ADD_CLASS = 1;                                                                                                   // 259\n  var REMOVE_CLASS = -1;                                                                                               // 260\n                                                                                                                       // 261\n  var flags = {};                                                                                                      // 262\n  existing = splitClassesToLookup(existing);                                                                           // 263\n                                                                                                                       // 264\n  toAdd = splitClassesToLookup(toAdd);                                                                                 // 265\n  forEach(toAdd, function(value, key) {                                                                                // 266\n    flags[key] = ADD_CLASS;                                                                                            // 267\n  });                                                                                                                  // 268\n                                                                                                                       // 269\n  toRemove = splitClassesToLookup(toRemove);                                                                           // 270\n  forEach(toRemove, function(value, key) {                                                                             // 271\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;                                                       // 272\n  });                                                                                                                  // 273\n                                                                                                                       // 274\n  var classes = {                                                                                                      // 275\n    addClass: '',                                                                                                      // 276\n    removeClass: ''                                                                                                    // 277\n  };                                                                                                                   // 278\n                                                                                                                       // 279\n  forEach(flags, function(val, klass) {                                                                                // 280\n    var prop, allow;                                                                                                   // 281\n    if (val === ADD_CLASS) {                                                                                           // 282\n      prop = 'addClass';                                                                                               // 283\n      allow = !existing[klass];                                                                                        // 284\n    } else if (val === REMOVE_CLASS) {                                                                                 // 285\n      prop = 'removeClass';                                                                                            // 286\n      allow = existing[klass];                                                                                         // 287\n    }                                                                                                                  // 288\n    if (allow) {                                                                                                       // 289\n      if (classes[prop].length) {                                                                                      // 290\n        classes[prop] += ' ';                                                                                          // 291\n      }                                                                                                                // 292\n      classes[prop] += klass;                                                                                          // 293\n    }                                                                                                                  // 294\n  });                                                                                                                  // 295\n                                                                                                                       // 296\n  function splitClassesToLookup(classes) {                                                                             // 297\n    if (isString(classes)) {                                                                                           // 298\n      classes = classes.split(' ');                                                                                    // 299\n    }                                                                                                                  // 300\n                                                                                                                       // 301\n    var obj = {};                                                                                                      // 302\n    forEach(classes, function(klass) {                                                                                 // 303\n      // sometimes the split leaves empty string values                                                                // 304\n      // incase extra spaces were applied to the options                                                               // 305\n      if (klass.length) {                                                                                              // 306\n        obj[klass] = true;                                                                                             // 307\n      }                                                                                                                // 308\n    });                                                                                                                // 309\n    return obj;                                                                                                        // 310\n  }                                                                                                                    // 311\n                                                                                                                       // 312\n  return classes;                                                                                                      // 313\n}                                                                                                                      // 314\n                                                                                                                       // 315\nfunction getDomNode(element) {                                                                                         // 316\n  return (element instanceof angular.element) ? element[0] : element;                                                  // 317\n}                                                                                                                      // 318\n                                                                                                                       // 319\nfunction applyGeneratedPreparationClasses(element, event, options) {                                                   // 320\n  var classes = '';                                                                                                    // 321\n  if (event) {                                                                                                         // 322\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);                                                            // 323\n  }                                                                                                                    // 324\n  if (options.addClass) {                                                                                              // 325\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));                               // 326\n  }                                                                                                                    // 327\n  if (options.removeClass) {                                                                                           // 328\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));                         // 329\n  }                                                                                                                    // 330\n  if (classes.length) {                                                                                                // 331\n    options.preparationClasses = classes;                                                                              // 332\n    element.addClass(classes);                                                                                         // 333\n  }                                                                                                                    // 334\n}                                                                                                                      // 335\n                                                                                                                       // 336\nfunction clearGeneratedClasses(element, options) {                                                                     // 337\n  if (options.preparationClasses) {                                                                                    // 338\n    element.removeClass(options.preparationClasses);                                                                   // 339\n    options.preparationClasses = null;                                                                                 // 340\n  }                                                                                                                    // 341\n  if (options.activeClasses) {                                                                                         // 342\n    element.removeClass(options.activeClasses);                                                                        // 343\n    options.activeClasses = null;                                                                                      // 344\n  }                                                                                                                    // 345\n}                                                                                                                      // 346\n                                                                                                                       // 347\nfunction blockTransitions(node, duration) {                                                                            // 348\n  // we use a negative delay value since it performs blocking                                                          // 349\n  // yet it doesn't kill any existing transitions running on the                                                       // 350\n  // same element which makes this safe for class-based animations                                                     // 351\n  var value = duration ? '-' + duration + 's' : '';                                                                    // 352\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);                                                              // 353\n  return [TRANSITION_DELAY_PROP, value];                                                                               // 354\n}                                                                                                                      // 355\n                                                                                                                       // 356\nfunction blockKeyframeAnimations(node, applyBlock) {                                                                   // 357\n  var value = applyBlock ? 'paused' : '';                                                                              // 358\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;                                                                  // 359\n  applyInlineStyle(node, [key, value]);                                                                                // 360\n  return [key, value];                                                                                                 // 361\n}                                                                                                                      // 362\n                                                                                                                       // 363\nfunction applyInlineStyle(node, styleTuple) {                                                                          // 364\n  var prop = styleTuple[0];                                                                                            // 365\n  var value = styleTuple[1];                                                                                           // 366\n  node.style[prop] = value;                                                                                            // 367\n}                                                                                                                      // 368\n                                                                                                                       // 369\nfunction concatWithSpace(a,b) {                                                                                        // 370\n  if (!a) return b;                                                                                                    // 371\n  if (!b) return a;                                                                                                    // 372\n  return a + ' ' + b;                                                                                                  // 373\n}                                                                                                                      // 374\n                                                                                                                       // 375\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {                                                                // 376\n  var queue, cancelFn;                                                                                                 // 377\n                                                                                                                       // 378\n  function scheduler(tasks) {                                                                                          // 379\n    // we make a copy since RAFScheduler mutates the state                                                             // 380\n    // of the passed in array variable and this would be difficult                                                     // 381\n    // to track down on the outside code                                                                               // 382\n    queue = queue.concat(tasks);                                                                                       // 383\n    nextTick();                                                                                                        // 384\n  }                                                                                                                    // 385\n                                                                                                                       // 386\n  queue = scheduler.queue = [];                                                                                        // 387\n                                                                                                                       // 388\n  /* waitUntilQuiet does two things:                                                                                   // 389\n   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through                               // 390\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.                                // 391\n   *                                                                                                                   // 392\n   * The motivation here is that animation code can request more time from the scheduler                               // 393\n   * before the next wave runs. This allows for certain DOM properties such as classes to                              // 394\n   * be resolved in time for the next animation to run.                                                                // 395\n   */                                                                                                                  // 396\n  scheduler.waitUntilQuiet = function(fn) {                                                                            // 397\n    if (cancelFn) cancelFn();                                                                                          // 398\n                                                                                                                       // 399\n    cancelFn = $$rAF(function() {                                                                                      // 400\n      cancelFn = null;                                                                                                 // 401\n      fn();                                                                                                            // 402\n      nextTick();                                                                                                      // 403\n    });                                                                                                                // 404\n  };                                                                                                                   // 405\n                                                                                                                       // 406\n  return scheduler;                                                                                                    // 407\n                                                                                                                       // 408\n  function nextTick() {                                                                                                // 409\n    if (!queue.length) return;                                                                                         // 410\n                                                                                                                       // 411\n    var items = queue.shift();                                                                                         // 412\n    for (var i = 0; i < items.length; i++) {                                                                           // 413\n      items[i]();                                                                                                      // 414\n    }                                                                                                                  // 415\n                                                                                                                       // 416\n    if (!cancelFn) {                                                                                                   // 417\n      $$rAF(function() {                                                                                               // 418\n        if (!cancelFn) nextTick();                                                                                     // 419\n      });                                                                                                              // 420\n    }                                                                                                                  // 421\n  }                                                                                                                    // 422\n}];                                                                                                                    // 423\n                                                                                                                       // 424\nvar $$AnimateChildrenDirective = [function() {                                                                         // 425\n  return function(scope, element, attrs) {                                                                             // 426\n    var val = attrs.ngAnimateChildren;                                                                                 // 427\n    if (angular.isString(val) && val.length === 0) { //empty attribute                                                 // 428\n      element.data(NG_ANIMATE_CHILDREN_DATA, true);                                                                    // 429\n    } else {                                                                                                           // 430\n      attrs.$observe('ngAnimateChildren', function(value) {                                                            // 431\n        value = value === 'on' || value === 'true';                                                                    // 432\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);                                                                 // 433\n      });                                                                                                              // 434\n    }                                                                                                                  // 435\n  };                                                                                                                   // 436\n}];                                                                                                                    // 437\n                                                                                                                       // 438\nvar ANIMATE_TIMER_KEY = '$$animateCss';                                                                                // 439\n                                                                                                                       // 440\n/**                                                                                                                    // 441\n * @ngdoc service                                                                                                      // 442\n * @name $animateCss                                                                                                   // 443\n * @kind object                                                                                                        // 444\n *                                                                                                                     // 445\n * @description                                                                                                        // 446\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes                 // 447\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT                 // 448\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or                 // 449\n * directives to create more complex animations that can be purely driven using CSS code.                              // 450\n *                                                                                                                     // 451\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of                      // 452\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).                                      // 453\n *                                                                                                                     // 454\n * ## Usage                                                                                                            // 455\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that                   // 456\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,               // 457\n * any automatic control over cancelling animations and/or preventing animations from being run on                     // 458\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to               // 459\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger                   // 460\n * the CSS animation.                                                                                                  // 461\n *                                                                                                                     // 462\n * The example below shows how we can create a folding animation on an element using `ng-if`:                          // 463\n *                                                                                                                     // 464\n * ```html                                                                                                             // 465\n * <!-- notice the `fold-animation` CSS class -->                                                                      // 466\n * <div ng-if=\"onOff\" class=\"fold-animation\">                                                                          // 467\n *   This element will go BOOM                                                                                         // 468\n * </div>                                                                                                              // 469\n * <button ng-click=\"onOff=true\">Fold In</button>                                                                      // 470\n * ```                                                                                                                 // 471\n *                                                                                                                     // 472\n * Now we create the **JavaScript animation** that will trigger the CSS transition:                                    // 473\n *                                                                                                                     // 474\n * ```js                                                                                                               // 475\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {                                       // 476\n *   return {                                                                                                          // 477\n *     enter: function(element, doneFn) {                                                                              // 478\n *       var height = element[0].offsetHeight;                                                                         // 479\n *       return $animateCss(element, {                                                                                 // 480\n *         from: { height:'0px' },                                                                                     // 481\n *         to: { height:height + 'px' },                                                                               // 482\n *         duration: 1 // one second                                                                                   // 483\n *       });                                                                                                           // 484\n *     }                                                                                                               // 485\n *   }                                                                                                                 // 486\n * }]);                                                                                                                // 487\n * ```                                                                                                                 // 488\n *                                                                                                                     // 489\n * ## More Advanced Uses                                                                                               // 490\n *                                                                                                                     // 491\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *                                                                                                                     // 494\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.                                                                // 498\n *                                                                                                                     // 499\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:                // 500\n *                                                                                                                     // 501\n * ```js                                                                                                               // 502\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {                                       // 503\n *   return {                                                                                                          // 504\n *     enter: function(element, doneFn) {                                                                              // 505\n *       var height = element[0].offsetHeight;                                                                         // 506\n *       return $animateCss(element, {                                                                                 // 507\n *         addClass: 'red large-text pulse-twice',                                                                     // 508\n *         easing: 'ease-out',                                                                                         // 509\n *         from: { height:'0px' },                                                                                     // 510\n *         to: { height:height + 'px' },                                                                               // 511\n *         duration: 1 // one second                                                                                   // 512\n *       });                                                                                                           // 513\n *     }                                                                                                               // 514\n *   }                                                                                                                 // 515\n * }]);                                                                                                                // 516\n * ```                                                                                                                 // 517\n *                                                                                                                     // 518\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:                            // 519\n *                                                                                                                     // 520\n * ```css                                                                                                              // 521\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,                         // 522\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/                 // 523\n * .red { background:red; }                                                                                            // 524\n * .large-text { font-size:20px; }                                                                                     // 525\n *                                                                                                                     // 526\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/       // 527\n * .pulse-twice {                                                                                                      // 528\n *   animation: 0.5s pulse linear 2;                                                                                   // 529\n *   -webkit-animation: 0.5s pulse linear 2;                                                                           // 530\n * }                                                                                                                   // 531\n *                                                                                                                     // 532\n * @keyframes pulse {                                                                                                  // 533\n *   from { transform: scale(0.5); }                                                                                   // 534\n *   to { transform: scale(1.5); }                                                                                     // 535\n * }                                                                                                                   // 536\n *                                                                                                                     // 537\n * @-webkit-keyframes pulse {                                                                                          // 538\n *   from { -webkit-transform: scale(0.5); }                                                                           // 539\n *   to { -webkit-transform: scale(1.5); }                                                                             // 540\n * }                                                                                                                   // 541\n * ```                                                                                                                 // 542\n *                                                                                                                     // 543\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *                                                                                                                     // 545\n * ## How the Options are handled                                                                                      // 546\n *                                                                                                                     // 547\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.                                                                        // 550\n *                                                                                                                     // 551\n * ```js                                                                                                               // 552\n * var animator = $animateCss(element, {                                                                               // 553\n *   from: { background:'red' },                                                                                       // 554\n *   to: { background:'blue' }                                                                                         // 555\n * });                                                                                                                 // 556\n * animator.start();                                                                                                   // 557\n * ```                                                                                                                 // 558\n *                                                                                                                     // 559\n * ```css                                                                                                              // 560\n * .rotating-animation {                                                                                               // 561\n *   animation:0.5s rotate linear;                                                                                     // 562\n *   -webkit-animation:0.5s rotate linear;                                                                             // 563\n * }                                                                                                                   // 564\n *                                                                                                                     // 565\n * @keyframes rotate {                                                                                                 // 566\n *   from { transform: rotate(0deg); }                                                                                 // 567\n *   to { transform: rotate(360deg); }                                                                                 // 568\n * }                                                                                                                   // 569\n *                                                                                                                     // 570\n * @-webkit-keyframes rotate {                                                                                         // 571\n *   from { -webkit-transform: rotate(0deg); }                                                                         // 572\n *   to { -webkit-transform: rotate(360deg); }                                                                         // 573\n * }                                                                                                                   // 574\n * ```                                                                                                                 // 575\n *                                                                                                                     // 576\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.                                                            // 581\n *                                                                                                                     // 582\n * ## What is returned                                                                                                 // 583\n *                                                                                                                     // 584\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *                                                                                                                     // 588\n * ```js                                                                                                               // 589\n * var animator = $animateCss(element, { ... });                                                                       // 590\n * ```                                                                                                                 // 591\n *                                                                                                                     // 592\n * Now what do the contents of our `animator` variable look like:                                                      // 593\n *                                                                                                                     // 594\n * ```js                                                                                                               // 595\n * {                                                                                                                   // 596\n *   // starts the animation                                                                                           // 597\n *   start: Function,                                                                                                  // 598\n *                                                                                                                     // 599\n *   // ends (aborts) the animation                                                                                    // 600\n *   end: Function                                                                                                     // 601\n * }                                                                                                                   // 602\n * ```                                                                                                                 // 603\n *                                                                                                                     // 604\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.                                        // 608\n *                                                                                                                     // 609\n * ### runner.done() vs runner.then()                                                                                  // 610\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.                                                             // 614\n *                                                                                                                     // 615\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).                       // 617\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.                           // 618\n *                                                                                                                     // 619\n * @param {DOMElement} element the element that will be animated                                                       // 620\n * @param {object} options the animation-related options that will be applied during the animation                     // 621\n *                                                                                                                     // 622\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.                                      // 626\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).           // 627\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).                        // 628\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).         // 629\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.         // 630\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.                                                            // 635\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.                                                                                                    // 639\n * * `stagger` - A numeric time value representing the delay between successively animated elements                    // 640\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})      // 641\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)                            // 643\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once                         // 645\n *    the animation is closed. This is useful for when the styles are used purely for the sake of                      // 646\n *    the animation and do not have a lasting visual effect on the element (e.g. a colapse and open animation).        // 647\n *    By default this value is set to `false`.                                                                         // 648\n *                                                                                                                     // 649\n * @return {object} an object with start and end methods and details about the animation.                              // 650\n *                                                                                                                     // 651\n * * `start` - The method to start the animation. This will return a `Promise` when called.                            // 652\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.                      // 653\n */                                                                                                                    // 654\nvar ONE_SECOND = 1000;                                                                                                 // 655\nvar BASE_TEN = 10;                                                                                                     // 656\n                                                                                                                       // 657\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;                                                                               // 658\nvar CLOSING_TIME_BUFFER = 1.5;                                                                                         // 659\n                                                                                                                       // 660\nvar DETECT_CSS_PROPERTIES = {                                                                                          // 661\n  transitionDuration:      TRANSITION_DURATION_PROP,                                                                   // 662\n  transitionDelay:         TRANSITION_DELAY_PROP,                                                                      // 663\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,                                                             // 664\n  animationDuration:       ANIMATION_DURATION_PROP,                                                                    // 665\n  animationDelay:          ANIMATION_DELAY_PROP,                                                                       // 666\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY                                              // 667\n};                                                                                                                     // 668\n                                                                                                                       // 669\nvar DETECT_STAGGER_CSS_PROPERTIES = {                                                                                  // 670\n  transitionDuration:      TRANSITION_DURATION_PROP,                                                                   // 671\n  transitionDelay:         TRANSITION_DELAY_PROP,                                                                      // 672\n  animationDuration:       ANIMATION_DURATION_PROP,                                                                    // 673\n  animationDelay:          ANIMATION_DELAY_PROP                                                                        // 674\n};                                                                                                                     // 675\n                                                                                                                       // 676\nfunction getCssKeyframeDurationStyle(duration) {                                                                       // 677\n  return [ANIMATION_DURATION_PROP, duration + 's'];                                                                    // 678\n}                                                                                                                      // 679\n                                                                                                                       // 680\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {                                                                // 681\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;                                       // 682\n  return [prop, delay + 's'];                                                                                          // 683\n}                                                                                                                      // 684\n                                                                                                                       // 685\nfunction computeCssStyles($window, element, properties) {                                                              // 686\n  var styles = Object.create(null);                                                                                    // 687\n  var detectedStyles = $window.getComputedStyle(element) || {};                                                        // 688\n  forEach(properties, function(formalStyleName, actualStyleName) {                                                     // 689\n    var val = detectedStyles[formalStyleName];                                                                         // 690\n    if (val) {                                                                                                         // 691\n      var c = val.charAt(0);                                                                                           // 692\n                                                                                                                       // 693\n      // only numerical-based values have a negative sign or digit as the first value                                  // 694\n      if (c === '-' || c === '+' || c >= 0) {                                                                          // 695\n        val = parseMaxTime(val);                                                                                       // 696\n      }                                                                                                                // 697\n                                                                                                                       // 698\n      // by setting this to null in the event that the delay is not set or is set directly as 0                        // 699\n      // then we can still allow for zegative values to be used later on and not mistake this                          // 700\n      // value for being greater than any other negative value.                                                        // 701\n      if (val === 0) {                                                                                                 // 702\n        val = null;                                                                                                    // 703\n      }                                                                                                                // 704\n      styles[actualStyleName] = val;                                                                                   // 705\n    }                                                                                                                  // 706\n  });                                                                                                                  // 707\n                                                                                                                       // 708\n  return styles;                                                                                                       // 709\n}                                                                                                                      // 710\n                                                                                                                       // 711\nfunction parseMaxTime(str) {                                                                                           // 712\n  var maxValue = 0;                                                                                                    // 713\n  var values = str.split(/\\s*,\\s*/);                                                                                   // 714\n  forEach(values, function(value) {                                                                                    // 715\n    // it's always safe to consider only second values and omit `ms` values since                                      // 716\n    // getComputedStyle will always handle the conversion for us                                                       // 717\n    if (value.charAt(value.length - 1) == 's') {                                                                       // 718\n      value = value.substring(0, value.length - 1);                                                                    // 719\n    }                                                                                                                  // 720\n    value = parseFloat(value) || 0;                                                                                    // 721\n    maxValue = maxValue ? Math.max(value, maxValue) : value;                                                           // 722\n  });                                                                                                                  // 723\n  return maxValue;                                                                                                     // 724\n}                                                                                                                      // 725\n                                                                                                                       // 726\nfunction truthyTimingValue(val) {                                                                                      // 727\n  return val === 0 || val != null;                                                                                     // 728\n}                                                                                                                      // 729\n                                                                                                                       // 730\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {                                                  // 731\n  var style = TRANSITION_PROP;                                                                                         // 732\n  var value = duration + 's';                                                                                          // 733\n  if (applyOnlyDuration) {                                                                                             // 734\n    style += DURATION_KEY;                                                                                             // 735\n  } else {                                                                                                             // 736\n    value += ' linear all';                                                                                            // 737\n  }                                                                                                                    // 738\n  return [style, value];                                                                                               // 739\n}                                                                                                                      // 740\n                                                                                                                       // 741\nfunction createLocalCacheLookup() {                                                                                    // 742\n  var cache = Object.create(null);                                                                                     // 743\n  return {                                                                                                             // 744\n    flush: function() {                                                                                                // 745\n      cache = Object.create(null);                                                                                     // 746\n    },                                                                                                                 // 747\n                                                                                                                       // 748\n    count: function(key) {                                                                                             // 749\n      var entry = cache[key];                                                                                          // 750\n      return entry ? entry.total : 0;                                                                                  // 751\n    },                                                                                                                 // 752\n                                                                                                                       // 753\n    get: function(key) {                                                                                               // 754\n      var entry = cache[key];                                                                                          // 755\n      return entry && entry.value;                                                                                     // 756\n    },                                                                                                                 // 757\n                                                                                                                       // 758\n    put: function(key, value) {                                                                                        // 759\n      if (!cache[key]) {                                                                                               // 760\n        cache[key] = { total: 1, value: value };                                                                       // 761\n      } else {                                                                                                         // 762\n        cache[key].total++;                                                                                            // 763\n      }                                                                                                                // 764\n    }                                                                                                                  // 765\n  };                                                                                                                   // 766\n}                                                                                                                      // 767\n                                                                                                                       // 768\n// we do not reassign an already present style value since                                                             // 769\n// if we detect the style property value again we may be                                                               // 770\n// detecting styles that were added via the `from` styles.                                                             // 771\n// We make use of `isDefined` here since an empty string                                                               // 772\n// or null value (which is what getPropertyValue will return                                                           // 773\n// for a non-existing style) will still be marked as a valid                                                           // 774\n// value for the style (a falsy value implies that the style                                                           // 775\n// is to be removed at the end of the animation). If we had a simple                                                   // 776\n// \"OR\" statement then it would not be enough to catch that.                                                           // 777\nfunction registerRestorableStyles(backup, node, properties) {                                                          // 778\n  forEach(properties, function(prop) {                                                                                 // 779\n    backup[prop] = isDefined(backup[prop])                                                                             // 780\n        ? backup[prop]                                                                                                 // 781\n        : node.style.getPropertyValue(prop);                                                                           // 782\n  });                                                                                                                  // 783\n}                                                                                                                      // 784\n                                                                                                                       // 785\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {                                            // 786\n  var gcsLookup = createLocalCacheLookup();                                                                            // 787\n  var gcsStaggerLookup = createLocalCacheLookup();                                                                     // 788\n                                                                                                                       // 789\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',                                                   // 790\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$animate',                                              // 791\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,                                                    // 792\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $animate) {                                               // 793\n                                                                                                                       // 794\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);                                                // 795\n                                                                                                                       // 796\n    var parentCounter = 0;                                                                                             // 797\n    function gcsHashFn(node, extraClasses) {                                                                           // 798\n      var KEY = \"$$ngAnimateParentKey\";                                                                                // 799\n      var parentNode = node.parentNode;                                                                                // 800\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);                                           // 801\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;                                         // 802\n    }                                                                                                                  // 803\n                                                                                                                       // 804\n    function computeCachedCssStyles(node, className, cacheKey, properties) {                                           // 805\n      var timings = gcsLookup.get(cacheKey);                                                                           // 806\n                                                                                                                       // 807\n      if (!timings) {                                                                                                  // 808\n        timings = computeCssStyles($window, node, properties);                                                         // 809\n        if (timings.animationIterationCount === 'infinite') {                                                          // 810\n          timings.animationIterationCount = 1;                                                                         // 811\n        }                                                                                                              // 812\n      }                                                                                                                // 813\n                                                                                                                       // 814\n      // we keep putting this in multiple times even though the value and the cacheKey are the same                    // 815\n      // because we're keeping an interal tally of how many duplicate animations are detected.                         // 816\n      gcsLookup.put(cacheKey, timings);                                                                                // 817\n      return timings;                                                                                                  // 818\n    }                                                                                                                  // 819\n                                                                                                                       // 820\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {                                    // 821\n      var stagger;                                                                                                     // 822\n                                                                                                                       // 823\n      // if we have one or more existing matches of matching elements                                                  // 824\n      // containing the same parent + CSS styles (which is how cacheKey works)                                         // 825\n      // then staggering is possible                                                                                   // 826\n      if (gcsLookup.count(cacheKey) > 0) {                                                                             // 827\n        stagger = gcsStaggerLookup.get(cacheKey);                                                                      // 828\n                                                                                                                       // 829\n        if (!stagger) {                                                                                                // 830\n          var staggerClassName = pendClasses(className, '-stagger');                                                   // 831\n                                                                                                                       // 832\n          $$jqLite.addClass(node, staggerClassName);                                                                   // 833\n                                                                                                                       // 834\n          stagger = computeCssStyles($window, node, properties);                                                       // 835\n                                                                                                                       // 836\n          // force the conversion of a null value to zero incase not set                                               // 837\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);                                          // 838\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);                                        // 839\n                                                                                                                       // 840\n          $$jqLite.removeClass(node, staggerClassName);                                                                // 841\n                                                                                                                       // 842\n          gcsStaggerLookup.put(cacheKey, stagger);                                                                     // 843\n        }                                                                                                              // 844\n      }                                                                                                                // 845\n                                                                                                                       // 846\n      return stagger || {};                                                                                            // 847\n    }                                                                                                                  // 848\n                                                                                                                       // 849\n    var cancelLastRAFRequest;                                                                                          // 850\n    var rafWaitQueue = [];                                                                                             // 851\n    function waitUntilQuiet(callback) {                                                                                // 852\n      rafWaitQueue.push(callback);                                                                                     // 853\n      $$rAFScheduler.waitUntilQuiet(function() {                                                                       // 854\n        gcsLookup.flush();                                                                                             // 855\n        gcsStaggerLookup.flush();                                                                                      // 856\n                                                                                                                       // 857\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.                                           // 858\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.                                               // 859\n        var pageWidth = $$forceReflow();                                                                               // 860\n                                                                                                                       // 861\n        // we use a for loop to ensure that if the queue is changed                                                    // 862\n        // during this looping then it will consider new requests                                                      // 863\n        for (var i = 0; i < rafWaitQueue.length; i++) {                                                                // 864\n          rafWaitQueue[i](pageWidth);                                                                                  // 865\n        }                                                                                                              // 866\n        rafWaitQueue.length = 0;                                                                                       // 867\n      });                                                                                                              // 868\n    }                                                                                                                  // 869\n                                                                                                                       // 870\n    function computeTimings(node, className, cacheKey) {                                                               // 871\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);                          // 872\n      var aD = timings.animationDelay;                                                                                 // 873\n      var tD = timings.transitionDelay;                                                                                // 874\n      timings.maxDelay = aD && tD                                                                                      // 875\n          ? Math.max(aD, tD)                                                                                           // 876\n          : (aD || tD);                                                                                                // 877\n      timings.maxDuration = Math.max(                                                                                  // 878\n          timings.animationDuration * timings.animationIterationCount,                                                 // 879\n          timings.transitionDuration);                                                                                 // 880\n                                                                                                                       // 881\n      return timings;                                                                                                  // 882\n    }                                                                                                                  // 883\n                                                                                                                       // 884\n    return function init(element, options) {                                                                           // 885\n      var restoreStyles = {};                                                                                          // 886\n      var node = getDomNode(element);                                                                                  // 887\n      if (!node                                                                                                        // 888\n          || !node.parentNode                                                                                          // 889\n          || !$animate.enabled()) {                                                                                    // 890\n        return closeAndReturnNoopAnimator();                                                                           // 891\n      }                                                                                                                // 892\n                                                                                                                       // 893\n      options = prepareAnimationOptions(options);                                                                      // 894\n                                                                                                                       // 895\n      var temporaryStyles = [];                                                                                        // 896\n      var classes = element.attr('class');                                                                             // 897\n      var styles = packageStyles(options);                                                                             // 898\n      var animationClosed;                                                                                             // 899\n      var animationPaused;                                                                                             // 900\n      var animationCompleted;                                                                                          // 901\n      var runner;                                                                                                      // 902\n      var runnerHost;                                                                                                  // 903\n      var maxDelay;                                                                                                    // 904\n      var maxDelayTime;                                                                                                // 905\n      var maxDuration;                                                                                                 // 906\n      var maxDurationTime;                                                                                             // 907\n                                                                                                                       // 908\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {                                 // 909\n        return closeAndReturnNoopAnimator();                                                                           // 910\n      }                                                                                                                // 911\n                                                                                                                       // 912\n      var method = options.event && isArray(options.event)                                                             // 913\n            ? options.event.join(' ')                                                                                  // 914\n            : options.event;                                                                                           // 915\n                                                                                                                       // 916\n      var isStructural = method && options.structural;                                                                 // 917\n      var structuralClassName = '';                                                                                    // 918\n      var addRemoveClassName = '';                                                                                     // 919\n                                                                                                                       // 920\n      if (isStructural) {                                                                                              // 921\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);                                           // 922\n      } else if (method) {                                                                                             // 923\n        structuralClassName = method;                                                                                  // 924\n      }                                                                                                                // 925\n                                                                                                                       // 926\n      if (options.addClass) {                                                                                          // 927\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);                                         // 928\n      }                                                                                                                // 929\n                                                                                                                       // 930\n      if (options.removeClass) {                                                                                       // 931\n        if (addRemoveClassName.length) {                                                                               // 932\n          addRemoveClassName += ' ';                                                                                   // 933\n        }                                                                                                              // 934\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);                                   // 935\n      }                                                                                                                // 936\n                                                                                                                       // 937\n      // there may be a situation where a structural animation is combined together                                    // 938\n      // with CSS classes that need to resolve before the animation is computed.                                       // 939\n      // However this means that there is no explicit CSS code to block the animation                                  // 940\n      // from happening (by setting 0s none in the class name). If this is the case                                    // 941\n      // we need to apply the classes before the first rAF so we know to continue if                                   // 942\n      // there actually is a detected transition or keyframe animation                                                 // 943\n      if (options.applyClassesEarly && addRemoveClassName.length) {                                                    // 944\n        applyAnimationClasses(element, options);                                                                       // 945\n      }                                                                                                                // 946\n                                                                                                                       // 947\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();                             // 948\n      var fullClassName = classes + ' ' + preparationClasses;                                                          // 949\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);                                        // 950\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;                                                // 951\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;                                        // 952\n                                                                                                                       // 953\n      // there is no way we can trigger an animation if no styles and                                                  // 954\n      // no classes are being applied which would then trigger a transition,                                           // 955\n      // unless there a is raw keyframe value that is applied to the element.                                          // 956\n      if (!containsKeyframeAnimation                                                                                   // 957\n           && !hasToStyles                                                                                             // 958\n           && !preparationClasses) {                                                                                   // 959\n        return closeAndReturnNoopAnimator();                                                                           // 960\n      }                                                                                                                // 961\n                                                                                                                       // 962\n      var cacheKey, stagger;                                                                                           // 963\n      if (options.stagger > 0) {                                                                                       // 964\n        var staggerVal = parseFloat(options.stagger);                                                                  // 965\n        stagger = {                                                                                                    // 966\n          transitionDelay: staggerVal,                                                                                 // 967\n          animationDelay: staggerVal,                                                                                  // 968\n          transitionDuration: 0,                                                                                       // 969\n          animationDuration: 0                                                                                         // 970\n        };                                                                                                             // 971\n      } else {                                                                                                         // 972\n        cacheKey = gcsHashFn(node, fullClassName);                                                                     // 973\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);    // 974\n      }                                                                                                                // 975\n                                                                                                                       // 976\n      if (!options.$$skipPreparationClasses) {                                                                         // 977\n        $$jqLite.addClass(element, preparationClasses);                                                                // 978\n      }                                                                                                                // 979\n                                                                                                                       // 980\n      var applyOnlyDuration;                                                                                           // 981\n                                                                                                                       // 982\n      if (options.transitionStyle) {                                                                                   // 983\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];                                              // 984\n        applyInlineStyle(node, transitionStyle);                                                                       // 985\n        temporaryStyles.push(transitionStyle);                                                                         // 986\n      }                                                                                                                // 987\n                                                                                                                       // 988\n      if (options.duration >= 0) {                                                                                     // 989\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;                                                    // 990\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);                        // 991\n                                                                                                                       // 992\n        // we set the duration so that it will be picked up by getComputedStyle later                                  // 993\n        applyInlineStyle(node, durationStyle);                                                                         // 994\n        temporaryStyles.push(durationStyle);                                                                           // 995\n      }                                                                                                                // 996\n                                                                                                                       // 997\n      if (options.keyframeStyle) {                                                                                     // 998\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];                                                   // 999\n        applyInlineStyle(node, keyframeStyle);                                                                         // 1000\n        temporaryStyles.push(keyframeStyle);                                                                           // 1001\n      }                                                                                                                // 1002\n                                                                                                                       // 1003\n      var itemIndex = stagger                                                                                          // 1004\n          ? options.staggerIndex >= 0                                                                                  // 1005\n              ? options.staggerIndex                                                                                   // 1006\n              : gcsLookup.count(cacheKey)                                                                              // 1007\n          : 0;                                                                                                         // 1008\n                                                                                                                       // 1009\n      var isFirst = itemIndex === 0;                                                                                   // 1010\n                                                                                                                       // 1011\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY                      // 1012\n      // without causing any combination of transitions to kick in. By adding a negative delay value                   // 1013\n      // it forces the setup class' transition to end immediately. We later then remove the negative                   // 1014\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is                   // 1015\n      // that if there is no transition defined then nothing will happen and this will also allow                      // 1016\n      // other transitions to be stacked on top of each other without any chopping them out.                           // 1017\n      if (isFirst && !options.skipBlocking) {                                                                          // 1018\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);                                                      // 1019\n      }                                                                                                                // 1020\n                                                                                                                       // 1021\n      var timings = computeTimings(node, fullClassName, cacheKey);                                                     // 1022\n      var relativeDelay = timings.maxDelay;                                                                            // 1023\n      maxDelay = Math.max(relativeDelay, 0);                                                                           // 1024\n      maxDuration = timings.maxDuration;                                                                               // 1025\n                                                                                                                       // 1026\n      var flags = {};                                                                                                  // 1027\n      flags.hasTransitions          = timings.transitionDuration > 0;                                                  // 1028\n      flags.hasAnimations           = timings.animationDuration > 0;                                                   // 1029\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';                     // 1030\n      flags.applyTransitionDuration = hasToStyles && (                                                                 // 1031\n                                        (flags.hasTransitions && !flags.hasTransitionAll)                              // 1032\n                                         || (flags.hasAnimations && !flags.hasTransitions));                           // 1033\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;                                         // 1034\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;                         // 1036\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;                                                   // 1037\n                                                                                                                       // 1038\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {                                             // 1039\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;                                   // 1040\n                                                                                                                       // 1041\n        if (flags.applyTransitionDuration) {                                                                           // 1042\n          flags.hasTransitions = true;                                                                                 // 1043\n          timings.transitionDuration = maxDuration;                                                                    // 1044\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;                                   // 1045\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));                         // 1046\n        }                                                                                                              // 1047\n                                                                                                                       // 1048\n        if (flags.applyAnimationDuration) {                                                                            // 1049\n          flags.hasAnimations = true;                                                                                  // 1050\n          timings.animationDuration = maxDuration;                                                                     // 1051\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));                                              // 1052\n        }                                                                                                              // 1053\n      }                                                                                                                // 1054\n                                                                                                                       // 1055\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {                                                       // 1056\n        return closeAndReturnNoopAnimator();                                                                           // 1057\n      }                                                                                                                // 1058\n                                                                                                                       // 1059\n      if (options.delay != null) {                                                                                     // 1060\n        var delayStyle = parseFloat(options.delay);                                                                    // 1061\n                                                                                                                       // 1062\n        if (flags.applyTransitionDelay) {                                                                              // 1063\n          temporaryStyles.push(getCssDelayStyle(delayStyle));                                                          // 1064\n        }                                                                                                              // 1065\n                                                                                                                       // 1066\n        if (flags.applyAnimationDelay) {                                                                               // 1067\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));                                                    // 1068\n        }                                                                                                              // 1069\n      }                                                                                                                // 1070\n                                                                                                                       // 1071\n      // we need to recalculate the delay value since we used a pre-emptive negative                                   // 1072\n      // delay value and the delay value is required for the final event checking. This                                // 1073\n      // property will ensure that this will happen after the RAF phase has passed.                                    // 1074\n      if (options.duration == null && timings.transitionDuration > 0) {                                                // 1075\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;                                      // 1076\n      }                                                                                                                // 1077\n                                                                                                                       // 1078\n      maxDelayTime = maxDelay * ONE_SECOND;                                                                            // 1079\n      maxDurationTime = maxDuration * ONE_SECOND;                                                                      // 1080\n      if (!options.skipBlocking) {                                                                                     // 1081\n        flags.blockTransition = timings.transitionDuration > 0;                                                        // 1082\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&                                                // 1083\n                                       stagger.animationDelay > 0 &&                                                   // 1084\n                                       stagger.animationDuration === 0;                                                // 1085\n      }                                                                                                                // 1086\n                                                                                                                       // 1087\n      if (options.from) {                                                                                              // 1088\n        if (options.cleanupStyles) {                                                                                   // 1089\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));                                    // 1090\n        }                                                                                                              // 1091\n        applyAnimationFromStyles(element, options);                                                                    // 1092\n      }                                                                                                                // 1093\n                                                                                                                       // 1094\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {                                                     // 1095\n        applyBlocking(maxDuration);                                                                                    // 1096\n      } else if (!options.skipBlocking) {                                                                              // 1097\n        blockTransitions(node, false);                                                                                 // 1098\n      }                                                                                                                // 1099\n                                                                                                                       // 1100\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging                        // 1101\n      return {                                                                                                         // 1102\n        $$willAnimate: true,                                                                                           // 1103\n        end: endFn,                                                                                                    // 1104\n        start: function() {                                                                                            // 1105\n          if (animationClosed) return;                                                                                 // 1106\n                                                                                                                       // 1107\n          runnerHost = {                                                                                               // 1108\n            end: endFn,                                                                                                // 1109\n            cancel: cancelFn,                                                                                          // 1110\n            resume: null, //this will be set during the start() phase                                                  // 1111\n            pause: null                                                                                                // 1112\n          };                                                                                                           // 1113\n                                                                                                                       // 1114\n          runner = new $$AnimateRunner(runnerHost);                                                                    // 1115\n                                                                                                                       // 1116\n          waitUntilQuiet(start);                                                                                       // 1117\n                                                                                                                       // 1118\n          // we don't have access to pause/resume the animation                                                        // 1119\n          // since it hasn't run yet. AnimateRunner will therefore                                                     // 1120\n          // set noop functions for resume and pause and they will                                                     // 1121\n          // later be overridden once the animation is triggered                                                       // 1122\n          return runner;                                                                                               // 1123\n        }                                                                                                              // 1124\n      };                                                                                                               // 1125\n                                                                                                                       // 1126\n      function endFn() {                                                                                               // 1127\n        close();                                                                                                       // 1128\n      }                                                                                                                // 1129\n                                                                                                                       // 1130\n      function cancelFn() {                                                                                            // 1131\n        close(true);                                                                                                   // 1132\n      }                                                                                                                // 1133\n                                                                                                                       // 1134\n      function close(rejected) { // jshint ignore:line                                                                 // 1135\n        // if the promise has been called already then we shouldn't close                                              // 1136\n        // the animation again                                                                                         // 1137\n        if (animationClosed || (animationCompleted && animationPaused)) return;                                        // 1138\n        animationClosed = true;                                                                                        // 1139\n        animationPaused = false;                                                                                       // 1140\n                                                                                                                       // 1141\n        if (!options.$$skipPreparationClasses) {                                                                       // 1142\n          $$jqLite.removeClass(element, preparationClasses);                                                           // 1143\n        }                                                                                                              // 1144\n        $$jqLite.removeClass(element, activeClasses);                                                                  // 1145\n                                                                                                                       // 1146\n        blockKeyframeAnimations(node, false);                                                                          // 1147\n        blockTransitions(node, false);                                                                                 // 1148\n                                                                                                                       // 1149\n        forEach(temporaryStyles, function(entry) {                                                                     // 1150\n          // There is only one way to remove inline style properties entirely from elements.                           // 1151\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS                              // 1152\n          // styles down to hyphenated values.                                                                         // 1153\n          node.style[entry[0]] = '';                                                                                   // 1154\n        });                                                                                                            // 1155\n                                                                                                                       // 1156\n        applyAnimationClasses(element, options);                                                                       // 1157\n        applyAnimationStyles(element, options);                                                                        // 1158\n                                                                                                                       // 1159\n        if (Object.keys(restoreStyles).length) {                                                                       // 1160\n          forEach(restoreStyles, function(value, prop) {                                                               // 1161\n            value ? node.style.setProperty(prop, value)                                                                // 1162\n                  : node.style.removeProperty(prop);                                                                   // 1163\n          });                                                                                                          // 1164\n        }                                                                                                              // 1165\n                                                                                                                       // 1166\n        // the reason why we have this option is to allow a synchronous closing callback                               // 1167\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if                                 // 1168\n        // the animation never takes off at all. A good example is a leave animation since                             // 1169\n        // the element must be removed just after the animation is over or else the element                            // 1170\n        // will appear on screen for one animation frame causing an overbearing flicker.                               // 1171\n        if (options.onDone) {                                                                                          // 1172\n          options.onDone();                                                                                            // 1173\n        }                                                                                                              // 1174\n                                                                                                                       // 1175\n        // if the preparation function fails then the promise is not setup                                             // 1176\n        if (runner) {                                                                                                  // 1177\n          runner.complete(!rejected);                                                                                  // 1178\n        }                                                                                                              // 1179\n      }                                                                                                                // 1180\n                                                                                                                       // 1181\n      function applyBlocking(duration) {                                                                               // 1182\n        if (flags.blockTransition) {                                                                                   // 1183\n          blockTransitions(node, duration);                                                                            // 1184\n        }                                                                                                              // 1185\n                                                                                                                       // 1186\n        if (flags.blockKeyframeAnimation) {                                                                            // 1187\n          blockKeyframeAnimations(node, !!duration);                                                                   // 1188\n        }                                                                                                              // 1189\n      }                                                                                                                // 1190\n                                                                                                                       // 1191\n      function closeAndReturnNoopAnimator() {                                                                          // 1192\n        runner = new $$AnimateRunner({                                                                                 // 1193\n          end: endFn,                                                                                                  // 1194\n          cancel: cancelFn                                                                                             // 1195\n        });                                                                                                            // 1196\n                                                                                                                       // 1197\n        // should flush the cache animation                                                                            // 1198\n        waitUntilQuiet(noop);                                                                                          // 1199\n        close();                                                                                                       // 1200\n                                                                                                                       // 1201\n        return {                                                                                                       // 1202\n          $$willAnimate: false,                                                                                        // 1203\n          start: function() {                                                                                          // 1204\n            return runner;                                                                                             // 1205\n          },                                                                                                           // 1206\n          end: endFn                                                                                                   // 1207\n        };                                                                                                             // 1208\n      }                                                                                                                // 1209\n                                                                                                                       // 1210\n      function start() {                                                                                               // 1211\n        if (animationClosed) return;                                                                                   // 1212\n        if (!node.parentNode) {                                                                                        // 1213\n          close();                                                                                                     // 1214\n          return;                                                                                                      // 1215\n        }                                                                                                              // 1216\n                                                                                                                       // 1217\n        var startTime, events = [];                                                                                    // 1218\n                                                                                                                       // 1219\n        // even though we only pause keyframe animations here the pause flag                                           // 1220\n        // will still happen when transitions are used. Only the transition will                                       // 1221\n        // not be paused since that is not possible. If the animation ends when                                        // 1222\n        // paused then it will not complete until unpaused or cancelled.                                               // 1223\n        var playPause = function(playAnimation) {                                                                      // 1224\n          if (!animationCompleted) {                                                                                   // 1225\n            animationPaused = !playAnimation;                                                                          // 1226\n            if (timings.animationDuration) {                                                                           // 1227\n              var value = blockKeyframeAnimations(node, animationPaused);                                              // 1228\n              animationPaused                                                                                          // 1229\n                  ? temporaryStyles.push(value)                                                                        // 1230\n                  : removeFromArray(temporaryStyles, value);                                                           // 1231\n            }                                                                                                          // 1232\n          } else if (animationPaused && playAnimation) {                                                               // 1233\n            animationPaused = false;                                                                                   // 1234\n            close();                                                                                                   // 1235\n          }                                                                                                            // 1236\n        };                                                                                                             // 1237\n                                                                                                                       // 1238\n        // checking the stagger duration prevents an accidently cascade of the CSS delay style                         // 1239\n        // being inherited from the parent. If the transition duration is zero then we can safely                      // 1240\n        // rely that the delay value is an intential stagger delay style.                                              // 1241\n        var maxStagger = itemIndex > 0                                                                                 // 1242\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||                       // 1243\n                            (timings.animationDuration && stagger.animationDuration === 0))                            // 1244\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);                                 // 1245\n        if (maxStagger) {                                                                                              // 1246\n          $timeout(triggerAnimationStart,                                                                              // 1247\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),                                                    // 1248\n                   false);                                                                                             // 1249\n        } else {                                                                                                       // 1250\n          triggerAnimationStart();                                                                                     // 1251\n        }                                                                                                              // 1252\n                                                                                                                       // 1253\n        // this will decorate the existing promise runner with pause/resume methods                                    // 1254\n        runnerHost.resume = function() {                                                                               // 1255\n          playPause(true);                                                                                             // 1256\n        };                                                                                                             // 1257\n                                                                                                                       // 1258\n        runnerHost.pause = function() {                                                                                // 1259\n          playPause(false);                                                                                            // 1260\n        };                                                                                                             // 1261\n                                                                                                                       // 1262\n        function triggerAnimationStart() {                                                                             // 1263\n          // just incase a stagger animation kicks in when the animation                                               // 1264\n          // itself was cancelled entirely                                                                             // 1265\n          if (animationClosed) return;                                                                                 // 1266\n                                                                                                                       // 1267\n          applyBlocking(false);                                                                                        // 1268\n                                                                                                                       // 1269\n          forEach(temporaryStyles, function(entry) {                                                                   // 1270\n            var key = entry[0];                                                                                        // 1271\n            var value = entry[1];                                                                                      // 1272\n            node.style[key] = value;                                                                                   // 1273\n          });                                                                                                          // 1274\n                                                                                                                       // 1275\n          applyAnimationClasses(element, options);                                                                     // 1276\n          $$jqLite.addClass(element, activeClasses);                                                                   // 1277\n                                                                                                                       // 1278\n          if (flags.recalculateTimingStyles) {                                                                         // 1279\n            fullClassName = node.className + ' ' + preparationClasses;                                                 // 1280\n            cacheKey = gcsHashFn(node, fullClassName);                                                                 // 1281\n                                                                                                                       // 1282\n            timings = computeTimings(node, fullClassName, cacheKey);                                                   // 1283\n            relativeDelay = timings.maxDelay;                                                                          // 1284\n            maxDelay = Math.max(relativeDelay, 0);                                                                     // 1285\n            maxDuration = timings.maxDuration;                                                                         // 1286\n                                                                                                                       // 1287\n            if (maxDuration === 0) {                                                                                   // 1288\n              close();                                                                                                 // 1289\n              return;                                                                                                  // 1290\n            }                                                                                                          // 1291\n                                                                                                                       // 1292\n            flags.hasTransitions = timings.transitionDuration > 0;                                                     // 1293\n            flags.hasAnimations = timings.animationDuration > 0;                                                       // 1294\n          }                                                                                                            // 1295\n                                                                                                                       // 1296\n          if (flags.applyAnimationDelay) {                                                                             // 1297\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)                     // 1298\n                  ? parseFloat(options.delay)                                                                          // 1299\n                  : relativeDelay;                                                                                     // 1300\n                                                                                                                       // 1301\n            maxDelay = Math.max(relativeDelay, 0);                                                                     // 1302\n            timings.animationDelay = relativeDelay;                                                                    // 1303\n            delayStyle = getCssDelayStyle(relativeDelay, true);                                                        // 1304\n            temporaryStyles.push(delayStyle);                                                                          // 1305\n            node.style[delayStyle[0]] = delayStyle[1];                                                                 // 1306\n          }                                                                                                            // 1307\n                                                                                                                       // 1308\n          maxDelayTime = maxDelay * ONE_SECOND;                                                                        // 1309\n          maxDurationTime = maxDuration * ONE_SECOND;                                                                  // 1310\n                                                                                                                       // 1311\n          if (options.easing) {                                                                                        // 1312\n            var easeProp, easeVal = options.easing;                                                                    // 1313\n            if (flags.hasTransitions) {                                                                                // 1314\n              easeProp = TRANSITION_PROP + TIMING_KEY;                                                                 // 1315\n              temporaryStyles.push([easeProp, easeVal]);                                                               // 1316\n              node.style[easeProp] = easeVal;                                                                          // 1317\n            }                                                                                                          // 1318\n            if (flags.hasAnimations) {                                                                                 // 1319\n              easeProp = ANIMATION_PROP + TIMING_KEY;                                                                  // 1320\n              temporaryStyles.push([easeProp, easeVal]);                                                               // 1321\n              node.style[easeProp] = easeVal;                                                                          // 1322\n            }                                                                                                          // 1323\n          }                                                                                                            // 1324\n                                                                                                                       // 1325\n          if (timings.transitionDuration) {                                                                            // 1326\n            events.push(TRANSITIONEND_EVENT);                                                                          // 1327\n          }                                                                                                            // 1328\n                                                                                                                       // 1329\n          if (timings.animationDuration) {                                                                             // 1330\n            events.push(ANIMATIONEND_EVENT);                                                                           // 1331\n          }                                                                                                            // 1332\n                                                                                                                       // 1333\n          startTime = Date.now();                                                                                      // 1334\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;                                        // 1335\n          var endTime = startTime + timerTime;                                                                         // 1336\n                                                                                                                       // 1337\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];                                                  // 1338\n          var setupFallbackTimer = true;                                                                               // 1339\n          if (animationsData.length) {                                                                                 // 1340\n            var currentTimerData = animationsData[0];                                                                  // 1341\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;                                           // 1342\n            if (setupFallbackTimer) {                                                                                  // 1343\n              $timeout.cancel(currentTimerData.timer);                                                                 // 1344\n            } else {                                                                                                   // 1345\n              animationsData.push(close);                                                                              // 1346\n            }                                                                                                          // 1347\n          }                                                                                                            // 1348\n                                                                                                                       // 1349\n          if (setupFallbackTimer) {                                                                                    // 1350\n            var timer = $timeout(onAnimationExpired, timerTime, false);                                                // 1351\n            animationsData[0] = {                                                                                      // 1352\n              timer: timer,                                                                                            // 1353\n              expectedEndTime: endTime                                                                                 // 1354\n            };                                                                                                         // 1355\n            animationsData.push(close);                                                                                // 1356\n            element.data(ANIMATE_TIMER_KEY, animationsData);                                                           // 1357\n          }                                                                                                            // 1358\n                                                                                                                       // 1359\n          element.on(events.join(' '), onAnimationProgress);                                                           // 1360\n          if (options.to) {                                                                                            // 1361\n            if (options.cleanupStyles) {                                                                               // 1362\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));                                  // 1363\n            }                                                                                                          // 1364\n            applyAnimationToStyles(element, options);                                                                  // 1365\n          }                                                                                                            // 1366\n        }                                                                                                              // 1367\n                                                                                                                       // 1368\n        function onAnimationExpired() {                                                                                // 1369\n          var animationsData = element.data(ANIMATE_TIMER_KEY);                                                        // 1370\n                                                                                                                       // 1371\n          // this will be false in the event that the element was                                                      // 1372\n          // removed from the DOM (via a leave animation or something                                                  // 1373\n          // similar)                                                                                                  // 1374\n          if (animationsData) {                                                                                        // 1375\n            for (var i = 1; i < animationsData.length; i++) {                                                          // 1376\n              animationsData[i]();                                                                                     // 1377\n            }                                                                                                          // 1378\n            element.removeData(ANIMATE_TIMER_KEY);                                                                     // 1379\n          }                                                                                                            // 1380\n        }                                                                                                              // 1381\n                                                                                                                       // 1382\n        function onAnimationProgress(event) {                                                                          // 1383\n          event.stopPropagation();                                                                                     // 1384\n          var ev = event.originalEvent || event;                                                                       // 1385\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();                                           // 1386\n                                                                                                                       // 1387\n          /* Firefox (or possibly just Gecko) likes to not round values up                                             // 1388\n           * when a ms measurement is used for the animation */                                                        // 1389\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));                       // 1390\n                                                                                                                       // 1391\n          /* $manualTimeStamp is a mocked timeStamp value which is set                                                 // 1392\n           * within browserTrigger(). This is only here so that tests can                                              // 1393\n           * mock animations properly. Real events fallback to event.timeStamp,                                        // 1394\n           * or, if they don't, then a timeStamp is automatically created for them.                                    // 1395\n           * We're checking to see if the timeStamp surpasses the expected delay,                                      // 1396\n           * but we're using elapsedTime instead of the timeStamp on the 2nd                                           // 1397\n           * pre-condition since animations sometimes close off early */                                               // 1398\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {                      // 1399\n            // we set this flag to ensure that if the transition is paused then, when resumed,                         // 1400\n            // the animation will automatically close itself since transitions cannot be paused.                       // 1401\n            animationCompleted = true;                                                                                 // 1402\n            close();                                                                                                   // 1403\n          }                                                                                                            // 1404\n        }                                                                                                              // 1405\n      }                                                                                                                // 1406\n    };                                                                                                                 // 1407\n  }];                                                                                                                  // 1408\n}];                                                                                                                    // 1409\n                                                                                                                       // 1410\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {                               // 1411\n  $$animationProvider.drivers.push('$$animateCssDriver');                                                              // 1412\n                                                                                                                       // 1413\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';                                                                  // 1414\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';                                                                      // 1415\n                                                                                                                       // 1416\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';                                                                      // 1417\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';                                                                        // 1418\n                                                                                                                       // 1419\n  function isDocumentFragment(node) {                                                                                  // 1420\n    return node.parentNode && node.parentNode.nodeType === 11;                                                         // 1421\n  }                                                                                                                    // 1422\n                                                                                                                       // 1423\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',    // 1424\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {   // 1425\n                                                                                                                       // 1426\n    // only browsers that support these properties can render animations                                               // 1427\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;                                                    // 1428\n                                                                                                                       // 1429\n    var bodyNode = $document[0].body;                                                                                  // 1430\n    var rootNode = getDomNode($rootElement);                                                                           // 1431\n                                                                                                                       // 1432\n    var rootBodyElement = jqLite(                                                                                      // 1433\n      // this is to avoid using something that exists outside of the body                                              // 1434\n      // we also special case the doc fragement case because our unit test code                                        // 1435\n      // appends the $rootElement to the body after the app has been bootstrapped                                      // 1436\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode                                // 1437\n    );                                                                                                                 // 1438\n                                                                                                                       // 1439\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);                                                // 1440\n                                                                                                                       // 1441\n    return function initDriverFn(animationDetails) {                                                                   // 1442\n      return animationDetails.from && animationDetails.to                                                              // 1443\n          ? prepareFromToAnchorAnimation(animationDetails.from,                                                        // 1444\n                                         animationDetails.to,                                                          // 1445\n                                         animationDetails.classes,                                                     // 1446\n                                         animationDetails.anchors)                                                     // 1447\n          : prepareRegularAnimation(animationDetails);                                                                 // 1448\n    };                                                                                                                 // 1449\n                                                                                                                       // 1450\n    function filterCssClasses(classes) {                                                                               // 1451\n      //remove all the `ng-` stuff                                                                                     // 1452\n      return classes.replace(/\\bng-\\S+\\b/g, '');                                                                       // 1453\n    }                                                                                                                  // 1454\n                                                                                                                       // 1455\n    function getUniqueValues(a, b) {                                                                                   // 1456\n      if (isString(a)) a = a.split(' ');                                                                               // 1457\n      if (isString(b)) b = b.split(' ');                                                                               // 1458\n      return a.filter(function(val) {                                                                                  // 1459\n        return b.indexOf(val) === -1;                                                                                  // 1460\n      }).join(' ');                                                                                                    // 1461\n    }                                                                                                                  // 1462\n                                                                                                                       // 1463\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {                                                  // 1464\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));                                                       // 1465\n      var startingClasses = filterCssClasses(getClassVal(clone));                                                      // 1466\n                                                                                                                       // 1467\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);                                                                  // 1468\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);                                                                   // 1469\n                                                                                                                       // 1470\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);                                                                    // 1471\n                                                                                                                       // 1472\n      rootBodyElement.append(clone);                                                                                   // 1473\n                                                                                                                       // 1474\n      var animatorIn, animatorOut = prepareOutAnimation();                                                             // 1475\n                                                                                                                       // 1476\n      // the user may not end up using the `out` animation and                                                         // 1477\n      // only making use of the `in` animation or vice-versa.                                                          // 1478\n      // In either case we should allow this and not assume the                                                        // 1479\n      // animation is over unless both animations are not used.                                                        // 1480\n      if (!animatorOut) {                                                                                              // 1481\n        animatorIn = prepareInAnimation();                                                                             // 1482\n        if (!animatorIn) {                                                                                             // 1483\n          return end();                                                                                                // 1484\n        }                                                                                                              // 1485\n      }                                                                                                                // 1486\n                                                                                                                       // 1487\n      var startingAnimator = animatorOut || animatorIn;                                                                // 1488\n                                                                                                                       // 1489\n      return {                                                                                                         // 1490\n        start: function() {                                                                                            // 1491\n          var runner;                                                                                                  // 1492\n                                                                                                                       // 1493\n          var currentAnimation = startingAnimator.start();                                                             // 1494\n          currentAnimation.done(function() {                                                                           // 1495\n            currentAnimation = null;                                                                                   // 1496\n            if (!animatorIn) {                                                                                         // 1497\n              animatorIn = prepareInAnimation();                                                                       // 1498\n              if (animatorIn) {                                                                                        // 1499\n                currentAnimation = animatorIn.start();                                                                 // 1500\n                currentAnimation.done(function() {                                                                     // 1501\n                  currentAnimation = null;                                                                             // 1502\n                  end();                                                                                               // 1503\n                  runner.complete();                                                                                   // 1504\n                });                                                                                                    // 1505\n                return currentAnimation;                                                                               // 1506\n              }                                                                                                        // 1507\n            }                                                                                                          // 1508\n            // in the event that there is no `in` animation                                                            // 1509\n            end();                                                                                                     // 1510\n            runner.complete();                                                                                         // 1511\n          });                                                                                                          // 1512\n                                                                                                                       // 1513\n          runner = new $$AnimateRunner({                                                                               // 1514\n            end: endFn,                                                                                                // 1515\n            cancel: endFn                                                                                              // 1516\n          });                                                                                                          // 1517\n                                                                                                                       // 1518\n          return runner;                                                                                               // 1519\n                                                                                                                       // 1520\n          function endFn() {                                                                                           // 1521\n            if (currentAnimation) {                                                                                    // 1522\n              currentAnimation.end();                                                                                  // 1523\n            }                                                                                                          // 1524\n          }                                                                                                            // 1525\n        }                                                                                                              // 1526\n      };                                                                                                               // 1527\n                                                                                                                       // 1528\n      function calculateAnchorStyles(anchor) {                                                                         // 1529\n        var styles = {};                                                                                               // 1530\n                                                                                                                       // 1531\n        var coords = getDomNode(anchor).getBoundingClientRect();                                                       // 1532\n                                                                                                                       // 1533\n        // we iterate directly since safari messes up and doesn't return                                               // 1534\n        // all the keys for the coods object when iterated                                                             // 1535\n        forEach(['width','height','top','left'], function(key) {                                                       // 1536\n          var value = coords[key];                                                                                     // 1537\n          switch (key) {                                                                                               // 1538\n            case 'top':                                                                                                // 1539\n              value += bodyNode.scrollTop;                                                                             // 1540\n              break;                                                                                                   // 1541\n            case 'left':                                                                                               // 1542\n              value += bodyNode.scrollLeft;                                                                            // 1543\n              break;                                                                                                   // 1544\n          }                                                                                                            // 1545\n          styles[key] = Math.floor(value) + 'px';                                                                      // 1546\n        });                                                                                                            // 1547\n        return styles;                                                                                                 // 1548\n      }                                                                                                                // 1549\n                                                                                                                       // 1550\n      function prepareOutAnimation() {                                                                                 // 1551\n        var animator = $animateCss(clone, {                                                                            // 1552\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,                                                                          // 1553\n          delay: true,                                                                                                 // 1554\n          from: calculateAnchorStyles(outAnchor)                                                                       // 1555\n        });                                                                                                            // 1556\n                                                                                                                       // 1557\n        // read the comment within `prepareRegularAnimation` to understand                                             // 1558\n        // why this check is necessary                                                                                 // 1559\n        return animator.$$willAnimate ? animator : null;                                                               // 1560\n      }                                                                                                                // 1561\n                                                                                                                       // 1562\n      function getClassVal(element) {                                                                                  // 1563\n        return element.attr('class') || '';                                                                            // 1564\n      }                                                                                                                // 1565\n                                                                                                                       // 1566\n      function prepareInAnimation() {                                                                                  // 1567\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));                                                   // 1568\n        var toAdd = getUniqueValues(endingClasses, startingClasses);                                                   // 1569\n        var toRemove = getUniqueValues(startingClasses, endingClasses);                                                // 1570\n                                                                                                                       // 1571\n        var animator = $animateCss(clone, {                                                                            // 1572\n          to: calculateAnchorStyles(inAnchor),                                                                         // 1573\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,                                                             // 1574\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,                                                      // 1575\n          delay: true                                                                                                  // 1576\n        });                                                                                                            // 1577\n                                                                                                                       // 1578\n        // read the comment within `prepareRegularAnimation` to understand                                             // 1579\n        // why this check is necessary                                                                                 // 1580\n        return animator.$$willAnimate ? animator : null;                                                               // 1581\n      }                                                                                                                // 1582\n                                                                                                                       // 1583\n      function end() {                                                                                                 // 1584\n        clone.remove();                                                                                                // 1585\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);                                                             // 1586\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);                                                              // 1587\n      }                                                                                                                // 1588\n    }                                                                                                                  // 1589\n                                                                                                                       // 1590\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {                                                // 1591\n      var fromAnimation = prepareRegularAnimation(from, noop);                                                         // 1592\n      var toAnimation = prepareRegularAnimation(to, noop);                                                             // 1593\n                                                                                                                       // 1594\n      var anchorAnimations = [];                                                                                       // 1595\n      forEach(anchors, function(anchor) {                                                                              // 1596\n        var outElement = anchor['out'];                                                                                // 1597\n        var inElement = anchor['in'];                                                                                  // 1598\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);                                       // 1599\n        if (animator) {                                                                                                // 1600\n          anchorAnimations.push(animator);                                                                             // 1601\n        }                                                                                                              // 1602\n      });                                                                                                              // 1603\n                                                                                                                       // 1604\n      // no point in doing anything when there are no elements to animate                                              // 1605\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;                                     // 1606\n                                                                                                                       // 1607\n      return {                                                                                                         // 1608\n        start: function() {                                                                                            // 1609\n          var animationRunners = [];                                                                                   // 1610\n                                                                                                                       // 1611\n          if (fromAnimation) {                                                                                         // 1612\n            animationRunners.push(fromAnimation.start());                                                              // 1613\n          }                                                                                                            // 1614\n                                                                                                                       // 1615\n          if (toAnimation) {                                                                                           // 1616\n            animationRunners.push(toAnimation.start());                                                                // 1617\n          }                                                                                                            // 1618\n                                                                                                                       // 1619\n          forEach(anchorAnimations, function(animation) {                                                              // 1620\n            animationRunners.push(animation.start());                                                                  // 1621\n          });                                                                                                          // 1622\n                                                                                                                       // 1623\n          var runner = new $$AnimateRunner({                                                                           // 1624\n            end: endFn,                                                                                                // 1625\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended                                     // 1626\n          });                                                                                                          // 1627\n                                                                                                                       // 1628\n          $$AnimateRunner.all(animationRunners, function(status) {                                                     // 1629\n            runner.complete(status);                                                                                   // 1630\n          });                                                                                                          // 1631\n                                                                                                                       // 1632\n          return runner;                                                                                               // 1633\n                                                                                                                       // 1634\n          function endFn() {                                                                                           // 1635\n            forEach(animationRunners, function(runner) {                                                               // 1636\n              runner.end();                                                                                            // 1637\n            });                                                                                                        // 1638\n          }                                                                                                            // 1639\n        }                                                                                                              // 1640\n      };                                                                                                               // 1641\n    }                                                                                                                  // 1642\n                                                                                                                       // 1643\n    function prepareRegularAnimation(animationDetails) {                                                               // 1644\n      var element = animationDetails.element;                                                                          // 1645\n      var options = animationDetails.options || {};                                                                    // 1646\n                                                                                                                       // 1647\n      if (animationDetails.structural) {                                                                               // 1648\n        options.event = animationDetails.event;                                                                        // 1649\n        options.structural = true;                                                                                     // 1650\n        options.applyClassesEarly = true;                                                                              // 1651\n                                                                                                                       // 1652\n        // we special case the leave animation since we want to ensure that                                            // 1653\n        // the element is removed as soon as the animation is over. Otherwise                                          // 1654\n        // a flicker might appear or the element may not be removed at all                                             // 1655\n        if (animationDetails.event === 'leave') {                                                                      // 1656\n          options.onDone = options.domOperation;                                                                       // 1657\n        }                                                                                                              // 1658\n      }                                                                                                                // 1659\n                                                                                                                       // 1660\n      // We assign the preparationClasses as the actual animation event since                                          // 1661\n      // the internals of $animateCss will just suffix the event token values                                          // 1662\n      // with `-active` to trigger the animation.                                                                      // 1663\n      if (options.preparationClasses) {                                                                                // 1664\n        options.event = concatWithSpace(options.event, options.preparationClasses);                                    // 1665\n      }                                                                                                                // 1666\n                                                                                                                       // 1667\n      var animator = $animateCss(element, options);                                                                    // 1668\n                                                                                                                       // 1669\n      // the driver lookup code inside of $$animation attempts to spawn a                                              // 1670\n      // driver one by one until a driver returns a.$$willAnimate animator object.                                     // 1671\n      // $animateCss will always return an object, however, it will pass in                                            // 1672\n      // a flag as a hint as to whether an animation was detected or not                                               // 1673\n      return animator.$$willAnimate ? animator : null;                                                                 // 1674\n    }                                                                                                                  // 1675\n  }];                                                                                                                  // 1676\n}];                                                                                                                    // 1677\n                                                                                                                       // 1678\n// TODO(matsko): use caching here to speed things up for detection                                                     // 1679\n// TODO(matsko): add documentation                                                                                     // 1680\n//  by the time...                                                                                                     // 1681\n                                                                                                                       // 1682\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {                                            // 1683\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',                                                             // 1684\n       function($injector,   $$AnimateRunner,   $$jqLite) {                                                            // 1685\n                                                                                                                       // 1686\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);                                                // 1687\n         // $animateJs(element, 'enter');                                                                              // 1688\n    return function(element, event, classes, options) {                                                                // 1689\n      // the `classes` argument is optional and if it is not used                                                      // 1690\n      // then the classes will be resolved from the element's className                                                // 1691\n      // property as well as options.addClass/options.removeClass.                                                     // 1692\n      if (arguments.length === 3 && isObject(classes)) {                                                               // 1693\n        options = classes;                                                                                             // 1694\n        classes = null;                                                                                                // 1695\n      }                                                                                                                // 1696\n                                                                                                                       // 1697\n      options = prepareAnimationOptions(options);                                                                      // 1698\n      if (!classes) {                                                                                                  // 1699\n        classes = element.attr('class') || '';                                                                         // 1700\n        if (options.addClass) {                                                                                        // 1701\n          classes += ' ' + options.addClass;                                                                           // 1702\n        }                                                                                                              // 1703\n        if (options.removeClass) {                                                                                     // 1704\n          classes += ' ' + options.removeClass;                                                                        // 1705\n        }                                                                                                              // 1706\n      }                                                                                                                // 1707\n                                                                                                                       // 1708\n      var classesToAdd = options.addClass;                                                                             // 1709\n      var classesToRemove = options.removeClass;                                                                       // 1710\n                                                                                                                       // 1711\n      // the lookupAnimations function returns a series of animation objects that are                                  // 1712\n      // matched up with one or more of the CSS classes. These animation objects are                                   // 1713\n      // defined via the module.animation factory function. If nothing is detected then                                // 1714\n      // we don't return anything which then makes $animation query the next driver.                                   // 1715\n      var animations = lookupAnimations(classes);                                                                      // 1716\n      var before, after;                                                                                               // 1717\n      if (animations.length) {                                                                                         // 1718\n        var afterFn, beforeFn;                                                                                         // 1719\n        if (event == 'leave') {                                                                                        // 1720\n          beforeFn = 'leave';                                                                                          // 1721\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this                                                     // 1722\n        } else {                                                                                                       // 1723\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);                                       // 1724\n          afterFn = event;                                                                                             // 1725\n        }                                                                                                              // 1726\n                                                                                                                       // 1727\n        if (event !== 'enter' && event !== 'move') {                                                                   // 1728\n          before = packageAnimations(element, event, options, animations, beforeFn);                                   // 1729\n        }                                                                                                              // 1730\n        after  = packageAnimations(element, event, options, animations, afterFn);                                      // 1731\n      }                                                                                                                // 1732\n                                                                                                                       // 1733\n      // no matching animations                                                                                        // 1734\n      if (!before && !after) return;                                                                                   // 1735\n                                                                                                                       // 1736\n      function applyOptions() {                                                                                        // 1737\n        options.domOperation();                                                                                        // 1738\n        applyAnimationClasses(element, options);                                                                       // 1739\n      }                                                                                                                // 1740\n                                                                                                                       // 1741\n      return {                                                                                                         // 1742\n        start: function() {                                                                                            // 1743\n          var closeActiveAnimations;                                                                                   // 1744\n          var chain = [];                                                                                              // 1745\n                                                                                                                       // 1746\n          if (before) {                                                                                                // 1747\n            chain.push(function(fn) {                                                                                  // 1748\n              closeActiveAnimations = before(fn);                                                                      // 1749\n            });                                                                                                        // 1750\n          }                                                                                                            // 1751\n                                                                                                                       // 1752\n          if (chain.length) {                                                                                          // 1753\n            chain.push(function(fn) {                                                                                  // 1754\n              applyOptions();                                                                                          // 1755\n              fn(true);                                                                                                // 1756\n            });                                                                                                        // 1757\n          } else {                                                                                                     // 1758\n            applyOptions();                                                                                            // 1759\n          }                                                                                                            // 1760\n                                                                                                                       // 1761\n          if (after) {                                                                                                 // 1762\n            chain.push(function(fn) {                                                                                  // 1763\n              closeActiveAnimations = after(fn);                                                                       // 1764\n            });                                                                                                        // 1765\n          }                                                                                                            // 1766\n                                                                                                                       // 1767\n          var animationClosed = false;                                                                                 // 1768\n          var runner = new $$AnimateRunner({                                                                           // 1769\n            end: function() {                                                                                          // 1770\n              endAnimations();                                                                                         // 1771\n            },                                                                                                         // 1772\n            cancel: function() {                                                                                       // 1773\n              endAnimations(true);                                                                                     // 1774\n            }                                                                                                          // 1775\n          });                                                                                                          // 1776\n                                                                                                                       // 1777\n          $$AnimateRunner.chain(chain, onComplete);                                                                    // 1778\n          return runner;                                                                                               // 1779\n                                                                                                                       // 1780\n          function onComplete(success) {                                                                               // 1781\n            animationClosed = true;                                                                                    // 1782\n            applyOptions();                                                                                            // 1783\n            applyAnimationStyles(element, options);                                                                    // 1784\n            runner.complete(success);                                                                                  // 1785\n          }                                                                                                            // 1786\n                                                                                                                       // 1787\n          function endAnimations(cancelled) {                                                                          // 1788\n            if (!animationClosed) {                                                                                    // 1789\n              (closeActiveAnimations || noop)(cancelled);                                                              // 1790\n              onComplete(cancelled);                                                                                   // 1791\n            }                                                                                                          // 1792\n          }                                                                                                            // 1793\n        }                                                                                                              // 1794\n      };                                                                                                               // 1795\n                                                                                                                       // 1796\n      function executeAnimationFn(fn, element, event, options, onDone) {                                               // 1797\n        var args;                                                                                                      // 1798\n        switch (event) {                                                                                               // 1799\n          case 'animate':                                                                                              // 1800\n            args = [element, options.from, options.to, onDone];                                                        // 1801\n            break;                                                                                                     // 1802\n                                                                                                                       // 1803\n          case 'setClass':                                                                                             // 1804\n            args = [element, classesToAdd, classesToRemove, onDone];                                                   // 1805\n            break;                                                                                                     // 1806\n                                                                                                                       // 1807\n          case 'addClass':                                                                                             // 1808\n            args = [element, classesToAdd, onDone];                                                                    // 1809\n            break;                                                                                                     // 1810\n                                                                                                                       // 1811\n          case 'removeClass':                                                                                          // 1812\n            args = [element, classesToRemove, onDone];                                                                 // 1813\n            break;                                                                                                     // 1814\n                                                                                                                       // 1815\n          default:                                                                                                     // 1816\n            args = [element, onDone];                                                                                  // 1817\n            break;                                                                                                     // 1818\n        }                                                                                                              // 1819\n                                                                                                                       // 1820\n        args.push(options);                                                                                            // 1821\n                                                                                                                       // 1822\n        var value = fn.apply(fn, args);                                                                                // 1823\n        if (value) {                                                                                                   // 1824\n          if (isFunction(value.start)) {                                                                               // 1825\n            value = value.start();                                                                                     // 1826\n          }                                                                                                            // 1827\n                                                                                                                       // 1828\n          if (value instanceof $$AnimateRunner) {                                                                      // 1829\n            value.done(onDone);                                                                                        // 1830\n          } else if (isFunction(value)) {                                                                              // 1831\n            // optional onEnd / onCancel callback                                                                      // 1832\n            return value;                                                                                              // 1833\n          }                                                                                                            // 1834\n        }                                                                                                              // 1835\n                                                                                                                       // 1836\n        return noop;                                                                                                   // 1837\n      }                                                                                                                // 1838\n                                                                                                                       // 1839\n      function groupEventedAnimations(element, event, options, animations, fnName) {                                   // 1840\n        var operations = [];                                                                                           // 1841\n        forEach(animations, function(ani) {                                                                            // 1842\n          var animation = ani[fnName];                                                                                 // 1843\n          if (!animation) return;                                                                                      // 1844\n                                                                                                                       // 1845\n          // note that all of these animations will run in parallel                                                    // 1846\n          operations.push(function() {                                                                                 // 1847\n            var runner;                                                                                                // 1848\n            var endProgressCb;                                                                                         // 1849\n                                                                                                                       // 1850\n            var resolved = false;                                                                                      // 1851\n            var onAnimationComplete = function(rejected) {                                                             // 1852\n              if (!resolved) {                                                                                         // 1853\n                resolved = true;                                                                                       // 1854\n                (endProgressCb || noop)(rejected);                                                                     // 1855\n                runner.complete(!rejected);                                                                            // 1856\n              }                                                                                                        // 1857\n            };                                                                                                         // 1858\n                                                                                                                       // 1859\n            runner = new $$AnimateRunner({                                                                             // 1860\n              end: function() {                                                                                        // 1861\n                onAnimationComplete();                                                                                 // 1862\n              },                                                                                                       // 1863\n              cancel: function() {                                                                                     // 1864\n                onAnimationComplete(true);                                                                             // 1865\n              }                                                                                                        // 1866\n            });                                                                                                        // 1867\n                                                                                                                       // 1868\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {                  // 1869\n              var cancelled = result === false;                                                                        // 1870\n              onAnimationComplete(cancelled);                                                                          // 1871\n            });                                                                                                        // 1872\n                                                                                                                       // 1873\n            return runner;                                                                                             // 1874\n          });                                                                                                          // 1875\n        });                                                                                                            // 1876\n                                                                                                                       // 1877\n        return operations;                                                                                             // 1878\n      }                                                                                                                // 1879\n                                                                                                                       // 1880\n      function packageAnimations(element, event, options, animations, fnName) {                                        // 1881\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);                          // 1882\n        if (operations.length === 0) {                                                                                 // 1883\n          var a,b;                                                                                                     // 1884\n          if (fnName === 'beforeSetClass') {                                                                           // 1885\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');              // 1886\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');                    // 1887\n          } else if (fnName === 'setClass') {                                                                          // 1888\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');                    // 1889\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');                          // 1890\n          }                                                                                                            // 1891\n                                                                                                                       // 1892\n          if (a) {                                                                                                     // 1893\n            operations = operations.concat(a);                                                                         // 1894\n          }                                                                                                            // 1895\n          if (b) {                                                                                                     // 1896\n            operations = operations.concat(b);                                                                         // 1897\n          }                                                                                                            // 1898\n        }                                                                                                              // 1899\n                                                                                                                       // 1900\n        if (operations.length === 0) return;                                                                           // 1901\n                                                                                                                       // 1902\n        // TODO(matsko): add documentation                                                                             // 1903\n        return function startAnimation(callback) {                                                                     // 1904\n          var runners = [];                                                                                            // 1905\n          if (operations.length) {                                                                                     // 1906\n            forEach(operations, function(animateFn) {                                                                  // 1907\n              runners.push(animateFn());                                                                               // 1908\n            });                                                                                                        // 1909\n          }                                                                                                            // 1910\n                                                                                                                       // 1911\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();                                        // 1912\n                                                                                                                       // 1913\n          return function endFn(reject) {                                                                              // 1914\n            forEach(runners, function(runner) {                                                                        // 1915\n              reject ? runner.cancel() : runner.end();                                                                 // 1916\n            });                                                                                                        // 1917\n          };                                                                                                           // 1918\n        };                                                                                                             // 1919\n      }                                                                                                                // 1920\n    };                                                                                                                 // 1921\n                                                                                                                       // 1922\n    function lookupAnimations(classes) {                                                                               // 1923\n      classes = isArray(classes) ? classes : classes.split(' ');                                                       // 1924\n      var matches = [], flagMap = {};                                                                                  // 1925\n      for (var i=0; i < classes.length; i++) {                                                                         // 1926\n        var klass = classes[i],                                                                                        // 1927\n            animationFactory = $animateProvider.$$registeredAnimations[klass];                                         // 1928\n        if (animationFactory && !flagMap[klass]) {                                                                     // 1929\n          matches.push($injector.get(animationFactory));                                                               // 1930\n          flagMap[klass] = true;                                                                                       // 1931\n        }                                                                                                              // 1932\n      }                                                                                                                // 1933\n      return matches;                                                                                                  // 1934\n    }                                                                                                                  // 1935\n  }];                                                                                                                  // 1936\n}];                                                                                                                    // 1937\n                                                                                                                       // 1938\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {                                // 1939\n  $$animationProvider.drivers.push('$$animateJsDriver');                                                               // 1940\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {                              // 1941\n    return function initDriverFn(animationDetails) {                                                                   // 1942\n      if (animationDetails.from && animationDetails.to) {                                                              // 1943\n        var fromAnimation = prepareAnimation(animationDetails.from);                                                   // 1944\n        var toAnimation = prepareAnimation(animationDetails.to);                                                       // 1945\n        if (!fromAnimation && !toAnimation) return;                                                                    // 1946\n                                                                                                                       // 1947\n        return {                                                                                                       // 1948\n          start: function() {                                                                                          // 1949\n            var animationRunners = [];                                                                                 // 1950\n                                                                                                                       // 1951\n            if (fromAnimation) {                                                                                       // 1952\n              animationRunners.push(fromAnimation.start());                                                            // 1953\n            }                                                                                                          // 1954\n                                                                                                                       // 1955\n            if (toAnimation) {                                                                                         // 1956\n              animationRunners.push(toAnimation.start());                                                              // 1957\n            }                                                                                                          // 1958\n                                                                                                                       // 1959\n            $$AnimateRunner.all(animationRunners, done);                                                               // 1960\n                                                                                                                       // 1961\n            var runner = new $$AnimateRunner({                                                                         // 1962\n              end: endFnFactory(),                                                                                     // 1963\n              cancel: endFnFactory()                                                                                   // 1964\n            });                                                                                                        // 1965\n                                                                                                                       // 1966\n            return runner;                                                                                             // 1967\n                                                                                                                       // 1968\n            function endFnFactory() {                                                                                  // 1969\n              return function() {                                                                                      // 1970\n                forEach(animationRunners, function(runner) {                                                           // 1971\n                  // at this point we cannot cancel animations for groups just yet. 1.5+                               // 1972\n                  runner.end();                                                                                        // 1973\n                });                                                                                                    // 1974\n              };                                                                                                       // 1975\n            }                                                                                                          // 1976\n                                                                                                                       // 1977\n            function done(status) {                                                                                    // 1978\n              runner.complete(status);                                                                                 // 1979\n            }                                                                                                          // 1980\n          }                                                                                                            // 1981\n        };                                                                                                             // 1982\n      } else {                                                                                                         // 1983\n        return prepareAnimation(animationDetails);                                                                     // 1984\n      }                                                                                                                // 1985\n    };                                                                                                                 // 1986\n                                                                                                                       // 1987\n    function prepareAnimation(animationDetails) {                                                                      // 1988\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations                // 1989\n      var element = animationDetails.element;                                                                          // 1990\n      var event = animationDetails.event;                                                                              // 1991\n      var options = animationDetails.options;                                                                          // 1992\n      var classes = animationDetails.classes;                                                                          // 1993\n      return $$animateJs(element, event, classes, options);                                                            // 1994\n    }                                                                                                                  // 1995\n  }];                                                                                                                  // 1996\n}];                                                                                                                    // 1997\n                                                                                                                       // 1998\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';                                                                          // 1999\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';                                                                             // 2000\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {                                         // 2001\n  var PRE_DIGEST_STATE = 1;                                                                                            // 2002\n  var RUNNING_STATE = 2;                                                                                               // 2003\n                                                                                                                       // 2004\n  var rules = this.rules = {                                                                                           // 2005\n    skip: [],                                                                                                          // 2006\n    cancel: [],                                                                                                        // 2007\n    join: []                                                                                                           // 2008\n  };                                                                                                                   // 2009\n                                                                                                                       // 2010\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {                                         // 2011\n    return rules[ruleType].some(function(fn) {                                                                         // 2012\n      return fn(element, currentAnimation, previousAnimation);                                                         // 2013\n    });                                                                                                                // 2014\n  }                                                                                                                    // 2015\n                                                                                                                       // 2016\n  function hasAnimationClasses(options, and) {                                                                         // 2017\n    options = options || {};                                                                                           // 2018\n    var a = (options.addClass || '').length > 0;                                                                       // 2019\n    var b = (options.removeClass || '').length > 0;                                                                    // 2020\n    return and ? a && b : a || b;                                                                                      // 2021\n  }                                                                                                                    // 2022\n                                                                                                                       // 2023\n  rules.join.push(function(element, newAnimation, currentAnimation) {                                                  // 2024\n    // if the new animation is class-based then we can just tack that on                                               // 2025\n    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);                                      // 2026\n  });                                                                                                                  // 2027\n                                                                                                                       // 2028\n  rules.skip.push(function(element, newAnimation, currentAnimation) {                                                  // 2029\n    // there is no need to animate anything if no classes are being added and                                          // 2030\n    // there is no structural animation that will be triggered                                                         // 2031\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);                                     // 2032\n  });                                                                                                                  // 2033\n                                                                                                                       // 2034\n  rules.skip.push(function(element, newAnimation, currentAnimation) {                                                  // 2035\n    // why should we trigger a new structural animation if the element will                                            // 2036\n    // be removed from the DOM anyway?                                                                                 // 2037\n    return currentAnimation.event == 'leave' && newAnimation.structural;                                               // 2038\n  });                                                                                                                  // 2039\n                                                                                                                       // 2040\n  rules.skip.push(function(element, newAnimation, currentAnimation) {                                                  // 2041\n    // if there is an ongoing current animation then don't even bother running the class-based animation               // 2042\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;        // 2043\n  });                                                                                                                  // 2044\n                                                                                                                       // 2045\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {                                                // 2046\n    // there can never be two structural animations running at the same time                                           // 2047\n    return currentAnimation.structural && newAnimation.structural;                                                     // 2048\n  });                                                                                                                  // 2049\n                                                                                                                       // 2050\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {                                                // 2051\n    // if the previous animation is already running, but the new animation will                                        // 2052\n    // be triggered, but the new animation is structural                                                               // 2053\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;                                        // 2054\n  });                                                                                                                  // 2055\n                                                                                                                       // 2056\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {                                                // 2057\n    var nO = newAnimation.options;                                                                                     // 2058\n    var cO = currentAnimation.options;                                                                                 // 2059\n                                                                                                                       // 2060\n    // if the exact same CSS class is added/removed then it's safe to cancel it                                        // 2061\n    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);      // 2062\n  });                                                                                                                  // 2063\n                                                                                                                       // 2064\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',                                        // 2065\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',                      // 2066\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,                                         // 2067\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {                     // 2068\n                                                                                                                       // 2069\n    var activeAnimationsLookup = new $$HashMap();                                                                      // 2070\n    var disabledElementsLookup = new $$HashMap();                                                                      // 2071\n    var animationsEnabled = null;                                                                                      // 2072\n                                                                                                                       // 2073\n    function postDigestTaskFactory() {                                                                                 // 2074\n      var postDigestCalled = false;                                                                                    // 2075\n      return function(fn) {                                                                                            // 2076\n        // we only issue a call to postDigest before                                                                   // 2077\n        // it has first passed. This prevents any callbacks                                                            // 2078\n        // from not firing once the animation has completed                                                            // 2079\n        // since it will be out of the digest cycle.                                                                   // 2080\n        if (postDigestCalled) {                                                                                        // 2081\n          fn();                                                                                                        // 2082\n        } else {                                                                                                       // 2083\n          $rootScope.$$postDigest(function() {                                                                         // 2084\n            postDigestCalled = true;                                                                                   // 2085\n            fn();                                                                                                      // 2086\n          });                                                                                                          // 2087\n        }                                                                                                              // 2088\n      };                                                                                                               // 2089\n    }                                                                                                                  // 2090\n                                                                                                                       // 2091\n    // Wait until all directive and route-related templates are downloaded and                                         // 2092\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of                                     // 2093\n    // all of the remote templates being currently downloaded. If there are no                                         // 2094\n    // templates currently downloading then the watcher will still fire anyway.                                        // 2095\n    var deregisterWatch = $rootScope.$watch(                                                                           // 2096\n      function() { return $templateRequest.totalPendingRequests === 0; },                                              // 2097\n      function(isEmpty) {                                                                                              // 2098\n        if (!isEmpty) return;                                                                                          // 2099\n        deregisterWatch();                                                                                             // 2100\n                                                                                                                       // 2101\n        // Now that all templates have been downloaded, $animate will wait until                                       // 2102\n        // the post digest queue is empty before enabling animations. By having two                                    // 2103\n        // calls to $postDigest calls we can ensure that the flag is enabled at the                                    // 2104\n        // very end of the post digest queue. Since all of the animations in $animate                                  // 2105\n        // use $postDigest, it's important that the code below executes at the end.                                    // 2106\n        // This basically means that the page is fully downloaded and compiled before                                  // 2107\n        // any animations are triggered.                                                                               // 2108\n        $rootScope.$$postDigest(function() {                                                                           // 2109\n          $rootScope.$$postDigest(function() {                                                                         // 2110\n            // we check for null directly in the event that the application already called                             // 2111\n            // .enabled() with whatever arguments that it provided it with                                             // 2112\n            if (animationsEnabled === null) {                                                                          // 2113\n              animationsEnabled = true;                                                                                // 2114\n            }                                                                                                          // 2115\n          });                                                                                                          // 2116\n        });                                                                                                            // 2117\n      }                                                                                                                // 2118\n    );                                                                                                                 // 2119\n                                                                                                                       // 2120\n    var callbackRegistry = {};                                                                                         // 2121\n                                                                                                                       // 2122\n    // remember that the classNameFilter is set during the provider/config                                             // 2123\n    // stage therefore we can optimize here and setup a helper function                                                // 2124\n    var classNameFilter = $animateProvider.classNameFilter();                                                          // 2125\n    var isAnimatableClassName = !classNameFilter                                                                       // 2126\n              ? function() { return true; }                                                                            // 2127\n              : function(className) {                                                                                  // 2128\n                return classNameFilter.test(className);                                                                // 2129\n              };                                                                                                       // 2130\n                                                                                                                       // 2131\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);                                                // 2132\n                                                                                                                       // 2133\n    function normalizeAnimationOptions(element, options) {                                                             // 2134\n      return mergeAnimationOptions(element, options, {});                                                              // 2135\n    }                                                                                                                  // 2136\n                                                                                                                       // 2137\n    function findCallbacks(parent, element, event) {                                                                   // 2138\n      var targetNode = getDomNode(element);                                                                            // 2139\n      var targetParentNode = getDomNode(parent);                                                                       // 2140\n                                                                                                                       // 2141\n      var matches = [];                                                                                                // 2142\n      var entries = callbackRegistry[event];                                                                           // 2143\n      if (entries) {                                                                                                   // 2144\n        forEach(entries, function(entry) {                                                                             // 2145\n          if (entry.node.contains(targetNode)) {                                                                       // 2146\n            matches.push(entry.callback);                                                                              // 2147\n          } else if (event === 'leave' && entry.node.contains(targetParentNode)) {                                     // 2148\n            matches.push(entry.callback);                                                                              // 2149\n          }                                                                                                            // 2150\n        });                                                                                                            // 2151\n      }                                                                                                                // 2152\n                                                                                                                       // 2153\n      return matches;                                                                                                  // 2154\n    }                                                                                                                  // 2155\n                                                                                                                       // 2156\n    return {                                                                                                           // 2157\n      on: function(event, container, callback) {                                                                       // 2158\n        var node = extractElementNode(container);                                                                      // 2159\n        callbackRegistry[event] = callbackRegistry[event] || [];                                                       // 2160\n        callbackRegistry[event].push({                                                                                 // 2161\n          node: node,                                                                                                  // 2162\n          callback: callback                                                                                           // 2163\n        });                                                                                                            // 2164\n      },                                                                                                               // 2165\n                                                                                                                       // 2166\n      off: function(event, container, callback) {                                                                      // 2167\n        var entries = callbackRegistry[event];                                                                         // 2168\n        if (!entries) return;                                                                                          // 2169\n                                                                                                                       // 2170\n        callbackRegistry[event] = arguments.length === 1                                                               // 2171\n            ? null                                                                                                     // 2172\n            : filterFromRegistry(entries, container, callback);                                                        // 2173\n                                                                                                                       // 2174\n        function filterFromRegistry(list, matchContainer, matchCallback) {                                             // 2175\n          var containerNode = extractElementNode(matchContainer);                                                      // 2176\n          return list.filter(function(entry) {                                                                         // 2177\n            var isMatch = entry.node === containerNode &&                                                              // 2178\n                            (!matchCallback || entry.callback === matchCallback);                                      // 2179\n            return !isMatch;                                                                                           // 2180\n          });                                                                                                          // 2181\n        }                                                                                                              // 2182\n      },                                                                                                               // 2183\n                                                                                                                       // 2184\n      pin: function(element, parentElement) {                                                                          // 2185\n        assertArg(isElement(element), 'element', 'not an element');                                                    // 2186\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');                                        // 2187\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);                                                              // 2188\n      },                                                                                                               // 2189\n                                                                                                                       // 2190\n      push: function(element, event, options, domOperation) {                                                          // 2191\n        options = options || {};                                                                                       // 2192\n        options.domOperation = domOperation;                                                                           // 2193\n        return queueAnimation(element, event, options);                                                                // 2194\n      },                                                                                                               // 2195\n                                                                                                                       // 2196\n      // this method has four signatures:                                                                              // 2197\n      //  () - global getter                                                                                           // 2198\n      //  (bool) - global setter                                                                                       // 2199\n      //  (element) - element getter                                                                                   // 2200\n      //  (element, bool) - element setter<F37>                                                                        // 2201\n      enabled: function(element, bool) {                                                                               // 2202\n        var argCount = arguments.length;                                                                               // 2203\n                                                                                                                       // 2204\n        if (argCount === 0) {                                                                                          // 2205\n          // () - Global getter                                                                                        // 2206\n          bool = !!animationsEnabled;                                                                                  // 2207\n        } else {                                                                                                       // 2208\n          var hasElement = isElement(element);                                                                         // 2209\n                                                                                                                       // 2210\n          if (!hasElement) {                                                                                           // 2211\n            // (bool) - Global setter                                                                                  // 2212\n            bool = animationsEnabled = !!element;                                                                      // 2213\n          } else {                                                                                                     // 2214\n            var node = getDomNode(element);                                                                            // 2215\n            var recordExists = disabledElementsLookup.get(node);                                                       // 2216\n                                                                                                                       // 2217\n            if (argCount === 1) {                                                                                      // 2218\n              // (element) - Element getter                                                                            // 2219\n              bool = !recordExists;                                                                                    // 2220\n            } else {                                                                                                   // 2221\n              // (element, bool) - Element setter                                                                      // 2222\n              bool = !!bool;                                                                                           // 2223\n              if (!bool) {                                                                                             // 2224\n                disabledElementsLookup.put(node, true);                                                                // 2225\n              } else if (recordExists) {                                                                               // 2226\n                disabledElementsLookup.remove(node);                                                                   // 2227\n              }                                                                                                        // 2228\n            }                                                                                                          // 2229\n          }                                                                                                            // 2230\n        }                                                                                                              // 2231\n                                                                                                                       // 2232\n        return bool;                                                                                                   // 2233\n      }                                                                                                                // 2234\n    };                                                                                                                 // 2235\n                                                                                                                       // 2236\n    function queueAnimation(element, event, options) {                                                                 // 2237\n      var node, parent;                                                                                                // 2238\n      element = stripCommentsFromElement(element);                                                                     // 2239\n      if (element) {                                                                                                   // 2240\n        node = getDomNode(element);                                                                                    // 2241\n        parent = element.parent();                                                                                     // 2242\n      }                                                                                                                // 2243\n                                                                                                                       // 2244\n      options = prepareAnimationOptions(options);                                                                      // 2245\n                                                                                                                       // 2246\n      // we create a fake runner with a working promise.                                                               // 2247\n      // These methods will become available after the digest has passed                                               // 2248\n      var runner = new $$AnimateRunner();                                                                              // 2249\n                                                                                                                       // 2250\n      // this is used to trigger callbacks in postDigest mode                                                          // 2251\n      var runInNextPostDigestOrNow = postDigestTaskFactory();                                                          // 2252\n                                                                                                                       // 2253\n      if (isArray(options.addClass)) {                                                                                 // 2254\n        options.addClass = options.addClass.join(' ');                                                                 // 2255\n      }                                                                                                                // 2256\n                                                                                                                       // 2257\n      if (options.addClass && !isString(options.addClass)) {                                                           // 2258\n        options.addClass = null;                                                                                       // 2259\n      }                                                                                                                // 2260\n                                                                                                                       // 2261\n      if (isArray(options.removeClass)) {                                                                              // 2262\n        options.removeClass = options.removeClass.join(' ');                                                           // 2263\n      }                                                                                                                // 2264\n                                                                                                                       // 2265\n      if (options.removeClass && !isString(options.removeClass)) {                                                     // 2266\n        options.removeClass = null;                                                                                    // 2267\n      }                                                                                                                // 2268\n                                                                                                                       // 2269\n      if (options.from && !isObject(options.from)) {                                                                   // 2270\n        options.from = null;                                                                                           // 2271\n      }                                                                                                                // 2272\n                                                                                                                       // 2273\n      if (options.to && !isObject(options.to)) {                                                                       // 2274\n        options.to = null;                                                                                             // 2275\n      }                                                                                                                // 2276\n                                                                                                                       // 2277\n      // there are situations where a directive issues an animation for                                                // 2278\n      // a jqLite wrapper that contains only comment nodes... If this                                                  // 2279\n      // happens then there is no way we can perform an animation                                                      // 2280\n      if (!node) {                                                                                                     // 2281\n        close();                                                                                                       // 2282\n        return runner;                                                                                                 // 2283\n      }                                                                                                                // 2284\n                                                                                                                       // 2285\n      var className = [node.className, options.addClass, options.removeClass].join(' ');                               // 2286\n      if (!isAnimatableClassName(className)) {                                                                         // 2287\n        close();                                                                                                       // 2288\n        return runner;                                                                                                 // 2289\n      }                                                                                                                // 2290\n                                                                                                                       // 2291\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;                                               // 2292\n                                                                                                                       // 2293\n      // this is a hard disable of all animations for the application or on                                            // 2294\n      // the element itself, therefore  there is no need to continue further                                           // 2295\n      // past this point if not enabled                                                                                // 2296\n      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);                                     // 2297\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};                             // 2298\n      var hasExistingAnimation = !!existingAnimation.state;                                                            // 2299\n                                                                                                                       // 2300\n      // there is no point in traversing the same collection of parent ancestors if a followup                         // 2301\n      // animation will be run on the same element that already did all that checking work                             // 2302\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {                 // 2303\n        skipAnimations = !areAnimationsAllowed(element, parent, event);                                                // 2304\n      }                                                                                                                // 2305\n                                                                                                                       // 2306\n      if (skipAnimations) {                                                                                            // 2307\n        close();                                                                                                       // 2308\n        return runner;                                                                                                 // 2309\n      }                                                                                                                // 2310\n                                                                                                                       // 2311\n      if (isStructural) {                                                                                              // 2312\n        closeChildAnimations(element);                                                                                 // 2313\n      }                                                                                                                // 2314\n                                                                                                                       // 2315\n      var newAnimation = {                                                                                             // 2316\n        structural: isStructural,                                                                                      // 2317\n        element: element,                                                                                              // 2318\n        event: event,                                                                                                  // 2319\n        close: close,                                                                                                  // 2320\n        options: options,                                                                                              // 2321\n        runner: runner                                                                                                 // 2322\n      };                                                                                                               // 2323\n                                                                                                                       // 2324\n      if (hasExistingAnimation) {                                                                                      // 2325\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);                           // 2326\n        if (skipAnimationFlag) {                                                                                       // 2327\n          if (existingAnimation.state === RUNNING_STATE) {                                                             // 2328\n            close();                                                                                                   // 2329\n            return runner;                                                                                             // 2330\n          } else {                                                                                                     // 2331\n            mergeAnimationOptions(element, existingAnimation.options, options);                                        // 2332\n            return existingAnimation.runner;                                                                           // 2333\n          }                                                                                                            // 2334\n        }                                                                                                              // 2335\n                                                                                                                       // 2336\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);                       // 2337\n        if (cancelAnimationFlag) {                                                                                     // 2338\n          if (existingAnimation.state === RUNNING_STATE) {                                                             // 2339\n            // this will end the animation right away and it is safe                                                   // 2340\n            // to do so since the animation is already running and the                                                 // 2341\n            // runner callback code will run in async                                                                  // 2342\n            existingAnimation.runner.end();                                                                            // 2343\n          } else if (existingAnimation.structural) {                                                                   // 2344\n            // this means that the animation is queued into a digest, but                                              // 2345\n            // hasn't started yet. Therefore it is safe to run the close                                               // 2346\n            // method which will call the runner methods in async.                                                     // 2347\n            existingAnimation.close();                                                                                 // 2348\n          } else {                                                                                                     // 2349\n            // this will merge the new animation options into existing animation options                               // 2350\n            mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);                           // 2351\n            return existingAnimation.runner;                                                                           // 2352\n          }                                                                                                            // 2353\n        } else {                                                                                                       // 2354\n          // a joined animation means that this animation will take over the existing one                              // 2355\n          // so an example would involve a leave animation taking over an enter. Then when                             // 2356\n          // the postDigest kicks in the enter will be ignored.                                                        // 2357\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);                         // 2358\n          if (joinAnimationFlag) {                                                                                     // 2359\n            if (existingAnimation.state === RUNNING_STATE) {                                                           // 2360\n              normalizeAnimationOptions(element, options);                                                             // 2361\n            } else {                                                                                                   // 2362\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);                         // 2363\n                                                                                                                       // 2364\n              event = newAnimation.event = existingAnimation.event;                                                    // 2365\n              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);               // 2366\n                                                                                                                       // 2367\n              //we return the same runner since only the option values of this animation will                          // 2368\n              //be fed into the `existingAnimation`.                                                                   // 2369\n              return existingAnimation.runner;                                                                         // 2370\n            }                                                                                                          // 2371\n          }                                                                                                            // 2372\n        }                                                                                                              // 2373\n      } else {                                                                                                         // 2374\n        // normalization in this case means that it removes redundant CSS classes that                                 // 2375\n        // already exist (addClass) or do not exist (removeClass) on the element                                       // 2376\n        normalizeAnimationOptions(element, options);                                                                   // 2377\n      }                                                                                                                // 2378\n                                                                                                                       // 2379\n      // when the options are merged and cleaned up we may end up not having to do                                     // 2380\n      // an animation at all, therefore we should check this before issuing a post                                     // 2381\n      // digest callback. Structural animations will always run no matter what.                                        // 2382\n      var isValidAnimation = newAnimation.structural;                                                                  // 2383\n      if (!isValidAnimation) {                                                                                         // 2384\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present               // 2385\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation.options);                                              // 2387\n      }                                                                                                                // 2388\n                                                                                                                       // 2389\n      if (!isValidAnimation) {                                                                                         // 2390\n        close();                                                                                                       // 2391\n        clearElementAnimationState(element);                                                                           // 2392\n        return runner;                                                                                                 // 2393\n      }                                                                                                                // 2394\n                                                                                                                       // 2395\n      // the counter keeps track of cancelled animations                                                               // 2396\n      var counter = (existingAnimation.counter || 0) + 1;                                                              // 2397\n      newAnimation.counter = counter;                                                                                  // 2398\n                                                                                                                       // 2399\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);                                              // 2400\n                                                                                                                       // 2401\n      $rootScope.$$postDigest(function() {                                                                             // 2402\n        var animationDetails = activeAnimationsLookup.get(node);                                                       // 2403\n        var animationCancelled = !animationDetails;                                                                    // 2404\n        animationDetails = animationDetails || {};                                                                     // 2405\n                                                                                                                       // 2406\n        // if addClass/removeClass is called before something like enter then the                                      // 2407\n        // registered parent element may not be present. The code below will ensure                                    // 2408\n        // that a final value for parent element is obtained                                                           // 2409\n        var parentElement = element.parent() || [];                                                                    // 2410\n                                                                                                                       // 2411\n        // animate/structural/class-based animations all have requirements. Otherwise there                            // 2412\n        // is no point in performing an animation. The parent node must also be set.                                   // 2413\n        var isValidAnimation = parentElement.length > 0                                                                // 2414\n                                && (animationDetails.event === 'animate'                                               // 2415\n                                    || animationDetails.structural                                                     // 2416\n                                    || hasAnimationClasses(animationDetails.options));                                 // 2417\n                                                                                                                       // 2418\n        // this means that the previous animation was cancelled                                                        // 2419\n        // even if the follow-up animation is the same event                                                           // 2420\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {                         // 2421\n          // if another animation did not take over then we need                                                       // 2422\n          // to make sure that the domOperation and options are                                                        // 2423\n          // handled accordingly                                                                                       // 2424\n          if (animationCancelled) {                                                                                    // 2425\n            applyAnimationClasses(element, options);                                                                   // 2426\n            applyAnimationStyles(element, options);                                                                    // 2427\n          }                                                                                                            // 2428\n                                                                                                                       // 2429\n          // if the event changed from something like enter to leave then we do                                        // 2430\n          // it, otherwise if it's the same then the end result will be the same too                                   // 2431\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {                              // 2432\n            options.domOperation();                                                                                    // 2433\n            runner.end();                                                                                              // 2434\n          }                                                                                                            // 2435\n                                                                                                                       // 2436\n          // in the event that the element animation was not cancelled or a follow-up animation                        // 2437\n          // isn't allowed to animate from here then we need to clear the state of the element                         // 2438\n          // so that any future animations won't read the expired animation data.                                      // 2439\n          if (!isValidAnimation) {                                                                                     // 2440\n            clearElementAnimationState(element);                                                                       // 2441\n          }                                                                                                            // 2442\n                                                                                                                       // 2443\n          return;                                                                                                      // 2444\n        }                                                                                                              // 2445\n                                                                                                                       // 2446\n        // this combined multiple class to addClass / removeClass into a setClass event                                // 2447\n        // so long as a structural event did not take over the animation                                               // 2448\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)                    // 2449\n            ? 'setClass'                                                                                               // 2450\n            : animationDetails.event;                                                                                  // 2451\n                                                                                                                       // 2452\n        markElementAnimationState(element, RUNNING_STATE);                                                             // 2453\n        var realRunner = $$animation(element, event, animationDetails.options);                                        // 2454\n                                                                                                                       // 2455\n        realRunner.done(function(status) {                                                                             // 2456\n          close(!status);                                                                                              // 2457\n          var animationDetails = activeAnimationsLookup.get(node);                                                     // 2458\n          if (animationDetails && animationDetails.counter === counter) {                                              // 2459\n            clearElementAnimationState(getDomNode(element));                                                           // 2460\n          }                                                                                                            // 2461\n          notifyProgress(runner, event, 'close', {});                                                                  // 2462\n        });                                                                                                            // 2463\n                                                                                                                       // 2464\n        // this will update the runner's flow-control events based on                                                  // 2465\n        // the `realRunner` object.                                                                                    // 2466\n        runner.setHost(realRunner);                                                                                    // 2467\n        notifyProgress(runner, event, 'start', {});                                                                    // 2468\n      });                                                                                                              // 2469\n                                                                                                                       // 2470\n      return runner;                                                                                                   // 2471\n                                                                                                                       // 2472\n      function notifyProgress(runner, event, phase, data) {                                                            // 2473\n        runInNextPostDigestOrNow(function() {                                                                          // 2474\n          var callbacks = findCallbacks(parent, element, event);                                                       // 2475\n          if (callbacks.length) {                                                                                      // 2476\n            // do not optimize this call here to RAF because                                                           // 2477\n            // we don't know how heavy the callback code here will                                                     // 2478\n            // be and if this code is buffered then this can                                                           // 2479\n            // lead to a performance regression.                                                                       // 2480\n            $$rAF(function() {                                                                                         // 2481\n              forEach(callbacks, function(callback) {                                                                  // 2482\n                callback(element, phase, data);                                                                        // 2483\n              });                                                                                                      // 2484\n            });                                                                                                        // 2485\n          }                                                                                                            // 2486\n        });                                                                                                            // 2487\n        runner.progress(event, phase, data);                                                                           // 2488\n      }                                                                                                                // 2489\n                                                                                                                       // 2490\n      function close(reject) { // jshint ignore:line                                                                   // 2491\n        clearGeneratedClasses(element, options);                                                                       // 2492\n        applyAnimationClasses(element, options);                                                                       // 2493\n        applyAnimationStyles(element, options);                                                                        // 2494\n        options.domOperation();                                                                                        // 2495\n        runner.complete(!reject);                                                                                      // 2496\n      }                                                                                                                // 2497\n    }                                                                                                                  // 2498\n                                                                                                                       // 2499\n    function closeChildAnimations(element) {                                                                           // 2500\n      var node = getDomNode(element);                                                                                  // 2501\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');                                          // 2502\n      forEach(children, function(child) {                                                                              // 2503\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));                                                // 2504\n        var animationDetails = activeAnimationsLookup.get(child);                                                      // 2505\n        switch (state) {                                                                                               // 2506\n          case RUNNING_STATE:                                                                                          // 2507\n            animationDetails.runner.end();                                                                             // 2508\n            /* falls through */                                                                                        // 2509\n          case PRE_DIGEST_STATE:                                                                                       // 2510\n            if (animationDetails) {                                                                                    // 2511\n              activeAnimationsLookup.remove(child);                                                                    // 2512\n            }                                                                                                          // 2513\n            break;                                                                                                     // 2514\n        }                                                                                                              // 2515\n      });                                                                                                              // 2516\n    }                                                                                                                  // 2517\n                                                                                                                       // 2518\n    function clearElementAnimationState(element) {                                                                     // 2519\n      var node = getDomNode(element);                                                                                  // 2520\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);                                                                      // 2521\n      activeAnimationsLookup.remove(node);                                                                             // 2522\n    }                                                                                                                  // 2523\n                                                                                                                       // 2524\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {                                                               // 2525\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);                                                        // 2526\n    }                                                                                                                  // 2527\n                                                                                                                       // 2528\n    function areAnimationsAllowed(element, parentElement, event) {                                                     // 2529\n      var bodyElement = jqLite($document[0].body);                                                                     // 2530\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';             // 2531\n      var rootElementDetected = isMatchingElement(element, $rootElement);                                              // 2532\n      var parentAnimationDetected = false;                                                                             // 2533\n      var animateChildren;                                                                                             // 2534\n                                                                                                                       // 2535\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);                                                              // 2536\n      if (parentHost) {                                                                                                // 2537\n        parentElement = parentHost;                                                                                    // 2538\n      }                                                                                                                // 2539\n                                                                                                                       // 2540\n      while (parentElement && parentElement.length) {                                                                  // 2541\n        if (!rootElementDetected) {                                                                                    // 2542\n          // angular doesn't want to attempt to animate elements outside of the application                            // 2543\n          // therefore we need to ensure that the rootElement is an ancestor of the current element                    // 2544\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);                                        // 2545\n        }                                                                                                              // 2546\n                                                                                                                       // 2547\n        var parentNode = parentElement[0];                                                                             // 2548\n        if (parentNode.nodeType !== ELEMENT_NODE) {                                                                    // 2549\n          // no point in inspecting the #document element                                                              // 2550\n          break;                                                                                                       // 2551\n        }                                                                                                              // 2552\n                                                                                                                       // 2553\n        var details = activeAnimationsLookup.get(parentNode) || {};                                                    // 2554\n        // either an enter, leave or move animation will commence                                                      // 2555\n        // therefore we can't allow any animations to take place                                                       // 2556\n        // but if a parent animation is class-based then that's ok                                                     // 2557\n        if (!parentAnimationDetected) {                                                                                // 2558\n          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);                      // 2559\n        }                                                                                                              // 2560\n                                                                                                                       // 2561\n        if (isUndefined(animateChildren) || animateChildren === true) {                                                // 2562\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);                                                    // 2563\n          if (isDefined(value)) {                                                                                      // 2564\n            animateChildren = value;                                                                                   // 2565\n          }                                                                                                            // 2566\n        }                                                                                                              // 2567\n                                                                                                                       // 2568\n        // there is no need to continue traversing at this point                                                       // 2569\n        if (parentAnimationDetected && animateChildren === false) break;                                               // 2570\n                                                                                                                       // 2571\n        if (!rootElementDetected) {                                                                                    // 2572\n          // angular doesn't want to attempt to animate elements outside of the application                            // 2573\n          // therefore we need to ensure that the rootElement is an ancestor of the current element                    // 2574\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);                                        // 2575\n          if (!rootElementDetected) {                                                                                  // 2576\n            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);                                                      // 2577\n            if (parentHost) {                                                                                          // 2578\n              parentElement = parentHost;                                                                              // 2579\n            }                                                                                                          // 2580\n          }                                                                                                            // 2581\n        }                                                                                                              // 2582\n                                                                                                                       // 2583\n        if (!bodyElementDetected) {                                                                                    // 2584\n          // we also need to ensure that the element is or will be apart of the body element                           // 2585\n          // otherwise it is pointless to even issue an animation to be rendered                                       // 2586\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);                                         // 2587\n        }                                                                                                              // 2588\n                                                                                                                       // 2589\n        parentElement = parentElement.parent();                                                                        // 2590\n      }                                                                                                                // 2591\n                                                                                                                       // 2592\n      var allowAnimation = !parentAnimationDetected || animateChildren;                                                // 2593\n      return allowAnimation && rootElementDetected && bodyElementDetected;                                             // 2594\n    }                                                                                                                  // 2595\n                                                                                                                       // 2596\n    function markElementAnimationState(element, state, details) {                                                      // 2597\n      details = details || {};                                                                                         // 2598\n      details.state = state;                                                                                           // 2599\n                                                                                                                       // 2600\n      var node = getDomNode(element);                                                                                  // 2601\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);                                                                  // 2602\n                                                                                                                       // 2603\n      var oldValue = activeAnimationsLookup.get(node);                                                                 // 2604\n      var newValue = oldValue                                                                                          // 2605\n          ? extend(oldValue, details)                                                                                  // 2606\n          : details;                                                                                                   // 2607\n      activeAnimationsLookup.put(node, newValue);                                                                      // 2608\n    }                                                                                                                  // 2609\n  }];                                                                                                                  // 2610\n}];                                                                                                                    // 2611\n                                                                                                                       // 2612\nvar $$AnimateAsyncRunFactory = ['$$rAF', function($$rAF) {                                                             // 2613\n  var waitQueue = [];                                                                                                  // 2614\n                                                                                                                       // 2615\n  function waitForTick(fn) {                                                                                           // 2616\n    waitQueue.push(fn);                                                                                                // 2617\n    if (waitQueue.length > 1) return;                                                                                  // 2618\n    $$rAF(function() {                                                                                                 // 2619\n      for (var i = 0; i < waitQueue.length; i++) {                                                                     // 2620\n        waitQueue[i]();                                                                                                // 2621\n      }                                                                                                                // 2622\n      waitQueue = [];                                                                                                  // 2623\n    });                                                                                                                // 2624\n  }                                                                                                                    // 2625\n                                                                                                                       // 2626\n  return function() {                                                                                                  // 2627\n    var passed = false;                                                                                                // 2628\n    waitForTick(function() {                                                                                           // 2629\n      passed = true;                                                                                                   // 2630\n    });                                                                                                                // 2631\n    return function(callback) {                                                                                        // 2632\n      passed ? callback() : waitForTick(callback);                                                                     // 2633\n    };                                                                                                                 // 2634\n  };                                                                                                                   // 2635\n}];                                                                                                                    // 2636\n                                                                                                                       // 2637\nvar $$AnimateRunnerFactory = ['$q', '$sniffer', '$$animateAsyncRun',                                                   // 2638\n                      function($q,   $sniffer,   $$animateAsyncRun) {                                                  // 2639\n                                                                                                                       // 2640\n  var INITIAL_STATE = 0;                                                                                               // 2641\n  var DONE_PENDING_STATE = 1;                                                                                          // 2642\n  var DONE_COMPLETE_STATE = 2;                                                                                         // 2643\n                                                                                                                       // 2644\n  AnimateRunner.chain = function(chain, callback) {                                                                    // 2645\n    var index = 0;                                                                                                     // 2646\n                                                                                                                       // 2647\n    next();                                                                                                            // 2648\n    function next() {                                                                                                  // 2649\n      if (index === chain.length) {                                                                                    // 2650\n        callback(true);                                                                                                // 2651\n        return;                                                                                                        // 2652\n      }                                                                                                                // 2653\n                                                                                                                       // 2654\n      chain[index](function(response) {                                                                                // 2655\n        if (response === false) {                                                                                      // 2656\n          callback(false);                                                                                             // 2657\n          return;                                                                                                      // 2658\n        }                                                                                                              // 2659\n        index++;                                                                                                       // 2660\n        next();                                                                                                        // 2661\n      });                                                                                                              // 2662\n    }                                                                                                                  // 2663\n  };                                                                                                                   // 2664\n                                                                                                                       // 2665\n  AnimateRunner.all = function(runners, callback) {                                                                    // 2666\n    var count = 0;                                                                                                     // 2667\n    var status = true;                                                                                                 // 2668\n    forEach(runners, function(runner) {                                                                                // 2669\n      runner.done(onProgress);                                                                                         // 2670\n    });                                                                                                                // 2671\n                                                                                                                       // 2672\n    function onProgress(response) {                                                                                    // 2673\n      status = status && response;                                                                                     // 2674\n      if (++count === runners.length) {                                                                                // 2675\n        callback(status);                                                                                              // 2676\n      }                                                                                                                // 2677\n    }                                                                                                                  // 2678\n  };                                                                                                                   // 2679\n                                                                                                                       // 2680\n  function AnimateRunner(host) {                                                                                       // 2681\n    this.setHost(host);                                                                                                // 2682\n                                                                                                                       // 2683\n    this._doneCallbacks = [];                                                                                          // 2684\n    this._runInAnimationFrame = $$animateAsyncRun();                                                                   // 2685\n    this._state = 0;                                                                                                   // 2686\n  }                                                                                                                    // 2687\n                                                                                                                       // 2688\n  AnimateRunner.prototype = {                                                                                          // 2689\n    setHost: function(host) {                                                                                          // 2690\n      this.host = host || {};                                                                                          // 2691\n    },                                                                                                                 // 2692\n                                                                                                                       // 2693\n    done: function(fn) {                                                                                               // 2694\n      if (this._state === DONE_COMPLETE_STATE) {                                                                       // 2695\n        fn();                                                                                                          // 2696\n      } else {                                                                                                         // 2697\n        this._doneCallbacks.push(fn);                                                                                  // 2698\n      }                                                                                                                // 2699\n    },                                                                                                                 // 2700\n                                                                                                                       // 2701\n    progress: noop,                                                                                                    // 2702\n                                                                                                                       // 2703\n    getPromise: function() {                                                                                           // 2704\n      if (!this.promise) {                                                                                             // 2705\n        var self = this;                                                                                               // 2706\n        this.promise = $q(function(resolve, reject) {                                                                  // 2707\n          self.done(function(status) {                                                                                 // 2708\n            status === false ? reject() : resolve();                                                                   // 2709\n          });                                                                                                          // 2710\n        });                                                                                                            // 2711\n      }                                                                                                                // 2712\n      return this.promise;                                                                                             // 2713\n    },                                                                                                                 // 2714\n                                                                                                                       // 2715\n    then: function(resolveHandler, rejectHandler) {                                                                    // 2716\n      return this.getPromise().then(resolveHandler, rejectHandler);                                                    // 2717\n    },                                                                                                                 // 2718\n                                                                                                                       // 2719\n    'catch': function(handler) {                                                                                       // 2720\n      return this.getPromise()['catch'](handler);                                                                      // 2721\n    },                                                                                                                 // 2722\n                                                                                                                       // 2723\n    'finally': function(handler) {                                                                                     // 2724\n      return this.getPromise()['finally'](handler);                                                                    // 2725\n    },                                                                                                                 // 2726\n                                                                                                                       // 2727\n    pause: function() {                                                                                                // 2728\n      if (this.host.pause) {                                                                                           // 2729\n        this.host.pause();                                                                                             // 2730\n      }                                                                                                                // 2731\n    },                                                                                                                 // 2732\n                                                                                                                       // 2733\n    resume: function() {                                                                                               // 2734\n      if (this.host.resume) {                                                                                          // 2735\n        this.host.resume();                                                                                            // 2736\n      }                                                                                                                // 2737\n    },                                                                                                                 // 2738\n                                                                                                                       // 2739\n    end: function() {                                                                                                  // 2740\n      if (this.host.end) {                                                                                             // 2741\n        this.host.end();                                                                                               // 2742\n      }                                                                                                                // 2743\n      this._resolve(true);                                                                                             // 2744\n    },                                                                                                                 // 2745\n                                                                                                                       // 2746\n    cancel: function() {                                                                                               // 2747\n      if (this.host.cancel) {                                                                                          // 2748\n        this.host.cancel();                                                                                            // 2749\n      }                                                                                                                // 2750\n      this._resolve(false);                                                                                            // 2751\n    },                                                                                                                 // 2752\n                                                                                                                       // 2753\n    complete: function(response) {                                                                                     // 2754\n      var self = this;                                                                                                 // 2755\n      if (self._state === INITIAL_STATE) {                                                                             // 2756\n        self._state = DONE_PENDING_STATE;                                                                              // 2757\n        self._runInAnimationFrame(function() {                                                                         // 2758\n          self._resolve(response);                                                                                     // 2759\n        });                                                                                                            // 2760\n      }                                                                                                                // 2761\n    },                                                                                                                 // 2762\n                                                                                                                       // 2763\n    _resolve: function(response) {                                                                                     // 2764\n      if (this._state !== DONE_COMPLETE_STATE) {                                                                       // 2765\n        forEach(this._doneCallbacks, function(fn) {                                                                    // 2766\n          fn(response);                                                                                                // 2767\n        });                                                                                                            // 2768\n        this._doneCallbacks.length = 0;                                                                                // 2769\n        this._state = DONE_COMPLETE_STATE;                                                                             // 2770\n      }                                                                                                                // 2771\n    }                                                                                                                  // 2772\n  };                                                                                                                   // 2773\n                                                                                                                       // 2774\n  return AnimateRunner;                                                                                                // 2775\n}];                                                                                                                    // 2776\n                                                                                                                       // 2777\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {                                            // 2778\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';                                                                          // 2779\n                                                                                                                       // 2780\n  var drivers = this.drivers = [];                                                                                     // 2781\n                                                                                                                       // 2782\n  var RUNNER_STORAGE_KEY = '$$animationRunner';                                                                        // 2783\n                                                                                                                       // 2784\n  function setRunner(element, runner) {                                                                                // 2785\n    element.data(RUNNER_STORAGE_KEY, runner);                                                                          // 2786\n  }                                                                                                                    // 2787\n                                                                                                                       // 2788\n  function removeRunner(element) {                                                                                     // 2789\n    element.removeData(RUNNER_STORAGE_KEY);                                                                            // 2790\n  }                                                                                                                    // 2791\n                                                                                                                       // 2792\n  function getRunner(element) {                                                                                        // 2793\n    return element.data(RUNNER_STORAGE_KEY);                                                                           // 2794\n  }                                                                                                                    // 2795\n                                                                                                                       // 2796\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',                // 2797\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {               // 2798\n                                                                                                                       // 2799\n    var animationQueue = [];                                                                                           // 2800\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);                                                // 2801\n                                                                                                                       // 2802\n    function sortAnimations(animations) {                                                                              // 2803\n      var tree = { children: [] };                                                                                     // 2804\n      var i, lookup = new $$HashMap();                                                                                 // 2805\n                                                                                                                       // 2806\n      // this is done first beforehand so that the hashmap                                                             // 2807\n      // is filled with a list of the elements that will be animated                                                   // 2808\n      for (i = 0; i < animations.length; i++) {                                                                        // 2809\n        var animation = animations[i];                                                                                 // 2810\n        lookup.put(animation.domNode, animations[i] = {                                                                // 2811\n          domNode: animation.domNode,                                                                                  // 2812\n          fn: animation.fn,                                                                                            // 2813\n          children: []                                                                                                 // 2814\n        });                                                                                                            // 2815\n      }                                                                                                                // 2816\n                                                                                                                       // 2817\n      for (i = 0; i < animations.length; i++) {                                                                        // 2818\n        processNode(animations[i]);                                                                                    // 2819\n      }                                                                                                                // 2820\n                                                                                                                       // 2821\n      return flatten(tree);                                                                                            // 2822\n                                                                                                                       // 2823\n      function processNode(entry) {                                                                                    // 2824\n        if (entry.processed) return entry;                                                                             // 2825\n        entry.processed = true;                                                                                        // 2826\n                                                                                                                       // 2827\n        var elementNode = entry.domNode;                                                                               // 2828\n        var parentNode = elementNode.parentNode;                                                                       // 2829\n        lookup.put(elementNode, entry);                                                                                // 2830\n                                                                                                                       // 2831\n        var parentEntry;                                                                                               // 2832\n        while (parentNode) {                                                                                           // 2833\n          parentEntry = lookup.get(parentNode);                                                                        // 2834\n          if (parentEntry) {                                                                                           // 2835\n            if (!parentEntry.processed) {                                                                              // 2836\n              parentEntry = processNode(parentEntry);                                                                  // 2837\n            }                                                                                                          // 2838\n            break;                                                                                                     // 2839\n          }                                                                                                            // 2840\n          parentNode = parentNode.parentNode;                                                                          // 2841\n        }                                                                                                              // 2842\n                                                                                                                       // 2843\n        (parentEntry || tree).children.push(entry);                                                                    // 2844\n        return entry;                                                                                                  // 2845\n      }                                                                                                                // 2846\n                                                                                                                       // 2847\n      function flatten(tree) {                                                                                         // 2848\n        var result = [];                                                                                               // 2849\n        var queue = [];                                                                                                // 2850\n        var i;                                                                                                         // 2851\n                                                                                                                       // 2852\n        for (i = 0; i < tree.children.length; i++) {                                                                   // 2853\n          queue.push(tree.children[i]);                                                                                // 2854\n        }                                                                                                              // 2855\n                                                                                                                       // 2856\n        var remainingLevelEntries = queue.length;                                                                      // 2857\n        var nextLevelEntries = 0;                                                                                      // 2858\n        var row = [];                                                                                                  // 2859\n                                                                                                                       // 2860\n        for (i = 0; i < queue.length; i++) {                                                                           // 2861\n          var entry = queue[i];                                                                                        // 2862\n          if (remainingLevelEntries <= 0) {                                                                            // 2863\n            remainingLevelEntries = nextLevelEntries;                                                                  // 2864\n            nextLevelEntries = 0;                                                                                      // 2865\n            result.push(row);                                                                                          // 2866\n            row = [];                                                                                                  // 2867\n          }                                                                                                            // 2868\n          row.push(entry.fn);                                                                                          // 2869\n          entry.children.forEach(function(childEntry) {                                                                // 2870\n            nextLevelEntries++;                                                                                        // 2871\n            queue.push(childEntry);                                                                                    // 2872\n          });                                                                                                          // 2873\n          remainingLevelEntries--;                                                                                     // 2874\n        }                                                                                                              // 2875\n                                                                                                                       // 2876\n        if (row.length) {                                                                                              // 2877\n          result.push(row);                                                                                            // 2878\n        }                                                                                                              // 2879\n                                                                                                                       // 2880\n        return result;                                                                                                 // 2881\n      }                                                                                                                // 2882\n    }                                                                                                                  // 2883\n                                                                                                                       // 2884\n    // TODO(matsko): document the signature in a better way                                                            // 2885\n    return function(element, event, options) {                                                                         // 2886\n      options = prepareAnimationOptions(options);                                                                      // 2887\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;                                               // 2888\n                                                                                                                       // 2889\n      // there is no animation at the current moment, however                                                          // 2890\n      // these runner methods will get later updated with the                                                          // 2891\n      // methods leading into the driver's end/cancel methods                                                          // 2892\n      // for now they just stop the animation from starting                                                            // 2893\n      var runner = new $$AnimateRunner({                                                                               // 2894\n        end: function() { close(); },                                                                                  // 2895\n        cancel: function() { close(true); }                                                                            // 2896\n      });                                                                                                              // 2897\n                                                                                                                       // 2898\n      if (!drivers.length) {                                                                                           // 2899\n        close();                                                                                                       // 2900\n        return runner;                                                                                                 // 2901\n      }                                                                                                                // 2902\n                                                                                                                       // 2903\n      setRunner(element, runner);                                                                                      // 2904\n                                                                                                                       // 2905\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));          // 2906\n      var tempClasses = options.tempClasses;                                                                           // 2907\n      if (tempClasses) {                                                                                               // 2908\n        classes += ' ' + tempClasses;                                                                                  // 2909\n        options.tempClasses = null;                                                                                    // 2910\n      }                                                                                                                // 2911\n                                                                                                                       // 2912\n      animationQueue.push({                                                                                            // 2913\n        // this data is used by the postDigest code and passed into                                                    // 2914\n        // the driver step function                                                                                    // 2915\n        element: element,                                                                                              // 2916\n        classes: classes,                                                                                              // 2917\n        event: event,                                                                                                  // 2918\n        structural: isStructural,                                                                                      // 2919\n        options: options,                                                                                              // 2920\n        beforeStart: beforeStart,                                                                                      // 2921\n        close: close                                                                                                   // 2922\n      });                                                                                                              // 2923\n                                                                                                                       // 2924\n      element.on('$destroy', handleDestroyedElement);                                                                  // 2925\n                                                                                                                       // 2926\n      // we only want there to be one function called within the post digest                                           // 2927\n      // block. This way we can group animations for all the animations that                                           // 2928\n      // were apart of the same postDigest flush call.                                                                 // 2929\n      if (animationQueue.length > 1) return runner;                                                                    // 2930\n                                                                                                                       // 2931\n      $rootScope.$$postDigest(function() {                                                                             // 2932\n        var animations = [];                                                                                           // 2933\n        forEach(animationQueue, function(entry) {                                                                      // 2934\n          // the element was destroyed early on which removed the runner                                               // 2935\n          // form its storage. This means we can't animate this element                                                // 2936\n          // at all and it already has been closed due to destruction.                                                 // 2937\n          if (getRunner(entry.element)) {                                                                              // 2938\n            animations.push(entry);                                                                                    // 2939\n          } else {                                                                                                     // 2940\n            entry.close();                                                                                             // 2941\n          }                                                                                                            // 2942\n        });                                                                                                            // 2943\n                                                                                                                       // 2944\n        // now any future animations will be in another postDigest                                                     // 2945\n        animationQueue.length = 0;                                                                                     // 2946\n                                                                                                                       // 2947\n        var groupedAnimations = groupAnimations(animations);                                                           // 2948\n        var toBeSortedAnimations = [];                                                                                 // 2949\n                                                                                                                       // 2950\n        forEach(groupedAnimations, function(animationEntry) {                                                          // 2951\n          toBeSortedAnimations.push({                                                                                  // 2952\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),           // 2953\n            fn: function triggerAnimationStart() {                                                                     // 2954\n              // it's important that we apply the `ng-animate` CSS class and the                                       // 2955\n              // temporary classes before we do any driver invoking since these                                        // 2956\n              // CSS classes may be required for proper CSS detection.                                                 // 2957\n              animationEntry.beforeStart();                                                                            // 2958\n                                                                                                                       // 2959\n              var startAnimationFn, closeFn = animationEntry.close;                                                    // 2960\n                                                                                                                       // 2961\n              // in the event that the element was removed before the digest runs or                                   // 2962\n              // during the RAF sequencing then we should not trigger the animation.                                   // 2963\n              var targetElement = animationEntry.anchors                                                               // 2964\n                  ? (animationEntry.from.element || animationEntry.to.element)                                         // 2965\n                  : animationEntry.element;                                                                            // 2966\n                                                                                                                       // 2967\n              if (getRunner(targetElement)) {                                                                          // 2968\n                var operation = invokeFirstDriver(animationEntry);                                                     // 2969\n                if (operation) {                                                                                       // 2970\n                  startAnimationFn = operation.start;                                                                  // 2971\n                }                                                                                                      // 2972\n              }                                                                                                        // 2973\n                                                                                                                       // 2974\n              if (!startAnimationFn) {                                                                                 // 2975\n                closeFn();                                                                                             // 2976\n              } else {                                                                                                 // 2977\n                var animationRunner = startAnimationFn();                                                              // 2978\n                animationRunner.done(function(status) {                                                                // 2979\n                  closeFn(!status);                                                                                    // 2980\n                });                                                                                                    // 2981\n                updateAnimationRunners(animationEntry, animationRunner);                                               // 2982\n              }                                                                                                        // 2983\n            }                                                                                                          // 2984\n          });                                                                                                          // 2985\n        });                                                                                                            // 2986\n                                                                                                                       // 2987\n        // we need to sort each of the animations in order of parent to child                                          // 2988\n        // relationships. This ensures that the child classes are applied at the                                       // 2989\n        // right time.                                                                                                 // 2990\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));                                                          // 2991\n      });                                                                                                              // 2992\n                                                                                                                       // 2993\n      return runner;                                                                                                   // 2994\n                                                                                                                       // 2995\n      // TODO(matsko): change to reference nodes                                                                       // 2996\n      function getAnchorNodes(node) {                                                                                  // 2997\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';                                                                // 2998\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)                                                             // 2999\n              ? [node]                                                                                                 // 3000\n              : node.querySelectorAll(SELECTOR);                                                                       // 3001\n        var anchors = [];                                                                                              // 3002\n        forEach(items, function(node) {                                                                                // 3003\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);                                                           // 3004\n          if (attr && attr.length) {                                                                                   // 3005\n            anchors.push(node);                                                                                        // 3006\n          }                                                                                                            // 3007\n        });                                                                                                            // 3008\n        return anchors;                                                                                                // 3009\n      }                                                                                                                // 3010\n                                                                                                                       // 3011\n      function groupAnimations(animations) {                                                                           // 3012\n        var preparedAnimations = [];                                                                                   // 3013\n        var refLookup = {};                                                                                            // 3014\n        forEach(animations, function(animation, index) {                                                               // 3015\n          var element = animation.element;                                                                             // 3016\n          var node = getDomNode(element);                                                                              // 3017\n          var event = animation.event;                                                                                 // 3018\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;                                                     // 3019\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];                                          // 3020\n                                                                                                                       // 3021\n          if (anchorNodes.length) {                                                                                    // 3022\n            var direction = enterOrMove ? 'to' : 'from';                                                               // 3023\n                                                                                                                       // 3024\n            forEach(anchorNodes, function(anchor) {                                                                    // 3025\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);                                                      // 3026\n              refLookup[key] = refLookup[key] || {};                                                                   // 3027\n              refLookup[key][direction] = {                                                                            // 3028\n                animationID: index,                                                                                    // 3029\n                element: jqLite(anchor)                                                                                // 3030\n              };                                                                                                       // 3031\n            });                                                                                                        // 3032\n          } else {                                                                                                     // 3033\n            preparedAnimations.push(animation);                                                                        // 3034\n          }                                                                                                            // 3035\n        });                                                                                                            // 3036\n                                                                                                                       // 3037\n        var usedIndicesLookup = {};                                                                                    // 3038\n        var anchorGroups = {};                                                                                         // 3039\n        forEach(refLookup, function(operations, key) {                                                                 // 3040\n          var from = operations.from;                                                                                  // 3041\n          var to = operations.to;                                                                                      // 3042\n                                                                                                                       // 3043\n          if (!from || !to) {                                                                                          // 3044\n            // only one of these is set therefore we can't have an                                                     // 3045\n            // anchor animation since all three pieces are required                                                    // 3046\n            var index = from ? from.animationID : to.animationID;                                                      // 3047\n            var indexKey = index.toString();                                                                           // 3048\n            if (!usedIndicesLookup[indexKey]) {                                                                        // 3049\n              usedIndicesLookup[indexKey] = true;                                                                      // 3050\n              preparedAnimations.push(animations[index]);                                                              // 3051\n            }                                                                                                          // 3052\n            return;                                                                                                    // 3053\n          }                                                                                                            // 3054\n                                                                                                                       // 3055\n          var fromAnimation = animations[from.animationID];                                                            // 3056\n          var toAnimation = animations[to.animationID];                                                                // 3057\n          var lookupKey = from.animationID.toString();                                                                 // 3058\n          if (!anchorGroups[lookupKey]) {                                                                              // 3059\n            var group = anchorGroups[lookupKey] = {                                                                    // 3060\n              structural: true,                                                                                        // 3061\n              beforeStart: function() {                                                                                // 3062\n                fromAnimation.beforeStart();                                                                           // 3063\n                toAnimation.beforeStart();                                                                             // 3064\n              },                                                                                                       // 3065\n              close: function() {                                                                                      // 3066\n                fromAnimation.close();                                                                                 // 3067\n                toAnimation.close();                                                                                   // 3068\n              },                                                                                                       // 3069\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),                             // 3070\n              from: fromAnimation,                                                                                     // 3071\n              to: toAnimation,                                                                                         // 3072\n              anchors: [] // TODO(matsko): change to reference nodes                                                   // 3073\n            };                                                                                                         // 3074\n                                                                                                                       // 3075\n            // the anchor animations require that the from and to elements both have at least                          // 3076\n            // one shared CSS class which effictively marries the two elements together to use                         // 3077\n            // the same animation driver and to properly sequence the anchor animation.                                // 3078\n            if (group.classes.length) {                                                                                // 3079\n              preparedAnimations.push(group);                                                                          // 3080\n            } else {                                                                                                   // 3081\n              preparedAnimations.push(fromAnimation);                                                                  // 3082\n              preparedAnimations.push(toAnimation);                                                                    // 3083\n            }                                                                                                          // 3084\n          }                                                                                                            // 3085\n                                                                                                                       // 3086\n          anchorGroups[lookupKey].anchors.push({                                                                       // 3087\n            'out': from.element, 'in': to.element                                                                      // 3088\n          });                                                                                                          // 3089\n        });                                                                                                            // 3090\n                                                                                                                       // 3091\n        return preparedAnimations;                                                                                     // 3092\n      }                                                                                                                // 3093\n                                                                                                                       // 3094\n      function cssClassesIntersection(a,b) {                                                                           // 3095\n        a = a.split(' ');                                                                                              // 3096\n        b = b.split(' ');                                                                                              // 3097\n        var matches = [];                                                                                              // 3098\n                                                                                                                       // 3099\n        for (var i = 0; i < a.length; i++) {                                                                           // 3100\n          var aa = a[i];                                                                                               // 3101\n          if (aa.substring(0,3) === 'ng-') continue;                                                                   // 3102\n                                                                                                                       // 3103\n          for (var j = 0; j < b.length; j++) {                                                                         // 3104\n            if (aa === b[j]) {                                                                                         // 3105\n              matches.push(aa);                                                                                        // 3106\n              break;                                                                                                   // 3107\n            }                                                                                                          // 3108\n          }                                                                                                            // 3109\n        }                                                                                                              // 3110\n                                                                                                                       // 3111\n        return matches.join(' ');                                                                                      // 3112\n      }                                                                                                                // 3113\n                                                                                                                       // 3114\n      function invokeFirstDriver(animationDetails) {                                                                   // 3115\n        // we loop in reverse order since the more general drivers (like CSS and JS)                                   // 3116\n        // may attempt more elements, but custom drivers are more particular                                           // 3117\n        for (var i = drivers.length - 1; i >= 0; i--) {                                                                // 3118\n          var driverName = drivers[i];                                                                                 // 3119\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check                                 // 3120\n                                                                                                                       // 3121\n          var factory = $injector.get(driverName);                                                                     // 3122\n          var driver = factory(animationDetails);                                                                      // 3123\n          if (driver) {                                                                                                // 3124\n            return driver;                                                                                             // 3125\n          }                                                                                                            // 3126\n        }                                                                                                              // 3127\n      }                                                                                                                // 3128\n                                                                                                                       // 3129\n      function beforeStart() {                                                                                         // 3130\n        element.addClass(NG_ANIMATE_CLASSNAME);                                                                        // 3131\n        if (tempClasses) {                                                                                             // 3132\n          $$jqLite.addClass(element, tempClasses);                                                                     // 3133\n        }                                                                                                              // 3134\n      }                                                                                                                // 3135\n                                                                                                                       // 3136\n      function updateAnimationRunners(animation, newRunner) {                                                          // 3137\n        if (animation.from && animation.to) {                                                                          // 3138\n          update(animation.from.element);                                                                              // 3139\n          update(animation.to.element);                                                                                // 3140\n        } else {                                                                                                       // 3141\n          update(animation.element);                                                                                   // 3142\n        }                                                                                                              // 3143\n                                                                                                                       // 3144\n        function update(element) {                                                                                     // 3145\n          getRunner(element).setHost(newRunner);                                                                       // 3146\n        }                                                                                                              // 3147\n      }                                                                                                                // 3148\n                                                                                                                       // 3149\n      function handleDestroyedElement() {                                                                              // 3150\n        var runner = getRunner(element);                                                                               // 3151\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {                                           // 3152\n          runner.end();                                                                                                // 3153\n        }                                                                                                              // 3154\n      }                                                                                                                // 3155\n                                                                                                                       // 3156\n      function close(rejected) { // jshint ignore:line                                                                 // 3157\n        element.off('$destroy', handleDestroyedElement);                                                               // 3158\n        removeRunner(element);                                                                                         // 3159\n                                                                                                                       // 3160\n        applyAnimationClasses(element, options);                                                                       // 3161\n        applyAnimationStyles(element, options);                                                                        // 3162\n        options.domOperation();                                                                                        // 3163\n                                                                                                                       // 3164\n        if (tempClasses) {                                                                                             // 3165\n          $$jqLite.removeClass(element, tempClasses);                                                                  // 3166\n        }                                                                                                              // 3167\n                                                                                                                       // 3168\n        element.removeClass(NG_ANIMATE_CLASSNAME);                                                                     // 3169\n        runner.complete(!rejected);                                                                                    // 3170\n      }                                                                                                                // 3171\n    };                                                                                                                 // 3172\n  }];                                                                                                                  // 3173\n}];                                                                                                                    // 3174\n                                                                                                                       // 3175\n/* global angularAnimateModule: true,                                                                                  // 3176\n                                                                                                                       // 3177\n   $$AnimateAsyncRunFactory,                                                                                           // 3178\n   $$rAFSchedulerFactory,                                                                                              // 3179\n   $$AnimateChildrenDirective,                                                                                         // 3180\n   $$AnimateRunnerFactory,                                                                                             // 3181\n   $$AnimateQueueProvider,                                                                                             // 3182\n   $$AnimationProvider,                                                                                                // 3183\n   $AnimateCssProvider,                                                                                                // 3184\n   $$AnimateCssDriverProvider,                                                                                         // 3185\n   $$AnimateJsProvider,                                                                                                // 3186\n   $$AnimateJsDriverProvider,                                                                                          // 3187\n*/                                                                                                                     // 3188\n                                                                                                                       // 3189\n/**                                                                                                                    // 3190\n * @ngdoc module                                                                                                       // 3191\n * @name ngAnimate                                                                                                     // 3192\n * @description                                                                                                        // 3193\n *                                                                                                                     // 3194\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *                                                                                                                     // 3197\n * <div doc-module-components=\"ngAnimate\"></div>                                                                       // 3198\n *                                                                                                                     // 3199\n * # Usage                                                                                                             // 3200\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.                                                           // 3204\n *                                                                                                                     // 3205\n * ## Directive Support                                                                                                // 3206\n * The following directives are \"animation aware\":                                                                     // 3207\n *                                                                                                                     // 3208\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *                                                                                                                     // 3221\n * (More information can be found by visiting each the documentation associated with each directive.)                  // 3222\n *                                                                                                                     // 3223\n * ## CSS-based Animations                                                                                             // 3224\n *                                                                                                                     // 3225\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *                                                                                                                     // 3228\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:                  // 3229\n *                                                                                                                     // 3230\n * ```html                                                                                                             // 3231\n * <div ng-if=\"bool\" class=\"fade\">                                                                                     // 3232\n *    Fade me in out                                                                                                   // 3233\n * </div>                                                                                                              // 3234\n * <button ng-click=\"bool=true\">Fade In!</button>                                                                      // 3235\n * <button ng-click=\"bool=false\">Fade Out!</button>                                                                    // 3236\n * ```                                                                                                                 // 3237\n *                                                                                                                     // 3238\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:                // 3239\n *                                                                                                                     // 3240\n * ```css                                                                                                              // 3241\n * /&#42; The starting CSS styles for the enter animation &#42;/                                                       // 3242\n * .fade.ng-enter {                                                                                                    // 3243\n *   transition:0.5s linear all;                                                                                       // 3244\n *   opacity:0;                                                                                                        // 3245\n * }                                                                                                                   // 3246\n *                                                                                                                     // 3247\n * /&#42; The finishing CSS styles for the enter animation &#42;/                                                      // 3248\n * .fade.ng-enter.ng-enter-active {                                                                                    // 3249\n *   opacity:1;                                                                                                        // 3250\n * }                                                                                                                   // 3251\n * ```                                                                                                                 // 3252\n *                                                                                                                     // 3253\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *                                                                                                                     // 3257\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *                                                                                                                     // 3259\n * ```css                                                                                                              // 3260\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/                                       // 3261\n * .fade.ng-leave {                                                                                                    // 3262\n *   transition:0.5s linear all;                                                                                       // 3263\n *   opacity:1;                                                                                                        // 3264\n * }                                                                                                                   // 3265\n * .fade.ng-leave.ng-leave-active {                                                                                    // 3266\n *   opacity:0;                                                                                                        // 3267\n * }                                                                                                                   // 3268\n * ```                                                                                                                 // 3269\n *                                                                                                                     // 3270\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:      // 3271\n *                                                                                                                     // 3272\n * ```css                                                                                                              // 3273\n * /&#42; there is no need to define anything inside of the destination                                                // 3274\n * CSS class since the keyframe will take charge of the animation &#42;/                                               // 3275\n * .fade.ng-leave {                                                                                                    // 3276\n *   animation: my_fade_animation 0.5s linear;                                                                         // 3277\n *   -webkit-animation: my_fade_animation 0.5s linear;                                                                 // 3278\n * }                                                                                                                   // 3279\n *                                                                                                                     // 3280\n * @keyframes my_fade_animation {                                                                                      // 3281\n *   from { opacity:1; }                                                                                               // 3282\n *   to { opacity:0; }                                                                                                 // 3283\n * }                                                                                                                   // 3284\n *                                                                                                                     // 3285\n * @-webkit-keyframes my_fade_animation {                                                                              // 3286\n *   from { opacity:1; }                                                                                               // 3287\n *   to { opacity:0; }                                                                                                 // 3288\n * }                                                                                                                   // 3289\n * ```                                                                                                                 // 3290\n *                                                                                                                     // 3291\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.         // 3292\n *                                                                                                                     // 3293\n * ### CSS Class-based Animations                                                                                      // 3294\n *                                                                                                                     // 3295\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.                                                                                                        // 3298\n *                                                                                                                     // 3299\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *                                                                                                                     // 3301\n * ```html                                                                                                             // 3302\n * <div ng-show=\"bool\" class=\"fade\">                                                                                   // 3303\n *   Show and hide me                                                                                                  // 3304\n * </div>                                                                                                              // 3305\n * <button ng-click=\"bool=true\">Toggle</button>                                                                        // 3306\n *                                                                                                                     // 3307\n * <style>                                                                                                             // 3308\n * .fade.ng-hide {                                                                                                     // 3309\n *   transition:0.5s linear all;                                                                                       // 3310\n *   opacity:0;                                                                                                        // 3311\n * }                                                                                                                   // 3312\n * </style>                                                                                                            // 3313\n * ```                                                                                                                 // 3314\n *                                                                                                                     // 3315\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.             // 3317\n *                                                                                                                     // 3318\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.                                                                                                    // 3320\n *                                                                                                                     // 3321\n * ```html                                                                                                             // 3322\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">                                                                       // 3323\n *   Highlight this box                                                                                                // 3324\n * </div>                                                                                                              // 3325\n * <button ng-click=\"onOff=!onOff\">Toggle</button>                                                                     // 3326\n *                                                                                                                     // 3327\n * <style>                                                                                                             // 3328\n * .highlight {                                                                                                        // 3329\n *   transition:0.5s linear all;                                                                                       // 3330\n * }                                                                                                                   // 3331\n * .highlight.on-add {                                                                                                 // 3332\n *   background:white;                                                                                                 // 3333\n * }                                                                                                                   // 3334\n * .highlight.on {                                                                                                     // 3335\n *   background:yellow;                                                                                                // 3336\n * }                                                                                                                   // 3337\n * .highlight.on-remove {                                                                                              // 3338\n *   background:black;                                                                                                 // 3339\n * }                                                                                                                   // 3340\n * </style>                                                                                                            // 3341\n * ```                                                                                                                 // 3342\n *                                                                                                                     // 3343\n * We can also make use of CSS keyframes by placing them within the CSS classes.                                       // 3344\n *                                                                                                                     // 3345\n *                                                                                                                     // 3346\n * ### CSS Staggering Animations                                                                                       // 3347\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for      // 3350\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an      // 3351\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).         // 3352\n *                                                                                                                     // 3353\n * ```css                                                                                                              // 3354\n * .my-animation.ng-enter {                                                                                            // 3355\n *   /&#42; standard transition code &#42;/                                                                            // 3356\n *   transition: 1s linear all;                                                                                        // 3357\n *   opacity:0;                                                                                                        // 3358\n * }                                                                                                                   // 3359\n * .my-animation.ng-enter-stagger {                                                                                    // 3360\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/                                // 3361\n *   transition-delay: 0.1s;                                                                                           // 3362\n *                                                                                                                     // 3363\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate                                                 // 3364\n *     to not accidentally inherit a delay property from another CSS class &#42;/                                      // 3365\n *   transition-duration: 0s;                                                                                          // 3366\n * }                                                                                                                   // 3367\n * .my-animation.ng-enter.ng-enter-active {                                                                            // 3368\n *   /&#42; standard transition styles &#42;/                                                                          // 3369\n *   opacity:1;                                                                                                        // 3370\n * }                                                                                                                   // 3371\n * ```                                                                                                                 // 3372\n *                                                                                                                     // 3373\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.   // 3377\n *                                                                                                                     // 3378\n * The following code will issue the **ng-leave-stagger** event on the element provided:                               // 3379\n *                                                                                                                     // 3380\n * ```js                                                                                                               // 3381\n * var kids = parent.children();                                                                                       // 3382\n *                                                                                                                     // 3383\n * $animate.leave(kids[0]); //stagger index=0                                                                          // 3384\n * $animate.leave(kids[1]); //stagger index=1                                                                          // 3385\n * $animate.leave(kids[2]); //stagger index=2                                                                          // 3386\n * $animate.leave(kids[3]); //stagger index=3                                                                          // 3387\n * $animate.leave(kids[4]); //stagger index=4                                                                          // 3388\n *                                                                                                                     // 3389\n * window.requestAnimationFrame(function() {                                                                           // 3390\n *   //stagger has reset itself                                                                                        // 3391\n *   $animate.leave(kids[5]); //stagger index=0                                                                        // 3392\n *   $animate.leave(kids[6]); //stagger index=1                                                                        // 3393\n *                                                                                                                     // 3394\n *   $scope.$digest();                                                                                                 // 3395\n * });                                                                                                                 // 3396\n * ```                                                                                                                 // 3397\n *                                                                                                                     // 3398\n * Stagger animations are currently only supported within CSS-defined animations.                                      // 3399\n *                                                                                                                     // 3400\n * ### The `ng-animate` CSS class                                                                                      // 3401\n *                                                                                                                     // 3402\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *                                                                                                                     // 3405\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.                     // 3406\n *                                                                                                                     // 3407\n * ```css                                                                                                              // 3408\n * .zipper.ng-animate {                                                                                                // 3409\n *   transition:0.5s linear all;                                                                                       // 3410\n * }                                                                                                                   // 3411\n * .zipper.ng-enter {                                                                                                  // 3412\n *   opacity:0;                                                                                                        // 3413\n * }                                                                                                                   // 3414\n * .zipper.ng-enter.ng-enter-active {                                                                                  // 3415\n *   opacity:1;                                                                                                        // 3416\n * }                                                                                                                   // 3417\n * .zipper.ng-leave {                                                                                                  // 3418\n *   opacity:1;                                                                                                        // 3419\n * }                                                                                                                   // 3420\n * .zipper.ng-leave.ng-leave-active {                                                                                  // 3421\n *   opacity:0;                                                                                                        // 3422\n * }                                                                                                                   // 3423\n * ```                                                                                                                 // 3424\n *                                                                                                                     // 3425\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)                                                                     // 3427\n *                                                                                                                     // 3428\n *                                                                                                                     // 3429\n * ## JavaScript-based Animations                                                                                      // 3430\n *                                                                                                                     // 3431\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.                                                 // 3434\n *                                                                                                                     // 3435\n * Let's see an example of a enter/leave animation using `ngRepeat`:                                                   // 3436\n *                                                                                                                     // 3437\n * ```html                                                                                                             // 3438\n * <div ng-repeat=\"item in items\" class=\"slide\">                                                                       // 3439\n *   {{ item }}                                                                                                        // 3440\n * </div>                                                                                                              // 3441\n * ```                                                                                                                 // 3442\n *                                                                                                                     // 3443\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *                                                                                                                     // 3445\n * ```js                                                                                                               // 3446\n * myModule.animation('.slide', [function() {                                                                          // 3447\n *   return {                                                                                                          // 3448\n *     // make note that other events (like addClass/removeClass)                                                      // 3449\n *     // have different function input parameters                                                                     // 3450\n *     enter: function(element, doneFn) {                                                                              // 3451\n *       jQuery(element).fadeIn(1000, doneFn);                                                                         // 3452\n *                                                                                                                     // 3453\n *       // remember to call doneFn so that angular                                                                    // 3454\n *       // knows that the animation has concluded                                                                     // 3455\n *     },                                                                                                              // 3456\n *                                                                                                                     // 3457\n *     move: function(element, doneFn) {                                                                               // 3458\n *       jQuery(element).fadeIn(1000, doneFn);                                                                         // 3459\n *     },                                                                                                              // 3460\n *                                                                                                                     // 3461\n *     leave: function(element, doneFn) {                                                                              // 3462\n *       jQuery(element).fadeOut(1000, doneFn);                                                                        // 3463\n *     }                                                                                                               // 3464\n *   }                                                                                                                 // 3465\n * }]);                                                                                                                // 3466\n * ```                                                                                                                 // 3467\n *                                                                                                                     // 3468\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.                                                                                       // 3470\n *                                                                                                                     // 3471\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:  // 3473\n *                                                                                                                     // 3474\n * ```html                                                                                                             // 3475\n * <div ng-class=\"color\" class=\"colorful\">                                                                             // 3476\n *   this box is moody                                                                                                 // 3477\n * </div>                                                                                                              // 3478\n * <button ng-click=\"color='red'\">Change to red</button>                                                               // 3479\n * <button ng-click=\"color='blue'\">Change to blue</button>                                                             // 3480\n * <button ng-click=\"color='green'\">Change to green</button>                                                           // 3481\n * ```                                                                                                                 // 3482\n *                                                                                                                     // 3483\n * ```js                                                                                                               // 3484\n * myModule.animation('.colorful', [function() {                                                                       // 3485\n *   return {                                                                                                          // 3486\n *     addClass: function(element, className, doneFn) {                                                                // 3487\n *       // do some cool animation and call the doneFn                                                                 // 3488\n *     },                                                                                                              // 3489\n *     removeClass: function(element, className, doneFn) {                                                             // 3490\n *       // do some cool animation and call the doneFn                                                                 // 3491\n *     },                                                                                                              // 3492\n *     setClass: function(element, addedClass, removedClass, doneFn) {                                                 // 3493\n *       // do some cool animation and call the doneFn                                                                 // 3494\n *     }                                                                                                               // 3495\n *   }                                                                                                                 // 3496\n * }]);                                                                                                                // 3497\n * ```                                                                                                                 // 3498\n *                                                                                                                     // 3499\n * ## CSS + JS Animations Together                                                                                     // 3500\n *                                                                                                                     // 3501\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:                                                                                          // 3504\n *                                                                                                                     // 3505\n * ```html                                                                                                             // 3506\n * <div ng-if=\"bool\" class=\"slide\">                                                                                    // 3507\n *   Slide in and out                                                                                                  // 3508\n * </div>                                                                                                              // 3509\n * ```                                                                                                                 // 3510\n *                                                                                                                     // 3511\n * ```js                                                                                                               // 3512\n * myModule.animation('.slide', [function() {                                                                          // 3513\n *   return {                                                                                                          // 3514\n *     enter: function(element, doneFn) {                                                                              // 3515\n *       jQuery(element).slideIn(1000, doneFn);                                                                        // 3516\n *     }                                                                                                               // 3517\n *   }                                                                                                                 // 3518\n * }]);                                                                                                                // 3519\n * ```                                                                                                                 // 3520\n *                                                                                                                     // 3521\n * ```css                                                                                                              // 3522\n * .slide.ng-enter {                                                                                                   // 3523\n *   transition:0.5s linear all;                                                                                       // 3524\n *   transform:translateY(-100px);                                                                                     // 3525\n * }                                                                                                                   // 3526\n * .slide.ng-enter.ng-enter-active {                                                                                   // 3527\n *   transform:translateY(0);                                                                                          // 3528\n * }                                                                                                                   // 3529\n * ```                                                                                                                 // 3530\n *                                                                                                                     // 3531\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:                                                                                    // 3534\n *                                                                                                                     // 3535\n * ```js                                                                                                               // 3536\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {                                                // 3537\n *   return {                                                                                                          // 3538\n *     enter: function(element) {                                                                                      // 3539\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.                                          // 3540\n *       return $animateCss(element, {                                                                                 // 3541\n *         event: 'enter',                                                                                             // 3542\n *         structural: true                                                                                            // 3543\n *       });                                                                                                           // 3544\n *     }                                                                                                               // 3545\n *   }                                                                                                                 // 3546\n * }]);                                                                                                                // 3547\n * ```                                                                                                                 // 3548\n *                                                                                                                     // 3549\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *                                                                                                                     // 3551\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:                                                                                   // 3554\n *                                                                                                                     // 3555\n * ```js                                                                                                               // 3556\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {                                                // 3557\n *   return {                                                                                                          // 3558\n *     enter: function(element) {                                                                                      // 3559\n *       return $animateCss(element, {                                                                                 // 3560\n *         event: 'enter',                                                                                             // 3561\n *         structural: true,                                                                                           // 3562\n *         addClass: 'maroon-setting',                                                                                 // 3563\n *         from: { height:0 },                                                                                         // 3564\n *         to: { height: 200 }                                                                                         // 3565\n *       });                                                                                                           // 3566\n *     }                                                                                                               // 3567\n *   }                                                                                                                 // 3568\n * }]);                                                                                                                // 3569\n * ```                                                                                                                 // 3570\n *                                                                                                                     // 3571\n * Now we can fill in the rest via our transition CSS code:                                                            // 3572\n *                                                                                                                     // 3573\n * ```css                                                                                                              // 3574\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/                                           // 3575\n * .slide.ng-enter { transition:0.5s linear all; }                                                                     // 3576\n *                                                                                                                     // 3577\n * /&#42; this extra CSS class will be absorbed into the transition                                                    // 3578\n * since the $animateCss code is adding the class &#42;/                                                               // 3579\n * .maroon-setting { background:red; }                                                                                 // 3580\n * ```                                                                                                                 // 3581\n *                                                                                                                     // 3582\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *                                                                                                                     // 3584\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.         // 3585\n *                                                                                                                     // 3586\n * ## Animation Anchoring (via `ng-animate-ref`)                                                                       // 3587\n *                                                                                                                     // 3588\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between                          // 3589\n * structural areas of an application (like views) by pairing up elements using an attribute                           // 3590\n * called `ng-animate-ref`.                                                                                            // 3591\n *                                                                                                                     // 3592\n * Let's say for example we have two views that are managed by `ng-view` and we want to show                           // 3593\n * that there is a relationship between two components situated in within these views. By using the                    // 3594\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we                       // 3595\n * can then attach an animation, which is triggered when the view changes.                                             // 3596\n *                                                                                                                     // 3597\n * Say for example we have the following template code:                                                                // 3598\n *                                                                                                                     // 3599\n * ```html                                                                                                             // 3600\n * <!-- index.html -->                                                                                                 // 3601\n * <div ng-view class=\"view-animation\">                                                                                // 3602\n * </div>                                                                                                              // 3603\n *                                                                                                                     // 3604\n * <!-- home.html -->                                                                                                  // 3605\n * <a href=\"#/banner-page\">                                                                                            // 3606\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">                                                   // 3607\n * </a>                                                                                                                // 3608\n *                                                                                                                     // 3609\n * <!-- banner-page.html -->                                                                                           // 3610\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">                                                     // 3611\n * ```                                                                                                                 // 3612\n *                                                                                                                     // 3613\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the                                   // 3614\n * HTML contents to see if there is a match reference between any components in the view                               // 3615\n * that is leaving and the view that is entering. It will scan both the view which is being                            // 3616\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that                               // 3617\n * contain a matching ref value.                                                                                       // 3618\n *                                                                                                                     // 3619\n * The two images match since they share the same ref value. ngAnimate will now create a                               // 3620\n * transport element (which is a clone of the first image element) and it will then attempt                            // 3621\n * to animate to the position of the second image element in the next view. For the animation to                       // 3622\n * work a special CSS class called `ng-anchor` will be added to the transported element.                               // 3623\n *                                                                                                                     // 3624\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then                                      // 3625\n * ngAnimate will handle the entire transition for us as well as the addition and removal of                           // 3626\n * any changes of CSS classes between the elements:                                                                    // 3627\n *                                                                                                                     // 3628\n * ```css                                                                                                              // 3629\n * .banner.ng-anchor {                                                                                                 // 3630\n *   /&#42; this animation will last for 1 second since there are                                                      // 3631\n *          two phases to the animation (an `in` and an `out` phase) &#42;/                                            // 3632\n *   transition:0.5s linear all;                                                                                       // 3633\n * }                                                                                                                   // 3634\n * ```                                                                                                                 // 3635\n *                                                                                                                     // 3636\n * We also **must** include animations for the views that are being entered and removed                                // 3637\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).                         // 3638\n *                                                                                                                     // 3639\n * ```css                                                                                                              // 3640\n * .view-animation.ng-enter, .view-animation.ng-leave {                                                                // 3641\n *   transition:0.5s linear all;                                                                                       // 3642\n *   position:fixed;                                                                                                   // 3643\n *   left:0;                                                                                                           // 3644\n *   top:0;                                                                                                            // 3645\n *   width:100%;                                                                                                       // 3646\n * }                                                                                                                   // 3647\n * .view-animation.ng-enter {                                                                                          // 3648\n *   transform:translateX(100%);                                                                                       // 3649\n * }                                                                                                                   // 3650\n * .view-animation.ng-leave,                                                                                           // 3651\n * .view-animation.ng-enter.ng-enter-active {                                                                          // 3652\n *   transform:translateX(0%);                                                                                         // 3653\n * }                                                                                                                   // 3654\n * .view-animation.ng-leave.ng-leave-active {                                                                          // 3655\n *   transform:translateX(-100%);                                                                                      // 3656\n * }                                                                                                                   // 3657\n * ```                                                                                                                 // 3658\n *                                                                                                                     // 3659\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:          // 3660\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away             // 3661\n * from its origin. Once that animation is over then the `in` stage occurs which animates the                          // 3662\n * element to its destination. The reason why there are two animations is to give enough time                          // 3663\n * for the enter animation on the new element to be ready.                                                             // 3664\n *                                                                                                                     // 3665\n * The example above sets up a transition for both the in and out phases, but we can also target the out or            // 3666\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.                                                          // 3667\n *                                                                                                                     // 3668\n * ```css                                                                                                              // 3669\n * .banner.ng-anchor-out {                                                                                             // 3670\n *   transition: 0.5s linear all;                                                                                      // 3671\n *                                                                                                                     // 3672\n *   /&#42; the scale will be applied during the out animation,                                                        // 3673\n *          but will be animated away when the in animation runs &#42;/                                                // 3674\n *   transform: scale(1.2);                                                                                            // 3675\n * }                                                                                                                   // 3676\n *                                                                                                                     // 3677\n * .banner.ng-anchor-in {                                                                                              // 3678\n *   transition: 1s linear all;                                                                                        // 3679\n * }                                                                                                                   // 3680\n * ```                                                                                                                 // 3681\n *                                                                                                                     // 3682\n *                                                                                                                     // 3683\n *                                                                                                                     // 3684\n *                                                                                                                     // 3685\n * ### Anchoring Demo                                                                                                  // 3686\n *                                                                                                                     // 3687\n  <example module=\"anchoringExample\"                                                                                   // 3688\n           name=\"anchoringExample\"                                                                                     // 3689\n           id=\"anchoringExample\"                                                                                       // 3690\n           deps=\"angular-animate.js;angular-route.js\"                                                                  // 3691\n           animations=\"true\">                                                                                          // 3692\n    <file name=\"index.html\">                                                                                           // 3693\n      <a href=\"#/\">Home</a>                                                                                            // 3694\n      <hr />                                                                                                           // 3695\n      <div class=\"view-container\">                                                                                     // 3696\n        <div ng-view class=\"view\"></div>                                                                               // 3697\n      </div>                                                                                                           // 3698\n    </file>                                                                                                            // 3699\n    <file name=\"script.js\">                                                                                            // 3700\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])                                                     // 3701\n        .config(['$routeProvider', function($routeProvider) {                                                          // 3702\n          $routeProvider.when('/', {                                                                                   // 3703\n            templateUrl: 'home.html',                                                                                  // 3704\n            controller: 'HomeController as home'                                                                       // 3705\n          });                                                                                                          // 3706\n          $routeProvider.when('/profile/:id', {                                                                        // 3707\n            templateUrl: 'profile.html',                                                                               // 3708\n            controller: 'ProfileController as profile'                                                                 // 3709\n          });                                                                                                          // 3710\n        }])                                                                                                            // 3711\n        .run(['$rootScope', function($rootScope) {                                                                     // 3712\n          $rootScope.records = [                                                                                       // 3713\n            { id:1, title: \"Miss Beulah Roob\" },                                                                       // 3714\n            { id:2, title: \"Trent Morissette\" },                                                                       // 3715\n            { id:3, title: \"Miss Ava Pouros\" },                                                                        // 3716\n            { id:4, title: \"Rod Pouros\" },                                                                             // 3717\n            { id:5, title: \"Abdul Rice\" },                                                                             // 3718\n            { id:6, title: \"Laurie Rutherford Sr.\" },                                                                  // 3719\n            { id:7, title: \"Nakia McLaughlin\" },                                                                       // 3720\n            { id:8, title: \"Jordon Blanda DVM\" },                                                                      // 3721\n            { id:9, title: \"Rhoda Hand\" },                                                                             // 3722\n            { id:10, title: \"Alexandrea Sauer\" }                                                                       // 3723\n          ];                                                                                                           // 3724\n        }])                                                                                                            // 3725\n        .controller('HomeController', [function() {                                                                    // 3726\n          //empty                                                                                                      // 3727\n        }])                                                                                                            // 3728\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {           // 3729\n          var index = parseInt($routeParams.id, 10);                                                                   // 3730\n          var record = $rootScope.records[index - 1];                                                                  // 3731\n                                                                                                                       // 3732\n          this.title = record.title;                                                                                   // 3733\n          this.id = record.id;                                                                                         // 3734\n        }]);                                                                                                           // 3735\n    </file>                                                                                                            // 3736\n    <file name=\"home.html\">                                                                                            // 3737\n      <h2>Welcome to the home page</h1>                                                                                // 3738\n      <p>Please click on an element</p>                                                                                // 3739\n      <a class=\"record\"                                                                                                // 3740\n         ng-href=\"#/profile/{{ record.id }}\"                                                                           // 3741\n         ng-animate-ref=\"{{ record.id }}\"                                                                              // 3742\n         ng-repeat=\"record in records\">                                                                                // 3743\n        {{ record.title }}                                                                                             // 3744\n      </a>                                                                                                             // 3745\n    </file>                                                                                                            // 3746\n    <file name=\"profile.html\">                                                                                         // 3747\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">                                                   // 3748\n        {{ profile.title }}                                                                                            // 3749\n      </div>                                                                                                           // 3750\n    </file>                                                                                                            // 3751\n    <file name=\"animations.css\">                                                                                       // 3752\n      .record {                                                                                                        // 3753\n        display:block;                                                                                                 // 3754\n        font-size:20px;                                                                                                // 3755\n      }                                                                                                                // 3756\n      .profile {                                                                                                       // 3757\n        background:black;                                                                                              // 3758\n        color:white;                                                                                                   // 3759\n        font-size:100px;                                                                                               // 3760\n      }                                                                                                                // 3761\n      .view-container {                                                                                                // 3762\n        position:relative;                                                                                             // 3763\n      }                                                                                                                // 3764\n      .view-container > .view.ng-animate {                                                                             // 3765\n        position:absolute;                                                                                             // 3766\n        top:0;                                                                                                         // 3767\n        left:0;                                                                                                        // 3768\n        width:100%;                                                                                                    // 3769\n        min-height:500px;                                                                                              // 3770\n      }                                                                                                                // 3771\n      .view.ng-enter, .view.ng-leave,                                                                                  // 3772\n      .record.ng-anchor {                                                                                              // 3773\n        transition:0.5s linear all;                                                                                    // 3774\n      }                                                                                                                // 3775\n      .view.ng-enter {                                                                                                 // 3776\n        transform:translateX(100%);                                                                                    // 3777\n      }                                                                                                                // 3778\n      .view.ng-enter.ng-enter-active, .view.ng-leave {                                                                 // 3779\n        transform:translateX(0%);                                                                                      // 3780\n      }                                                                                                                // 3781\n      .view.ng-leave.ng-leave-active {                                                                                 // 3782\n        transform:translateX(-100%);                                                                                   // 3783\n      }                                                                                                                // 3784\n      .record.ng-anchor-out {                                                                                          // 3785\n        background:red;                                                                                                // 3786\n      }                                                                                                                // 3787\n    </file>                                                                                                            // 3788\n  </example>                                                                                                           // 3789\n *                                                                                                                     // 3790\n * ### How is the element transported?                                                                                 // 3791\n *                                                                                                                     // 3792\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match    // 3796\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.                                                           // 3800\n *                                                                                                                     // 3801\n * ### How is the morphing handled?                                                                                    // 3802\n *                                                                                                                     // 3803\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out         // 3804\n * what CSS classes differ between the starting element and the destination element. These different CSS classes       // 3805\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided       // 3806\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will         // 3807\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that      // 3808\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since     // 3809\n * the cloned element is placed inside of root element which is likely close to the body element).                     // 3810\n *                                                                                                                     // 3811\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.        // 3812\n *                                                                                                                     // 3813\n *                                                                                                                     // 3814\n * ## Using $animate in your directive code                                                                            // 3815\n *                                                                                                                     // 3816\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes                                    // 3819\n *                                                                                                                     // 3820\n * ```html                                                                                                             // 3821\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>                                                              // 3822\n * ```                                                                                                                 // 3823\n *                                                                                                                     // 3824\n * ```js                                                                                                               // 3825\n * ngModule.directive('greetingBox', ['$animate', function($animate) {                                                 // 3826\n *   return function(scope, element, attrs) {                                                                          // 3827\n *     attrs.$observe('active', function(value) {                                                                      // 3828\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');                               // 3829\n *     });                                                                                                             // 3830\n *   });                                                                                                               // 3831\n * }]);                                                                                                                // 3832\n * ```                                                                                                                 // 3833\n *                                                                                                                     // 3834\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.                                               // 3836\n *                                                                                                                     // 3837\n * ```css                                                                                                              // 3838\n * /&#42; normally we would create a CSS class to reference on the element &#42;/                                      // 3839\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }                                      // 3840\n * ```                                                                                                                 // 3841\n *                                                                                                                     // 3842\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.                                        // 3844\n *                                                                                                                     // 3845\n *                                                                                                                     // 3846\n * ### Preventing Collisions With Third Party Libraries                                                                // 3847\n *                                                                                                                     // 3848\n * Some third-party frameworks place animation duration defaults across many element or className                      // 3849\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which            // 3850\n * is expecting actual animations on these elements and has to wait for their completion.                              // 3851\n *                                                                                                                     // 3852\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:                             // 3853\n *                                                                                                                     // 3854\n * ```css                                                                                                              // 3855\n * /&#42; prefixed with animate- &#42;/                                                                                // 3856\n * .animate-fade-add.animate-fade-add-active {                                                                         // 3857\n *   transition:1s linear all;                                                                                         // 3858\n *   opacity:0;                                                                                                        // 3859\n * }                                                                                                                   // 3860\n * ```                                                                                                                 // 3861\n *                                                                                                                     // 3862\n * You then configure `$animate` to enforce this prefix:                                                               // 3863\n *                                                                                                                     // 3864\n * ```js                                                                                                               // 3865\n * $animateProvider.classNameFilter(/animate-/);                                                                       // 3866\n * ```                                                                                                                 // 3867\n *                                                                                                                     // 3868\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix  // 3869\n * will be evaluated for animation when any DOM changes occur in the application.                                      // 3870\n *                                                                                                                     // 3871\n * ## Callbacks and Promises                                                                                           // 3872\n *                                                                                                                     // 3873\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.                                          // 3876\n *                                                                                                                     // 3877\n * ```js                                                                                                               // 3878\n * // somewhere within the depths of the directive                                                                     // 3879\n * $animate.enter(element, parent).then(function() {                                                                   // 3880\n *   //the animation has completed                                                                                     // 3881\n * });                                                                                                                 // 3882\n * ```                                                                                                                 // 3883\n *                                                                                                                     // 3884\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)                                                                                                           // 3886\n *                                                                                                                     // 3887\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view   // 3889\n * routing controller to hook into that:                                                                               // 3890\n *                                                                                                                     // 3891\n * ```js                                                                                                               // 3892\n * ngModule.controller('HomePageController', ['$animate', function($animate) {                                         // 3893\n *   $animate.on('enter', ngViewElement, function(element) {                                                           // 3894\n *     // the animation for this route has completed                                                                   // 3895\n *   }]);                                                                                                              // 3896\n * }])                                                                                                                 // 3897\n * ```                                                                                                                 // 3898\n *                                                                                                                     // 3899\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */                                                                                                                    // 3901\n                                                                                                                       // 3902\n/**                                                                                                                    // 3903\n * @ngdoc service                                                                                                      // 3904\n * @name $animate                                                                                                      // 3905\n * @kind object                                                                                                        // 3906\n *                                                                                                                     // 3907\n * @description                                                                                                        // 3908\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.                         // 3909\n *                                                                                                                     // 3910\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.                                      // 3911\n */                                                                                                                    // 3912\nangular.module('ngAnimate', [])                                                                                        // 3913\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)                                                          // 3914\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)                                                                    // 3915\n                                                                                                                       // 3916\n  .factory('$$AnimateRunner', $$AnimateRunnerFactory)                                                                  // 3917\n  .factory('$$animateAsyncRun', $$AnimateAsyncRunFactory)                                                              // 3918\n                                                                                                                       // 3919\n  .provider('$$animateQueue', $$AnimateQueueProvider)                                                                  // 3920\n  .provider('$$animation', $$AnimationProvider)                                                                        // 3921\n                                                                                                                       // 3922\n  .provider('$animateCss', $AnimateCssProvider)                                                                        // 3923\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)                                                          // 3924\n                                                                                                                       // 3925\n  .provider('$$animateJs', $$AnimateJsProvider)                                                                        // 3926\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);                                                           // 3927\n                                                                                                                       // 3928\n                                                                                                                       // 3929\n})(window, window.angular);                                                                                            // 3930\n                                                                                                                       // 3931\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['angular:angular-animate'] = {};\n\n})();\n","servePath":"/packages/angular_angular-animate.js","sourceMap":{"version":3,"sources":["/packages/angular_angular-animate/angular-animate.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8H","file":"/packages/angular_angular-animate.js","sourcesContent":["/**\n * @license AngularJS v1.4.8\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n};\n\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return [];\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationOptions(element, target, newOptions) {\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\nvar $$AnimateChildrenDirective = [function() {\n  return function(scope, element, attrs) {\n    var val = attrs.ngAnimateChildren;\n    if (angular.isString(val) && val.length === 0) { //empty attribute\n      element.data(NG_ANIMATE_CHILDREN_DATA, true);\n    } else {\n      attrs.$observe('ngAnimateChildren', function(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      });\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a colapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for zegative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$animate',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $animate) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an interal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, options) {\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$animate.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle = parseFloat(options.delay);\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        var startTime, events = [];\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidently cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intential stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          element.on(events.join(' '), onAnimationProgress);\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          var ev = event.originalEvent || event;\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early */\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n            // we set this flag to ensure that if the transition is paused then, when resumed,\n            // the animation will automatically close itself since transitions cannot be paused.\n            animationCompleted = true;\n            close();\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragement case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coods object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      return {\n        start: function() {\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          var animationClosed = false;\n          var runner = new $$AnimateRunner({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            animationClosed = true;\n            applyOptions();\n            applyAnimationStyles(element, options);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(options, and) {\n    options = options || {};\n    var a = (options.addClass || '').length > 0;\n    var b = (options.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    var nO = newAnimation.options;\n    var cO = currentAnimation.options;\n\n    // if the exact same CSS class is added/removed then it's safe to cancel it\n    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationOptions(element, options) {\n      return mergeAnimationOptions(element, options, {});\n    }\n\n    function findCallbacks(parent, element, event) {\n      var targetNode = getDomNode(element);\n      var targetParentNode = getDomNode(parent);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (entry.node.contains(targetNode)) {\n            matches.push(entry.callback);\n          } else if (event === 'leave' && entry.node.contains(targetParentNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    return {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n      },\n\n      off: function(event, container, callback) {\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n\n        function filterFromRegistry(list, matchContainer, matchCallback) {\n          var containerNode = extractElementNode(matchContainer);\n          return list.filter(function(entry) {\n            var isMatch = entry.node === containerNode &&\n                            (!matchCallback || entry.callback === matchCallback);\n            return !isMatch;\n          });\n        }\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              bool = !!bool;\n              if (!bool) {\n                disabledElementsLookup.put(node, true);\n              } else if (recordExists) {\n                disabledElementsLookup.remove(node);\n              }\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    function queueAnimation(element, event, options) {\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        close();\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationOptions(element, existingAnimation.options, options);\n            return existingAnimation.runner;\n          }\n        }\n\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationOptions(element, options);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationOptions(element, options);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation.options);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails.options));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(parent, element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n            });\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        switch (state) {\n          case RUNNING_STATE:\n            animationDetails.runner.end();\n            /* falls through */\n          case PRE_DIGEST_STATE:\n            if (animationDetails) {\n              activeAnimationsLookup.remove(child);\n            }\n            break;\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      while (parentElement && parentElement.length) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        var parentNode = parentElement[0];\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n          if (!rootElementDetected) {\n            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);\n            if (parentHost) {\n              parentElement = parentHost;\n            }\n          }\n        }\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be apart of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        parentElement = parentElement.parent();\n      }\n\n      var allowAnimation = !parentAnimationDetected || animateChildren;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimateAsyncRunFactory = ['$$rAF', function($$rAF) {\n  var waitQueue = [];\n\n  function waitForTick(fn) {\n    waitQueue.push(fn);\n    if (waitQueue.length > 1) return;\n    $$rAF(function() {\n      for (var i = 0; i < waitQueue.length; i++) {\n        waitQueue[i]();\n      }\n      waitQueue = [];\n    });\n  }\n\n  return function() {\n    var passed = false;\n    waitForTick(function() {\n      passed = true;\n    });\n    return function(callback) {\n      passed ? callback() : waitForTick(callback);\n    };\n  };\n}];\n\nvar $$AnimateRunnerFactory = ['$q', '$sniffer', '$$animateAsyncRun',\n                      function($q,   $sniffer,   $$animateAsyncRun) {\n\n  var INITIAL_STATE = 0;\n  var DONE_PENDING_STATE = 1;\n  var DONE_COMPLETE_STATE = 2;\n\n  AnimateRunner.chain = function(chain, callback) {\n    var index = 0;\n\n    next();\n    function next() {\n      if (index === chain.length) {\n        callback(true);\n        return;\n      }\n\n      chain[index](function(response) {\n        if (response === false) {\n          callback(false);\n          return;\n        }\n        index++;\n        next();\n      });\n    }\n  };\n\n  AnimateRunner.all = function(runners, callback) {\n    var count = 0;\n    var status = true;\n    forEach(runners, function(runner) {\n      runner.done(onProgress);\n    });\n\n    function onProgress(response) {\n      status = status && response;\n      if (++count === runners.length) {\n        callback(status);\n      }\n    }\n  };\n\n  function AnimateRunner(host) {\n    this.setHost(host);\n\n    this._doneCallbacks = [];\n    this._runInAnimationFrame = $$animateAsyncRun();\n    this._state = 0;\n  }\n\n  AnimateRunner.prototype = {\n    setHost: function(host) {\n      this.host = host || {};\n    },\n\n    done: function(fn) {\n      if (this._state === DONE_COMPLETE_STATE) {\n        fn();\n      } else {\n        this._doneCallbacks.push(fn);\n      }\n    },\n\n    progress: noop,\n\n    getPromise: function() {\n      if (!this.promise) {\n        var self = this;\n        this.promise = $q(function(resolve, reject) {\n          self.done(function(status) {\n            status === false ? reject() : resolve();\n          });\n        });\n      }\n      return this.promise;\n    },\n\n    then: function(resolveHandler, rejectHandler) {\n      return this.getPromise().then(resolveHandler, rejectHandler);\n    },\n\n    'catch': function(handler) {\n      return this.getPromise()['catch'](handler);\n    },\n\n    'finally': function(handler) {\n      return this.getPromise()['finally'](handler);\n    },\n\n    pause: function() {\n      if (this.host.pause) {\n        this.host.pause();\n      }\n    },\n\n    resume: function() {\n      if (this.host.resume) {\n        this.host.resume();\n      }\n    },\n\n    end: function() {\n      if (this.host.end) {\n        this.host.end();\n      }\n      this._resolve(true);\n    },\n\n    cancel: function() {\n      if (this.host.cancel) {\n        this.host.cancel();\n      }\n      this._resolve(false);\n    },\n\n    complete: function(response) {\n      var self = this;\n      if (self._state === INITIAL_STATE) {\n        self._state = DONE_PENDING_STATE;\n        self._runInAnimationFrame(function() {\n          self._resolve(response);\n        });\n      }\n    },\n\n    _resolve: function(response) {\n      if (this._state !== DONE_COMPLETE_STATE) {\n        forEach(this._doneCallbacks, function(fn) {\n          fn(response);\n        });\n        this._doneCallbacks.length = 0;\n        this._state = DONE_COMPLETE_STATE;\n      }\n    }\n  };\n\n  return AnimateRunner;\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effictively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check\n\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          getRunner(element).setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/* global angularAnimateModule: true,\n\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateRunnerFactory,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]);\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .factory('$$AnimateRunner', $$AnimateRunnerFactory)\n  .factory('$$animateAsyncRun', $$AnimateAsyncRunFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n"]}}]