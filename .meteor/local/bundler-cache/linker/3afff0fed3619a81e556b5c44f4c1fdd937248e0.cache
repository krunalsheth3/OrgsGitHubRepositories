[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar _ = Package.underscore._;\nvar RoutePolicy = Package.routepolicy.RoutePolicy;\nvar WebApp = Package.webapp.WebApp;\nvar main = Package.webapp.main;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar ServiceConfiguration = Package['service-configuration'].ServiceConfiguration;\nvar Log = Package.logging.Log;\nvar URL = Package.url.URL;\n\n/* Package-scope variables */\nvar OAuth, OAuthTest, Oauth;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                //\n// packages/oauth/oauth_server.js                                                                 //\n//                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                  //\nvar Fiber = Npm.require('fibers');                                                                // 1\nvar url = Npm.require('url');                                                                     // 2\n                                                                                                  // 3\nOAuth = {};                                                                                       // 4\nOAuthTest = {};                                                                                   // 5\n                                                                                                  // 6\nRoutePolicy.declare('/_oauth/', 'network');                                                       // 7\n                                                                                                  // 8\nvar registeredServices = {};                                                                      // 9\n                                                                                                  // 10\n// Internal: Maps from service version to handler function. The                                   // 11\n// 'oauth1' and 'oauth2' packages manipulate this directly to register                            // 12\n// for callbacks.                                                                                 // 13\nOAuth._requestHandlers = {};                                                                      // 14\n                                                                                                  // 15\n                                                                                                  // 16\n// Register a handler for an OAuth service. The handler will be called                            // 17\n// when we get an incoming http request on /_oauth/{serviceName}. This                            // 18\n// handler should use that information to fetch data about the user                               // 19\n// logging in.                                                                                    // 20\n//                                                                                                // 21\n// @param name {String} e.g. \"google\", \"facebook\"                                                 // 22\n// @param version {Number} OAuth version (1 or 2)                                                 // 23\n// @param urls   For OAuth1 only, specify the service's urls                                      // 24\n// @param handleOauthRequest {Function(oauthBinding|query)}                                       // 25\n//   - (For OAuth1 only) oauthBinding {OAuth1Binding} bound to the appropriate provider           // 26\n//   - (For OAuth2 only) query {Object} parameters passed in query string                         // 27\n//   - return value is:                                                                           // 28\n//     - {serviceData:, (optional options:)} where serviceData should end                         // 29\n//       up in the user's services[name] field                                                    // 30\n//     - `null` if the user declined to give permissions                                          // 31\n//                                                                                                // 32\nOAuth.registerService = function (name, version, urls, handleOauthRequest) {                      // 33\n  if (registeredServices[name])                                                                   // 34\n    throw new Error(\"Already registered the \" + name + \" OAuth service\");                         // 35\n                                                                                                  // 36\n  registeredServices[name] = {                                                                    // 37\n    serviceName: name,                                                                            // 38\n    version: version,                                                                             // 39\n    urls: urls,                                                                                   // 40\n    handleOauthRequest: handleOauthRequest                                                        // 41\n  };                                                                                              // 42\n};                                                                                                // 43\n                                                                                                  // 44\n// For test cleanup.                                                                              // 45\nOAuthTest.unregisterService = function (name) {                                                   // 46\n  delete registeredServices[name];                                                                // 47\n};                                                                                                // 48\n                                                                                                  // 49\n                                                                                                  // 50\nOAuth.retrieveCredential = function(credentialToken, credentialSecret) {                          // 51\n  return OAuth._retrievePendingCredential(credentialToken, credentialSecret);                     // 52\n};                                                                                                // 53\n                                                                                                  // 54\n                                                                                                  // 55\n// The state parameter is normally generated on the client using                                  // 56\n// `btoa`, but for tests we need a version that runs on the server.                               // 57\n//                                                                                                // 58\nOAuth._generateState = function (loginStyle, credentialToken, redirectUrl) {                      // 59\n  return new Buffer(JSON.stringify({                                                              // 60\n    loginStyle: loginStyle,                                                                       // 61\n    credentialToken: credentialToken,                                                             // 62\n    redirectUrl: redirectUrl})).toString('base64');                                               // 63\n};                                                                                                // 64\n                                                                                                  // 65\nOAuth._stateFromQuery = function (query) {                                                        // 66\n  var string;                                                                                     // 67\n  try {                                                                                           // 68\n    string = new Buffer(query.state, 'base64').toString('binary');                                // 69\n  } catch (e) {                                                                                   // 70\n    Log.warn('Unable to base64 decode state from OAuth query: ' + query.state);                   // 71\n    throw e;                                                                                      // 72\n  }                                                                                               // 73\n                                                                                                  // 74\n  try {                                                                                           // 75\n    return JSON.parse(string);                                                                    // 76\n  } catch (e) {                                                                                   // 77\n    Log.warn('Unable to parse state from OAuth query: ' + string);                                // 78\n    throw e;                                                                                      // 79\n  }                                                                                               // 80\n};                                                                                                // 81\n                                                                                                  // 82\nOAuth._loginStyleFromQuery = function (query) {                                                   // 83\n  var style;                                                                                      // 84\n  // For backwards-compatibility for older clients, catch any errors                              // 85\n  // that result from parsing the state parameter. If we can't parse it,                          // 86\n  // set login style to popup by default.                                                         // 87\n  try {                                                                                           // 88\n    style = OAuth._stateFromQuery(query).loginStyle;                                              // 89\n  } catch (err) {                                                                                 // 90\n    style = \"popup\";                                                                              // 91\n  }                                                                                               // 92\n  if (style !== \"popup\" && style !== \"redirect\") {                                                // 93\n    throw new Error(\"Unrecognized login style: \" + style);                                        // 94\n  }                                                                                               // 95\n  return style;                                                                                   // 96\n};                                                                                                // 97\n                                                                                                  // 98\nOAuth._credentialTokenFromQuery = function (query) {                                              // 99\n  var state;                                                                                      // 100\n  // For backwards-compatibility for older clients, catch any errors                              // 101\n  // that result from parsing the state parameter. If we can't parse it,                          // 102\n  // assume that the state parameter's value is the credential token, as                          // 103\n  // it used to be for older clients.                                                             // 104\n  try {                                                                                           // 105\n    state = OAuth._stateFromQuery(query);                                                         // 106\n  } catch (err) {                                                                                 // 107\n    return query.state;                                                                           // 108\n  }                                                                                               // 109\n  return state.credentialToken;                                                                   // 110\n};                                                                                                // 111\n                                                                                                  // 112\nOAuth._isCordovaFromQuery = function (query) {                                                    // 113\n  try {                                                                                           // 114\n    return !! OAuth._stateFromQuery(query).isCordova;                                             // 115\n  } catch (err) {                                                                                 // 116\n    // For backwards-compatibility for older clients, catch any errors                            // 117\n    // that result from parsing the state parameter. If we can't parse                            // 118\n    // it, assume that we are not on Cordova, since older Meteor didn't                           // 119\n    // do Cordova.                                                                                // 120\n    return false;                                                                                 // 121\n  }                                                                                               // 122\n};                                                                                                // 123\n                                                                                                  // 124\n// Checks if the `redirectUrl` matches the app host.                                              // 125\n// We export this function so that developers can override this                                   // 126\n// behavior to allow apps from external domains to login using the                                // 127\n// redirect OAuth flow.                                                                           // 128\nOAuth._checkRedirectUrlOrigin = function (redirectUrl) {                                          // 129\n  var appHost = Meteor.absoluteUrl();                                                             // 130\n  var appHostReplacedLocalhost = Meteor.absoluteUrl(undefined, {                                  // 131\n    replaceLocalhost: true                                                                        // 132\n  });                                                                                             // 133\n  return (                                                                                        // 134\n    redirectUrl.substr(0, appHost.length) !== appHost &&                                          // 135\n    redirectUrl.substr(0, appHostReplacedLocalhost.length) !== appHostReplacedLocalhost           // 136\n  );                                                                                              // 137\n};                                                                                                // 138\n                                                                                                  // 139\n                                                                                                  // 140\n// Listen to incoming OAuth http requests                                                         // 141\nWebApp.connectHandlers.use(function(req, res, next) {                                             // 142\n  // Need to create a Fiber since we're using synchronous http calls and nothing                  // 143\n  // else is wrapping this in a fiber automatically                                               // 144\n  Fiber(function () {                                                                             // 145\n    middleware(req, res, next);                                                                   // 146\n  }).run();                                                                                       // 147\n});                                                                                               // 148\n                                                                                                  // 149\nvar middleware = function (req, res, next) {                                                      // 150\n  // Make sure to catch any exceptions because otherwise we'd crash                               // 151\n  // the runner                                                                                   // 152\n  try {                                                                                           // 153\n    var serviceName = oauthServiceName(req);                                                      // 154\n    if (!serviceName) {                                                                           // 155\n      // not an oauth request. pass to next middleware.                                           // 156\n      next();                                                                                     // 157\n      return;                                                                                     // 158\n    }                                                                                             // 159\n                                                                                                  // 160\n    var service = registeredServices[serviceName];                                                // 161\n                                                                                                  // 162\n    // Skip everything if there's no service set by the oauth middleware                          // 163\n    if (!service)                                                                                 // 164\n      throw new Error(\"Unexpected OAuth service \" + serviceName);                                 // 165\n                                                                                                  // 166\n    // Make sure we're configured                                                                 // 167\n    ensureConfigured(serviceName);                                                                // 168\n                                                                                                  // 169\n    var handler = OAuth._requestHandlers[service.version];                                        // 170\n    if (!handler)                                                                                 // 171\n      throw new Error(\"Unexpected OAuth version \" + service.version);                             // 172\n    handler(service, req.query, res);                                                             // 173\n  } catch (err) {                                                                                 // 174\n    // if we got thrown an error, save it off, it will get passed to                              // 175\n    // the appropriate login call (if any) and reported there.                                    // 176\n    //                                                                                            // 177\n    // The other option would be to display it in the popup tab that                              // 178\n    // is still open at this point, ignoring the 'close' or 'redirect'                            // 179\n    // we were passed. But then the developer wouldn't be able to                                 // 180\n    // style the error or react to it in any way.                                                 // 181\n    if (req.query.state && err instanceof Error) {                                                // 182\n      try { // catch any exceptions to avoid crashing runner                                      // 183\n        OAuth._storePendingCredential(OAuth._credentialTokenFromQuery(req.query), err);           // 184\n      } catch (err) {                                                                             // 185\n        // Ignore the error and just give up. If we failed to store the                           // 186\n        // error, then the login will just fail with a generic error.                             // 187\n        Log.warn(\"Error in OAuth Server while storing pending login result.\\n\" +                  // 188\n                 err.stack || err.message);                                                       // 189\n      }                                                                                           // 190\n    }                                                                                             // 191\n                                                                                                  // 192\n    // close the popup. because nobody likes them just hanging                                    // 193\n    // there.  when someone sees this multiple times they might                                   // 194\n    // think to check server logs (we hope?)                                                      // 195\n    // Catch errors because any exception here will crash the runner.                             // 196\n    try {                                                                                         // 197\n      OAuth._endOfLoginResponse(res, {                                                            // 198\n        query: req.query,                                                                         // 199\n        loginStyle: OAuth._loginStyleFromQuery(req.query),                                        // 200\n        error: err                                                                                // 201\n      });                                                                                         // 202\n    } catch (err) {                                                                               // 203\n      Log.warn(\"Error generating end of login response\\n\" +                                       // 204\n               (err && (err.stack || err.message)));                                              // 205\n    }                                                                                             // 206\n  }                                                                                               // 207\n};                                                                                                // 208\n                                                                                                  // 209\nOAuthTest.middleware = middleware;                                                                // 210\n                                                                                                  // 211\n// Handle /_oauth/* paths and extract the service name.                                           // 212\n//                                                                                                // 213\n// @returns {String|null} e.g. \"facebook\", or null if this isn't an                               // 214\n// oauth request                                                                                  // 215\nvar oauthServiceName = function (req) {                                                           // 216\n  // req.url will be \"/_oauth/<service name>\" with an optional \"?close\".                          // 217\n  var i = req.url.indexOf('?');                                                                   // 218\n  var barePath;                                                                                   // 219\n  if (i === -1)                                                                                   // 220\n    barePath = req.url;                                                                           // 221\n  else                                                                                            // 222\n    barePath = req.url.substring(0, i);                                                           // 223\n  var splitPath = barePath.split('/');                                                            // 224\n                                                                                                  // 225\n  // Any non-oauth request will continue down the default                                         // 226\n  // middlewares.                                                                                 // 227\n  if (splitPath[1] !== '_oauth')                                                                  // 228\n    return null;                                                                                  // 229\n                                                                                                  // 230\n  // Find service based on url                                                                    // 231\n  var serviceName = splitPath[2];                                                                 // 232\n  return serviceName;                                                                             // 233\n};                                                                                                // 234\n                                                                                                  // 235\n// Make sure we're configured                                                                     // 236\nvar ensureConfigured = function(serviceName) {                                                    // 237\n  if (!ServiceConfiguration.configurations.findOne({service: serviceName})) {                     // 238\n    throw new ServiceConfiguration.ConfigError();                                                 // 239\n  }                                                                                               // 240\n};                                                                                                // 241\n                                                                                                  // 242\nvar isSafe = function (value) {                                                                   // 243\n  // This matches strings generated by `Random.secret` and                                        // 244\n  // `Random.id`.                                                                                 // 245\n  return typeof value === \"string\" &&                                                             // 246\n    /^[a-zA-Z0-9\\-_]+$/.test(value);                                                              // 247\n};                                                                                                // 248\n                                                                                                  // 249\n// Internal: used by the oauth1 and oauth2 packages                                               // 250\nOAuth._renderOauthResults = function(res, query, credentialSecret) {                              // 251\n  // For tests, we support the `only_credential_secret_for_test`                                  // 252\n  // parameter, which just returns the credential secret without any                              // 253\n  // surrounding HTML. (The test needs to be able to easily grab the                              // 254\n  // secret and use it to log in.)                                                                // 255\n  //                                                                                              // 256\n  // XXX only_credential_secret_for_test could be useful for other                                // 257\n  // things beside tests, like command-line clients. We should give it a                          // 258\n  // real name and serve the credential secret in JSON.                                           // 259\n                                                                                                  // 260\n  if (query.only_credential_secret_for_test) {                                                    // 261\n    res.writeHead(200, {'Content-Type': 'text/html'});                                            // 262\n    res.end(credentialSecret, 'utf-8');                                                           // 263\n  } else {                                                                                        // 264\n    var details = {                                                                               // 265\n      query: query,                                                                               // 266\n      loginStyle: OAuth._loginStyleFromQuery(query)                                               // 267\n    };                                                                                            // 268\n    if (query.error) {                                                                            // 269\n      details.error = query.error;                                                                // 270\n    } else {                                                                                      // 271\n      var token = OAuth._credentialTokenFromQuery(query);                                         // 272\n      var secret = credentialSecret;                                                              // 273\n      if (token && secret &&                                                                      // 274\n          isSafe(token) && isSafe(secret)) {                                                      // 275\n        details.credentials = { token: token, secret: secret};                                    // 276\n      } else {                                                                                    // 277\n        details.error = \"invalid_credential_token_or_secret\";                                     // 278\n      }                                                                                           // 279\n    }                                                                                             // 280\n                                                                                                  // 281\n    OAuth._endOfLoginResponse(res, details);                                                      // 282\n  }                                                                                               // 283\n};                                                                                                // 284\n                                                                                                  // 285\n// This \"template\" (not a real Spacebars template, just an HTML file                              // 286\n// with some ##PLACEHOLDER##s) communicates the credential secret back                            // 287\n// to the main window and then closes the popup.                                                  // 288\nOAuth._endOfPopupResponseTemplate = Assets.getText(                                               // 289\n  \"end_of_popup_response.html\");                                                                  // 290\n                                                                                                  // 291\nOAuth._endOfRedirectResponseTemplate = Assets.getText(                                            // 292\n  \"end_of_redirect_response.html\");                                                               // 293\n                                                                                                  // 294\n// Renders the end of login response template into some HTML and JavaScript                       // 295\n// that closes the popup or redirects at the end of the OAuth flow.                               // 296\n//                                                                                                // 297\n// options are:                                                                                   // 298\n//   - loginStyle (\"popup\" or \"redirect\")                                                         // 299\n//   - setCredentialToken (boolean)                                                               // 300\n//   - credentialToken                                                                            // 301\n//   - credentialSecret                                                                           // 302\n//   - redirectUrl                                                                                // 303\n//   - isCordova (boolean)                                                                        // 304\n//                                                                                                // 305\nvar renderEndOfLoginResponse = function (options) {                                               // 306\n  // It would be nice to use Blaze here, but it's a little tricky                                 // 307\n  // because our mustaches would be inside a <script> tag, and Blaze                              // 308\n  // would treat the <script> tag contents as text (e.g. encode '&' as                            // 309\n  // '&amp;'). So we just do a simple replace.                                                    // 310\n                                                                                                  // 311\n  var escape = function (s) {                                                                     // 312\n    if (s) {                                                                                      // 313\n      return s.replace(/&/g, \"&amp;\").                                                            // 314\n        replace(/</g, \"&lt;\").                                                                    // 315\n        replace(/>/g, \"&gt;\").                                                                    // 316\n        replace(/\\\"/g, \"&quot;\").                                                                 // 317\n        replace(/\\'/g, \"&#x27;\").                                                                 // 318\n        replace(/\\//g, \"&#x2F;\");                                                                 // 319\n    } else {                                                                                      // 320\n      return s;                                                                                   // 321\n    }                                                                                             // 322\n  };                                                                                              // 323\n                                                                                                  // 324\n  // Escape everything just to be safe (we've already checked that some                           // 325\n  // of this data -- the token and secret -- are safe).                                           // 326\n  var config = {                                                                                  // 327\n    setCredentialToken: !! options.setCredentialToken,                                            // 328\n    credentialToken: escape(options.credentialToken),                                             // 329\n    credentialSecret: escape(options.credentialSecret),                                           // 330\n    storagePrefix: escape(OAuth._storageTokenPrefix),                                             // 331\n    redirectUrl: escape(options.redirectUrl),                                                     // 332\n    isCordova: !! options.isCordova                                                               // 333\n  };                                                                                              // 334\n                                                                                                  // 335\n  var template;                                                                                   // 336\n  if (options.loginStyle === 'popup') {                                                           // 337\n    template = OAuth._endOfPopupResponseTemplate;                                                 // 338\n  } else if (options.loginStyle === 'redirect') {                                                 // 339\n    template = OAuth._endOfRedirectResponseTemplate;                                              // 340\n  } else {                                                                                        // 341\n    throw new Error('invalid loginStyle: ' + options.loginStyle);                                 // 342\n  }                                                                                               // 343\n                                                                                                  // 344\n  var result = template.replace(/##CONFIG##/, JSON.stringify(config));                            // 345\n                                                                                                  // 346\n  return \"<!DOCTYPE html>\\n\" + result;                                                            // 347\n};                                                                                                // 348\n                                                                                                  // 349\n// Writes an HTTP response to the popup window at the end of an OAuth                             // 350\n// login flow. At this point, if the user has successfully authenticated                          // 351\n// to the OAuth server and authorized this app, we communicate the                                // 352\n// credentialToken and credentialSecret to the main window. The main                              // 353\n// window must provide both these values to the DDP `login` method to                             // 354\n// authenticate its DDP connection. After communicating these vaues to                            // 355\n// the main window, we close the popup.                                                           // 356\n//                                                                                                // 357\n// We export this function so that developers can override this                                   // 358\n// behavior, which is particularly useful in, for example, some mobile                            // 359\n// environments where popups and/or `window.opener` don't work. For                               // 360\n// example, an app could override `OAuth._endOfPopupResponse` to put the                          // 361\n// credential token and credential secret in the popup URL for the main                           // 362\n// window to read them there instead of using `window.opener`. If you                             // 363\n// override this function, you take responsibility for writing to the                             // 364\n// request and calling `res.end()` to complete the request.                                       // 365\n//                                                                                                // 366\n// Arguments:                                                                                     // 367\n//   - res: the HTTP response object                                                              // 368\n//   - details:                                                                                   // 369\n//      - query: the query string on the HTTP request                                             // 370\n//      - credentials: { token: *, secret: * }. If present, this field                            // 371\n//        indicates that the login was successful. Return these values                            // 372\n//        to the client, who can use them to log in over DDP. If                                  // 373\n//        present, the values have been checked against a limited                                 // 374\n//        character set and are safe to include in HTML.                                          // 375\n//      - error: if present, a string or Error indicating an error that                           // 376\n//        occurred during the login. This can come from the client and                            // 377\n//        so shouldn't be trusted for security decisions or included in                           // 378\n//        the response without sanitizing it first. Only one of `error`                           // 379\n//        or `credentials` should be set.                                                         // 380\nOAuth._endOfLoginResponse = function (res, details) {                                             // 381\n  res.writeHead(200, {'Content-Type': 'text/html'});                                              // 382\n                                                                                                  // 383\n  var redirectUrl;                                                                                // 384\n  if (details.loginStyle === 'redirect') {                                                        // 385\n    redirectUrl = OAuth._stateFromQuery(details.query).redirectUrl;                               // 386\n    var appHost = Meteor.absoluteUrl();                                                           // 387\n    if (OAuth._checkRedirectUrlOrigin(redirectUrl)) {                                             // 388\n      details.error = \"redirectUrl (\" + redirectUrl +                                             // 389\n        \") is not on the same host as the app (\" + appHost + \")\";                                 // 390\n      redirectUrl = appHost;                                                                      // 391\n    }                                                                                             // 392\n  }                                                                                               // 393\n                                                                                                  // 394\n  var isCordova = OAuth._isCordovaFromQuery(details.query);                                       // 395\n                                                                                                  // 396\n  if (details.error) {                                                                            // 397\n    Log.warn(\"Error in OAuth Server: \" +                                                          // 398\n             (details.error instanceof Error ?                                                    // 399\n              details.error.message : details.error));                                            // 400\n    res.end(renderEndOfLoginResponse({                                                            // 401\n      loginStyle: details.loginStyle,                                                             // 402\n      setCredentialToken: false,                                                                  // 403\n      redirectUrl: redirectUrl,                                                                   // 404\n      isCordova: isCordova                                                                        // 405\n    }), \"utf-8\");                                                                                 // 406\n    return;                                                                                       // 407\n  }                                                                                               // 408\n                                                                                                  // 409\n  // If we have a credentialSecret, report it back to the parent                                  // 410\n  // window, with the corresponding credentialToken. The parent window                            // 411\n  // uses the credentialToken and credentialSecret to log in over DDP.                            // 412\n  res.end(renderEndOfLoginResponse({                                                              // 413\n    loginStyle: details.loginStyle,                                                               // 414\n    setCredentialToken: true,                                                                     // 415\n    credentialToken: details.credentials.token,                                                   // 416\n    credentialSecret: details.credentials.secret,                                                 // 417\n    redirectUrl: redirectUrl,                                                                     // 418\n    isCordova: isCordova                                                                          // 419\n  }), \"utf-8\");                                                                                   // 420\n};                                                                                                // 421\n                                                                                                  // 422\n                                                                                                  // 423\nvar OAuthEncryption = Package[\"oauth-encryption\"] && Package[\"oauth-encryption\"].OAuthEncryption;\n                                                                                                  // 425\nvar usingOAuthEncryption = function () {                                                          // 426\n  return OAuthEncryption && OAuthEncryption.keyIsLoaded();                                        // 427\n};                                                                                                // 428\n                                                                                                  // 429\n// Encrypt sensitive service data such as access tokens if the                                    // 430\n// \"oauth-encryption\" package is loaded and the oauth secret key has                              // 431\n// been specified.  Returns the unencrypted plaintext otherwise.                                  // 432\n//                                                                                                // 433\n// The user id is not specified because the user isn't known yet at                               // 434\n// this point in the oauth authentication process.  After the oauth                               // 435\n// authentication process completes the encrypted service data fields                             // 436\n// will be re-encrypted with the user id included before inserting the                            // 437\n// service data into the user document.                                                           // 438\n//                                                                                                // 439\nOAuth.sealSecret = function (plaintext) {                                                         // 440\n  if (usingOAuthEncryption())                                                                     // 441\n    return OAuthEncryption.seal(plaintext);                                                       // 442\n  else                                                                                            // 443\n    return plaintext;                                                                             // 444\n}                                                                                                 // 445\n                                                                                                  // 446\n// Unencrypt a service data field, if the \"oauth-encryption\"                                      // 447\n// package is loaded and the field is encrypted.                                                  // 448\n//                                                                                                // 449\n// Throws an error if the \"oauth-encryption\" package is loaded and the                            // 450\n// field is encrypted, but the oauth secret key hasn't been specified.                            // 451\n//                                                                                                // 452\nOAuth.openSecret = function (maybeSecret, userId) {                                               // 453\n  if (!Package[\"oauth-encryption\"] || !OAuthEncryption.isSealed(maybeSecret))                     // 454\n    return maybeSecret;                                                                           // 455\n                                                                                                  // 456\n  return OAuthEncryption.open(maybeSecret, userId);                                               // 457\n};                                                                                                // 458\n                                                                                                  // 459\n// Unencrypt fields in the service data object.                                                   // 460\n//                                                                                                // 461\nOAuth.openSecrets = function (serviceData, userId) {                                              // 462\n  var result = {};                                                                                // 463\n  _.each(_.keys(serviceData), function (key) {                                                    // 464\n    result[key] = OAuth.openSecret(serviceData[key], userId);                                     // 465\n  });                                                                                             // 466\n  return result;                                                                                  // 467\n};                                                                                                // 468\n                                                                                                  // 469\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                //\n// packages/oauth/pending_credentials.js                                                          //\n//                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                  //\n//                                                                                                // 1\n// When an oauth request is made, Meteor receives oauth credentials                               // 2\n// in one browser tab, and temporarily persists them while that                                   // 3\n// tab is closed, then retrieves them in the browser tab that                                     // 4\n// initiated the credential request.                                                              // 5\n//                                                                                                // 6\n// _pendingCredentials is the storage mechanism used to share the                                 // 7\n// credential between the 2 tabs                                                                  // 8\n//                                                                                                // 9\n                                                                                                  // 10\n                                                                                                  // 11\n// Collection containing pending credentials of oauth credential requests                         // 12\n// Has key, credential, and createdAt fields.                                                     // 13\nOAuth._pendingCredentials = new Mongo.Collection(                                                 // 14\n  \"meteor_oauth_pendingCredentials\", {                                                            // 15\n    _preventAutopublish: true                                                                     // 16\n  });                                                                                             // 17\n                                                                                                  // 18\nOAuth._pendingCredentials._ensureIndex('key', {unique: 1});                                       // 19\nOAuth._pendingCredentials._ensureIndex('credentialSecret');                                       // 20\nOAuth._pendingCredentials._ensureIndex('createdAt');                                              // 21\n                                                                                                  // 22\n                                                                                                  // 23\n                                                                                                  // 24\n// Periodically clear old entries that were never retrieved                                       // 25\nvar _cleanStaleResults = function() {                                                             // 26\n  // Remove credentials older than 1 minute                                                       // 27\n  var timeCutoff = new Date();                                                                    // 28\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 1);                                             // 29\n  OAuth._pendingCredentials.remove({ createdAt: { $lt: timeCutoff } });                           // 30\n};                                                                                                // 31\nvar _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);                           // 32\n                                                                                                  // 33\n                                                                                                  // 34\n// Stores the key and credential in the _pendingCredentials collection.                           // 35\n// Will throw an exception if `key` is not a string.                                              // 36\n//                                                                                                // 37\n// @param key {string}                                                                            // 38\n// @param credential {Object}   The credential to store                                           // 39\n// @param credentialSecret {string} A secret that must be presented in                            // 40\n//   addition to the `key` to retrieve the credential                                             // 41\n//                                                                                                // 42\nOAuth._storePendingCredential = function (key, credential, credentialSecret) {                    // 43\n  check(key, String);                                                                             // 44\n  check(credentialSecret, Match.Optional(String));                                                // 45\n                                                                                                  // 46\n  if (credential instanceof Error) {                                                              // 47\n    credential = storableError(credential);                                                       // 48\n  } else {                                                                                        // 49\n    credential = OAuth.sealSecret(credential);                                                    // 50\n  }                                                                                               // 51\n                                                                                                  // 52\n  // We do an upsert here instead of an insert in case the user happens                           // 53\n  // to somehow send the same `state` parameter twice during an OAuth                             // 54\n  // login; we don't want a duplicate key error.                                                  // 55\n  OAuth._pendingCredentials.upsert({                                                              // 56\n    key: key                                                                                      // 57\n  }, {                                                                                            // 58\n    key: key,                                                                                     // 59\n    credential: credential,                                                                       // 60\n    credentialSecret: credentialSecret || null,                                                   // 61\n    createdAt: new Date()                                                                         // 62\n  });                                                                                             // 63\n};                                                                                                // 64\n                                                                                                  // 65\n                                                                                                  // 66\n// Retrieves and removes a credential from the _pendingCredentials collection                     // 67\n//                                                                                                // 68\n// @param key {string}                                                                            // 69\n// @param credentialSecret {string}                                                               // 70\n//                                                                                                // 71\nOAuth._retrievePendingCredential = function (key, credentialSecret) {                             // 72\n  check(key, String);                                                                             // 73\n                                                                                                  // 74\n  var pendingCredential = OAuth._pendingCredentials.findOne({                                     // 75\n    key: key,                                                                                     // 76\n    credentialSecret: credentialSecret || null                                                    // 77\n  });                                                                                             // 78\n  if (pendingCredential) {                                                                        // 79\n    OAuth._pendingCredentials.remove({ _id: pendingCredential._id });                             // 80\n    if (pendingCredential.credential.error)                                                       // 81\n      return recreateError(pendingCredential.credential.error);                                   // 82\n    else                                                                                          // 83\n      return OAuth.openSecret(pendingCredential.credential);                                      // 84\n  } else {                                                                                        // 85\n    return undefined;                                                                             // 86\n  }                                                                                               // 87\n};                                                                                                // 88\n                                                                                                  // 89\n                                                                                                  // 90\n// Convert an Error into an object that can be stored in mongo                                    // 91\n// Note: A Meteor.Error is reconstructed as a Meteor.Error                                        // 92\n// All other error classes are reconstructed as a plain Error.                                    // 93\nvar storableError = function(error) {                                                             // 94\n  var plainObject = {};                                                                           // 95\n  Object.getOwnPropertyNames(error).forEach(function(key) {                                       // 96\n    plainObject[key] = error[key];                                                                // 97\n  });                                                                                             // 98\n                                                                                                  // 99\n  // Keep track of whether it's a Meteor.Error                                                    // 100\n  if(error instanceof Meteor.Error) {                                                             // 101\n    plainObject['meteorError'] = true;                                                            // 102\n  }                                                                                               // 103\n                                                                                                  // 104\n  return { error: plainObject };                                                                  // 105\n};                                                                                                // 106\n                                                                                                  // 107\n// Create an error from the error format stored in mongo                                          // 108\nvar recreateError = function(errorDoc) {                                                          // 109\n  var error;                                                                                      // 110\n                                                                                                  // 111\n  if (errorDoc.meteorError) {                                                                     // 112\n    error = new Meteor.Error();                                                                   // 113\n    delete errorDoc.meteorError;                                                                  // 114\n  } else {                                                                                        // 115\n    error = new Error();                                                                          // 116\n  }                                                                                               // 117\n                                                                                                  // 118\n  Object.getOwnPropertyNames(errorDoc).forEach(function(key) {                                    // 119\n    error[key] = errorDoc[key];                                                                   // 120\n  });                                                                                             // 121\n                                                                                                  // 122\n  return error;                                                                                   // 123\n};                                                                                                // 124\n                                                                                                  // 125\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                //\n// packages/oauth/oauth_common.js                                                                 //\n//                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                  //\nOAuth._storageTokenPrefix = \"Meteor.oauth.credentialSecret-\";                                     // 1\n                                                                                                  // 2\nOAuth._redirectUri = function (serviceName, config, params, absoluteUrlOptions) {                 // 3\n  // XXX COMPAT WITH 0.9.0                                                                        // 4\n  // The redirect URI used to have a \"?close\" query argument.  We                                 // 5\n  // detect whether we need to be backwards compatible by checking for                            // 6\n  // the absence of the `loginStyle` field, which wasn't used in the                              // 7\n  // code which had the \"?close\" argument.                                                        // 8\n  // This logic is duplicated in the tool so that the tool can do OAuth                           // 9\n  // flow with <= 0.9.0 servers (tools/auth.js).                                                  // 10\n  var query = config.loginStyle ? null : \"close\";                                                 // 11\n                                                                                                  // 12\n  // Clone because we're going to mutate 'params'. The 'cordova' and                              // 13\n  // 'android' parameters are only used for picking the host of the                               // 14\n  // redirect URL, and not actually included in the redirect URL itself.                          // 15\n  var isCordova = false;                                                                          // 16\n  var isAndroid = false;                                                                          // 17\n  if (params) {                                                                                   // 18\n    params = _.clone(params);                                                                     // 19\n    isCordova = params.cordova;                                                                   // 20\n    isAndroid = params.android;                                                                   // 21\n    delete params.cordova;                                                                        // 22\n    delete params.android;                                                                        // 23\n    if (_.isEmpty(params)) {                                                                      // 24\n      params = undefined;                                                                         // 25\n    }                                                                                             // 26\n  }                                                                                               // 27\n                                                                                                  // 28\n  if (Meteor.isServer && isCordova) {                                                             // 29\n    var rootUrl = process.env.MOBILE_ROOT_URL ||                                                  // 30\n          __meteor_runtime_config__.ROOT_URL;                                                     // 31\n                                                                                                  // 32\n    if (isAndroid) {                                                                              // 33\n      // Match the replace that we do in cordova boilerplate                                      // 34\n      // (boilerplate-generator package).                                                         // 35\n      // XXX Maybe we should put this in a separate package or something                          // 36\n      // that is used here and by boilerplate-generator? Or maybe                                 // 37\n      // `Meteor.absoluteUrl` should know how to do this?                                         // 38\n      var url = Npm.require(\"url\");                                                               // 39\n      var parsedRootUrl = url.parse(rootUrl);                                                     // 40\n      if (parsedRootUrl.hostname === \"localhost\") {                                               // 41\n        parsedRootUrl.hostname = \"10.0.2.2\";                                                      // 42\n        delete parsedRootUrl.host;                                                                // 43\n      }                                                                                           // 44\n      rootUrl = url.format(parsedRootUrl);                                                        // 45\n    }                                                                                             // 46\n                                                                                                  // 47\n    absoluteUrlOptions = _.extend({}, absoluteUrlOptions, {                                       // 48\n      // For Cordova clients, redirect to the special Cordova root url                            // 49\n      // (likely a local IP in development mode).                                                 // 50\n      rootUrl: rootUrl                                                                            // 51\n    });                                                                                           // 52\n  }                                                                                               // 53\n                                                                                                  // 54\n  return URL._constructUrl(                                                                       // 55\n    Meteor.absoluteUrl('_oauth/' + serviceName, absoluteUrlOptions),                              // 56\n    query,                                                                                        // 57\n    params);                                                                                      // 58\n};                                                                                                // 59\n                                                                                                  // 60\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                //\n// packages/oauth/deprecated.js                                                                   //\n//                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                  //\n// XXX COMPAT WITH 0.8.0                                                                          // 1\n                                                                                                  // 2\nOauth = OAuth;                                                                                    // 3\n                                                                                                  // 4\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.oauth = {\n  OAuth: OAuth,\n  OAuthTest: OAuthTest,\n  Oauth: Oauth\n};\n\n})();\n","servePath":"/packages/oauth.js","sourceMap":{"version":3,"sources":["/packages/oauth/oauth_server.js","/packages/oauth/pending_credentials.js","/packages/oauth/oauth_common.js","/packages/oauth/deprecated.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wG;;;;;;;;;;;;;;;;;;ACpdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wG;;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uG;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA,sG","file":"/packages/oauth.js","sourcesContent":["var Fiber = Npm.require('fibers');\nvar url = Npm.require('url');\n\nOAuth = {};\nOAuthTest = {};\n\nRoutePolicy.declare('/_oauth/', 'network');\n\nvar registeredServices = {};\n\n// Internal: Maps from service version to handler function. The\n// 'oauth1' and 'oauth2' packages manipulate this directly to register\n// for callbacks.\nOAuth._requestHandlers = {};\n\n\n// Register a handler for an OAuth service. The handler will be called\n// when we get an incoming http request on /_oauth/{serviceName}. This\n// handler should use that information to fetch data about the user\n// logging in.\n//\n// @param name {String} e.g. \"google\", \"facebook\"\n// @param version {Number} OAuth version (1 or 2)\n// @param urls   For OAuth1 only, specify the service's urls\n// @param handleOauthRequest {Function(oauthBinding|query)}\n//   - (For OAuth1 only) oauthBinding {OAuth1Binding} bound to the appropriate provider\n//   - (For OAuth2 only) query {Object} parameters passed in query string\n//   - return value is:\n//     - {serviceData:, (optional options:)} where serviceData should end\n//       up in the user's services[name] field\n//     - `null` if the user declined to give permissions\n//\nOAuth.registerService = function (name, version, urls, handleOauthRequest) {\n  if (registeredServices[name])\n    throw new Error(\"Already registered the \" + name + \" OAuth service\");\n\n  registeredServices[name] = {\n    serviceName: name,\n    version: version,\n    urls: urls,\n    handleOauthRequest: handleOauthRequest\n  };\n};\n\n// For test cleanup.\nOAuthTest.unregisterService = function (name) {\n  delete registeredServices[name];\n};\n\n\nOAuth.retrieveCredential = function(credentialToken, credentialSecret) {\n  return OAuth._retrievePendingCredential(credentialToken, credentialSecret);\n};\n\n\n// The state parameter is normally generated on the client using\n// `btoa`, but for tests we need a version that runs on the server.\n//\nOAuth._generateState = function (loginStyle, credentialToken, redirectUrl) {\n  return new Buffer(JSON.stringify({\n    loginStyle: loginStyle,\n    credentialToken: credentialToken,\n    redirectUrl: redirectUrl})).toString('base64');\n};\n\nOAuth._stateFromQuery = function (query) {\n  var string;\n  try {\n    string = new Buffer(query.state, 'base64').toString('binary');\n  } catch (e) {\n    Log.warn('Unable to base64 decode state from OAuth query: ' + query.state);\n    throw e;\n  }\n\n  try {\n    return JSON.parse(string);\n  } catch (e) {\n    Log.warn('Unable to parse state from OAuth query: ' + string);\n    throw e;\n  }\n};\n\nOAuth._loginStyleFromQuery = function (query) {\n  var style;\n  // For backwards-compatibility for older clients, catch any errors\n  // that result from parsing the state parameter. If we can't parse it,\n  // set login style to popup by default.\n  try {\n    style = OAuth._stateFromQuery(query).loginStyle;\n  } catch (err) {\n    style = \"popup\";\n  }\n  if (style !== \"popup\" && style !== \"redirect\") {\n    throw new Error(\"Unrecognized login style: \" + style);\n  }\n  return style;\n};\n\nOAuth._credentialTokenFromQuery = function (query) {\n  var state;\n  // For backwards-compatibility for older clients, catch any errors\n  // that result from parsing the state parameter. If we can't parse it,\n  // assume that the state parameter's value is the credential token, as\n  // it used to be for older clients.\n  try {\n    state = OAuth._stateFromQuery(query);\n  } catch (err) {\n    return query.state;\n  }\n  return state.credentialToken;\n};\n\nOAuth._isCordovaFromQuery = function (query) {\n  try {\n    return !! OAuth._stateFromQuery(query).isCordova;\n  } catch (err) {\n    // For backwards-compatibility for older clients, catch any errors\n    // that result from parsing the state parameter. If we can't parse\n    // it, assume that we are not on Cordova, since older Meteor didn't\n    // do Cordova.\n    return false;\n  }\n};\n\n// Checks if the `redirectUrl` matches the app host.\n// We export this function so that developers can override this\n// behavior to allow apps from external domains to login using the\n// redirect OAuth flow.\nOAuth._checkRedirectUrlOrigin = function (redirectUrl) {\n  var appHost = Meteor.absoluteUrl();\n  var appHostReplacedLocalhost = Meteor.absoluteUrl(undefined, {\n    replaceLocalhost: true\n  });\n  return (\n    redirectUrl.substr(0, appHost.length) !== appHost &&\n    redirectUrl.substr(0, appHostReplacedLocalhost.length) !== appHostReplacedLocalhost\n  );\n};\n\n\n// Listen to incoming OAuth http requests\nWebApp.connectHandlers.use(function(req, res, next) {\n  // Need to create a Fiber since we're using synchronous http calls and nothing\n  // else is wrapping this in a fiber automatically\n  Fiber(function () {\n    middleware(req, res, next);\n  }).run();\n});\n\nvar middleware = function (req, res, next) {\n  // Make sure to catch any exceptions because otherwise we'd crash\n  // the runner\n  try {\n    var serviceName = oauthServiceName(req);\n    if (!serviceName) {\n      // not an oauth request. pass to next middleware.\n      next();\n      return;\n    }\n\n    var service = registeredServices[serviceName];\n\n    // Skip everything if there's no service set by the oauth middleware\n    if (!service)\n      throw new Error(\"Unexpected OAuth service \" + serviceName);\n\n    // Make sure we're configured\n    ensureConfigured(serviceName);\n\n    var handler = OAuth._requestHandlers[service.version];\n    if (!handler)\n      throw new Error(\"Unexpected OAuth version \" + service.version);\n    handler(service, req.query, res);\n  } catch (err) {\n    // if we got thrown an error, save it off, it will get passed to\n    // the appropriate login call (if any) and reported there.\n    //\n    // The other option would be to display it in the popup tab that\n    // is still open at this point, ignoring the 'close' or 'redirect'\n    // we were passed. But then the developer wouldn't be able to\n    // style the error or react to it in any way.\n    if (req.query.state && err instanceof Error) {\n      try { // catch any exceptions to avoid crashing runner\n        OAuth._storePendingCredential(OAuth._credentialTokenFromQuery(req.query), err);\n      } catch (err) {\n        // Ignore the error and just give up. If we failed to store the\n        // error, then the login will just fail with a generic error.\n        Log.warn(\"Error in OAuth Server while storing pending login result.\\n\" +\n                 err.stack || err.message);\n      }\n    }\n\n    // close the popup. because nobody likes them just hanging\n    // there.  when someone sees this multiple times they might\n    // think to check server logs (we hope?)\n    // Catch errors because any exception here will crash the runner.\n    try {\n      OAuth._endOfLoginResponse(res, {\n        query: req.query,\n        loginStyle: OAuth._loginStyleFromQuery(req.query),\n        error: err\n      });\n    } catch (err) {\n      Log.warn(\"Error generating end of login response\\n\" +\n               (err && (err.stack || err.message)));\n    }\n  }\n};\n\nOAuthTest.middleware = middleware;\n\n// Handle /_oauth/* paths and extract the service name.\n//\n// @returns {String|null} e.g. \"facebook\", or null if this isn't an\n// oauth request\nvar oauthServiceName = function (req) {\n  // req.url will be \"/_oauth/<service name>\" with an optional \"?close\".\n  var i = req.url.indexOf('?');\n  var barePath;\n  if (i === -1)\n    barePath = req.url;\n  else\n    barePath = req.url.substring(0, i);\n  var splitPath = barePath.split('/');\n\n  // Any non-oauth request will continue down the default\n  // middlewares.\n  if (splitPath[1] !== '_oauth')\n    return null;\n\n  // Find service based on url\n  var serviceName = splitPath[2];\n  return serviceName;\n};\n\n// Make sure we're configured\nvar ensureConfigured = function(serviceName) {\n  if (!ServiceConfiguration.configurations.findOne({service: serviceName})) {\n    throw new ServiceConfiguration.ConfigError();\n  }\n};\n\nvar isSafe = function (value) {\n  // This matches strings generated by `Random.secret` and\n  // `Random.id`.\n  return typeof value === \"string\" &&\n    /^[a-zA-Z0-9\\-_]+$/.test(value);\n};\n\n// Internal: used by the oauth1 and oauth2 packages\nOAuth._renderOauthResults = function(res, query, credentialSecret) {\n  // For tests, we support the `only_credential_secret_for_test`\n  // parameter, which just returns the credential secret without any\n  // surrounding HTML. (The test needs to be able to easily grab the\n  // secret and use it to log in.)\n  //\n  // XXX only_credential_secret_for_test could be useful for other\n  // things beside tests, like command-line clients. We should give it a\n  // real name and serve the credential secret in JSON.\n\n  if (query.only_credential_secret_for_test) {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(credentialSecret, 'utf-8');\n  } else {\n    var details = {\n      query: query,\n      loginStyle: OAuth._loginStyleFromQuery(query)\n    };\n    if (query.error) {\n      details.error = query.error;\n    } else {\n      var token = OAuth._credentialTokenFromQuery(query);\n      var secret = credentialSecret;\n      if (token && secret &&\n          isSafe(token) && isSafe(secret)) {\n        details.credentials = { token: token, secret: secret};\n      } else {\n        details.error = \"invalid_credential_token_or_secret\";\n      }\n    }\n\n    OAuth._endOfLoginResponse(res, details);\n  }\n};\n\n// This \"template\" (not a real Spacebars template, just an HTML file\n// with some ##PLACEHOLDER##s) communicates the credential secret back\n// to the main window and then closes the popup.\nOAuth._endOfPopupResponseTemplate = Assets.getText(\n  \"end_of_popup_response.html\");\n\nOAuth._endOfRedirectResponseTemplate = Assets.getText(\n  \"end_of_redirect_response.html\");\n\n// Renders the end of login response template into some HTML and JavaScript\n// that closes the popup or redirects at the end of the OAuth flow.\n//\n// options are:\n//   - loginStyle (\"popup\" or \"redirect\")\n//   - setCredentialToken (boolean)\n//   - credentialToken\n//   - credentialSecret\n//   - redirectUrl\n//   - isCordova (boolean)\n//\nvar renderEndOfLoginResponse = function (options) {\n  // It would be nice to use Blaze here, but it's a little tricky\n  // because our mustaches would be inside a <script> tag, and Blaze\n  // would treat the <script> tag contents as text (e.g. encode '&' as\n  // '&amp;'). So we just do a simple replace.\n\n  var escape = function (s) {\n    if (s) {\n      return s.replace(/&/g, \"&amp;\").\n        replace(/</g, \"&lt;\").\n        replace(/>/g, \"&gt;\").\n        replace(/\\\"/g, \"&quot;\").\n        replace(/\\'/g, \"&#x27;\").\n        replace(/\\//g, \"&#x2F;\");\n    } else {\n      return s;\n    }\n  };\n\n  // Escape everything just to be safe (we've already checked that some\n  // of this data -- the token and secret -- are safe).\n  var config = {\n    setCredentialToken: !! options.setCredentialToken,\n    credentialToken: escape(options.credentialToken),\n    credentialSecret: escape(options.credentialSecret),\n    storagePrefix: escape(OAuth._storageTokenPrefix),\n    redirectUrl: escape(options.redirectUrl),\n    isCordova: !! options.isCordova\n  };\n\n  var template;\n  if (options.loginStyle === 'popup') {\n    template = OAuth._endOfPopupResponseTemplate;\n  } else if (options.loginStyle === 'redirect') {\n    template = OAuth._endOfRedirectResponseTemplate;\n  } else {\n    throw new Error('invalid loginStyle: ' + options.loginStyle);\n  }\n\n  var result = template.replace(/##CONFIG##/, JSON.stringify(config));\n\n  return \"<!DOCTYPE html>\\n\" + result;\n};\n\n// Writes an HTTP response to the popup window at the end of an OAuth\n// login flow. At this point, if the user has successfully authenticated\n// to the OAuth server and authorized this app, we communicate the\n// credentialToken and credentialSecret to the main window. The main\n// window must provide both these values to the DDP `login` method to\n// authenticate its DDP connection. After communicating these vaues to\n// the main window, we close the popup.\n//\n// We export this function so that developers can override this\n// behavior, which is particularly useful in, for example, some mobile\n// environments where popups and/or `window.opener` don't work. For\n// example, an app could override `OAuth._endOfPopupResponse` to put the\n// credential token and credential secret in the popup URL for the main\n// window to read them there instead of using `window.opener`. If you\n// override this function, you take responsibility for writing to the\n// request and calling `res.end()` to complete the request.\n//\n// Arguments:\n//   - res: the HTTP response object\n//   - details:\n//      - query: the query string on the HTTP request\n//      - credentials: { token: *, secret: * }. If present, this field\n//        indicates that the login was successful. Return these values\n//        to the client, who can use them to log in over DDP. If\n//        present, the values have been checked against a limited\n//        character set and are safe to include in HTML.\n//      - error: if present, a string or Error indicating an error that\n//        occurred during the login. This can come from the client and\n//        so shouldn't be trusted for security decisions or included in\n//        the response without sanitizing it first. Only one of `error`\n//        or `credentials` should be set.\nOAuth._endOfLoginResponse = function (res, details) {\n  res.writeHead(200, {'Content-Type': 'text/html'});\n\n  var redirectUrl;\n  if (details.loginStyle === 'redirect') {\n    redirectUrl = OAuth._stateFromQuery(details.query).redirectUrl;\n    var appHost = Meteor.absoluteUrl();\n    if (OAuth._checkRedirectUrlOrigin(redirectUrl)) {\n      details.error = \"redirectUrl (\" + redirectUrl +\n        \") is not on the same host as the app (\" + appHost + \")\";\n      redirectUrl = appHost;\n    }\n  }\n\n  var isCordova = OAuth._isCordovaFromQuery(details.query);\n\n  if (details.error) {\n    Log.warn(\"Error in OAuth Server: \" +\n             (details.error instanceof Error ?\n              details.error.message : details.error));\n    res.end(renderEndOfLoginResponse({\n      loginStyle: details.loginStyle,\n      setCredentialToken: false,\n      redirectUrl: redirectUrl,\n      isCordova: isCordova\n    }), \"utf-8\");\n    return;\n  }\n\n  // If we have a credentialSecret, report it back to the parent\n  // window, with the corresponding credentialToken. The parent window\n  // uses the credentialToken and credentialSecret to log in over DDP.\n  res.end(renderEndOfLoginResponse({\n    loginStyle: details.loginStyle,\n    setCredentialToken: true,\n    credentialToken: details.credentials.token,\n    credentialSecret: details.credentials.secret,\n    redirectUrl: redirectUrl,\n    isCordova: isCordova\n  }), \"utf-8\");\n};\n\n\nvar OAuthEncryption = Package[\"oauth-encryption\"] && Package[\"oauth-encryption\"].OAuthEncryption;\n\nvar usingOAuthEncryption = function () {\n  return OAuthEncryption && OAuthEncryption.keyIsLoaded();\n};\n\n// Encrypt sensitive service data such as access tokens if the\n// \"oauth-encryption\" package is loaded and the oauth secret key has\n// been specified.  Returns the unencrypted plaintext otherwise.\n//\n// The user id is not specified because the user isn't known yet at\n// this point in the oauth authentication process.  After the oauth\n// authentication process completes the encrypted service data fields\n// will be re-encrypted with the user id included before inserting the\n// service data into the user document.\n//\nOAuth.sealSecret = function (plaintext) {\n  if (usingOAuthEncryption())\n    return OAuthEncryption.seal(plaintext);\n  else\n    return plaintext;\n}\n\n// Unencrypt a service data field, if the \"oauth-encryption\"\n// package is loaded and the field is encrypted.\n//\n// Throws an error if the \"oauth-encryption\" package is loaded and the\n// field is encrypted, but the oauth secret key hasn't been specified.\n//\nOAuth.openSecret = function (maybeSecret, userId) {\n  if (!Package[\"oauth-encryption\"] || !OAuthEncryption.isSealed(maybeSecret))\n    return maybeSecret;\n\n  return OAuthEncryption.open(maybeSecret, userId);\n};\n\n// Unencrypt fields in the service data object.\n//\nOAuth.openSecrets = function (serviceData, userId) {\n  var result = {};\n  _.each(_.keys(serviceData), function (key) {\n    result[key] = OAuth.openSecret(serviceData[key], userId);\n  });\n  return result;\n};\n","//\n// When an oauth request is made, Meteor receives oauth credentials\n// in one browser tab, and temporarily persists them while that\n// tab is closed, then retrieves them in the browser tab that\n// initiated the credential request.\n//\n// _pendingCredentials is the storage mechanism used to share the\n// credential between the 2 tabs\n//\n\n\n// Collection containing pending credentials of oauth credential requests\n// Has key, credential, and createdAt fields.\nOAuth._pendingCredentials = new Mongo.Collection(\n  \"meteor_oauth_pendingCredentials\", {\n    _preventAutopublish: true\n  });\n\nOAuth._pendingCredentials._ensureIndex('key', {unique: 1});\nOAuth._pendingCredentials._ensureIndex('credentialSecret');\nOAuth._pendingCredentials._ensureIndex('createdAt');\n\n\n\n// Periodically clear old entries that were never retrieved\nvar _cleanStaleResults = function() {\n  // Remove credentials older than 1 minute\n  var timeCutoff = new Date();\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 1);\n  OAuth._pendingCredentials.remove({ createdAt: { $lt: timeCutoff } });\n};\nvar _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\n\n\n// Stores the key and credential in the _pendingCredentials collection.\n// Will throw an exception if `key` is not a string.\n//\n// @param key {string}\n// @param credential {Object}   The credential to store\n// @param credentialSecret {string} A secret that must be presented in\n//   addition to the `key` to retrieve the credential\n//\nOAuth._storePendingCredential = function (key, credential, credentialSecret) {\n  check(key, String);\n  check(credentialSecret, Match.Optional(String));\n\n  if (credential instanceof Error) {\n    credential = storableError(credential);\n  } else {\n    credential = OAuth.sealSecret(credential);\n  }\n\n  // We do an upsert here instead of an insert in case the user happens\n  // to somehow send the same `state` parameter twice during an OAuth\n  // login; we don't want a duplicate key error.\n  OAuth._pendingCredentials.upsert({\n    key: key\n  }, {\n    key: key,\n    credential: credential,\n    credentialSecret: credentialSecret || null,\n    createdAt: new Date()\n  });\n};\n\n\n// Retrieves and removes a credential from the _pendingCredentials collection\n//\n// @param key {string}\n// @param credentialSecret {string}\n//\nOAuth._retrievePendingCredential = function (key, credentialSecret) {\n  check(key, String);\n\n  var pendingCredential = OAuth._pendingCredentials.findOne({\n    key: key,\n    credentialSecret: credentialSecret || null\n  });\n  if (pendingCredential) {\n    OAuth._pendingCredentials.remove({ _id: pendingCredential._id });\n    if (pendingCredential.credential.error)\n      return recreateError(pendingCredential.credential.error);\n    else\n      return OAuth.openSecret(pendingCredential.credential);\n  } else {\n    return undefined;\n  }\n};\n\n\n// Convert an Error into an object that can be stored in mongo\n// Note: A Meteor.Error is reconstructed as a Meteor.Error\n// All other error classes are reconstructed as a plain Error.\nvar storableError = function(error) {\n  var plainObject = {};\n  Object.getOwnPropertyNames(error).forEach(function(key) {\n    plainObject[key] = error[key];\n  });\n\n  // Keep track of whether it's a Meteor.Error\n  if(error instanceof Meteor.Error) {\n    plainObject['meteorError'] = true;\n  }\n\n  return { error: plainObject };\n};\n\n// Create an error from the error format stored in mongo\nvar recreateError = function(errorDoc) {\n  var error;\n\n  if (errorDoc.meteorError) {\n    error = new Meteor.Error();\n    delete errorDoc.meteorError;\n  } else {\n    error = new Error();\n  }\n\n  Object.getOwnPropertyNames(errorDoc).forEach(function(key) {\n    error[key] = errorDoc[key];\n  });\n\n  return error;\n};\n","OAuth._storageTokenPrefix = \"Meteor.oauth.credentialSecret-\";\n\nOAuth._redirectUri = function (serviceName, config, params, absoluteUrlOptions) {\n  // XXX COMPAT WITH 0.9.0\n  // The redirect URI used to have a \"?close\" query argument.  We\n  // detect whether we need to be backwards compatible by checking for\n  // the absence of the `loginStyle` field, which wasn't used in the\n  // code which had the \"?close\" argument.\n  // This logic is duplicated in the tool so that the tool can do OAuth\n  // flow with <= 0.9.0 servers (tools/auth.js).\n  var query = config.loginStyle ? null : \"close\";\n\n  // Clone because we're going to mutate 'params'. The 'cordova' and\n  // 'android' parameters are only used for picking the host of the\n  // redirect URL, and not actually included in the redirect URL itself.\n  var isCordova = false;\n  var isAndroid = false;\n  if (params) {\n    params = _.clone(params);\n    isCordova = params.cordova;\n    isAndroid = params.android;\n    delete params.cordova;\n    delete params.android;\n    if (_.isEmpty(params)) {\n      params = undefined;\n    }\n  }\n\n  if (Meteor.isServer && isCordova) {\n    var rootUrl = process.env.MOBILE_ROOT_URL ||\n          __meteor_runtime_config__.ROOT_URL;\n\n    if (isAndroid) {\n      // Match the replace that we do in cordova boilerplate\n      // (boilerplate-generator package).\n      // XXX Maybe we should put this in a separate package or something\n      // that is used here and by boilerplate-generator? Or maybe\n      // `Meteor.absoluteUrl` should know how to do this?\n      var url = Npm.require(\"url\");\n      var parsedRootUrl = url.parse(rootUrl);\n      if (parsedRootUrl.hostname === \"localhost\") {\n        parsedRootUrl.hostname = \"10.0.2.2\";\n        delete parsedRootUrl.host;\n      }\n      rootUrl = url.format(parsedRootUrl);\n    }\n\n    absoluteUrlOptions = _.extend({}, absoluteUrlOptions, {\n      // For Cordova clients, redirect to the special Cordova root url\n      // (likely a local IP in development mode).\n      rootUrl: rootUrl\n    });\n  }\n\n  return URL._constructUrl(\n    Meteor.absoluteUrl('_oauth/' + serviceName, absoluteUrlOptions),\n    query,\n    params);\n};\n","// XXX COMPAT WITH 0.8.0\n\nOauth = OAuth;\n"]}}]