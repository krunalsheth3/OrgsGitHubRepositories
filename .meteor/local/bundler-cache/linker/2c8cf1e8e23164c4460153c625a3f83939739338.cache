[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar NpmModuleBcrypt = Package['npm-bcrypt'].NpmModuleBcrypt;\nvar Accounts = Package['accounts-base'].Accounts;\nvar AccountsServer = Package['accounts-base'].AccountsServer;\nvar SRP = Package.srp.SRP;\nvar SHA256 = Package.sha.SHA256;\nvar EJSON = Package.ejson.EJSON;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar Email = Package.email.Email;\nvar EmailInternals = Package.email.EmailInternals;\nvar Random = Package.random.Random;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar _ = Package.underscore._;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar babelHelpers = Package['babel-runtime'].babelHelpers;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar Promise = Package.promise.Promise;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/accounts-password/email_templates.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/**                                                                                                                    //\n * @summary Options to customize emails sent from the Accounts system.                                                 //\n * @locus Server                                                                                                       //\n */                                                                                                                    //\n                                                                                                                       //\nfunction greet(welcomeMsg) {                                                                                           // 6\n  return function (user, url) {                                                                                        // 7\n    var greeting = user.profile && user.profile.name ? \"Hello \" + user.profile.name + \",\" : \"Hello,\";                  // 8\n    return greeting + \"\\n\\n\" + welcomeMsg + \", simply click the link below.\\n\\n\" + url + \"\\n\\nThanks.\\n\";              // 10\n  };                                                                                                                   //\n}                                                                                                                      //\n                                                                                                                       //\nAccounts.emailTemplates = {                                                                                            // 21\n  from: \"Meteor Accounts <no-reply@meteor.com>\",                                                                       // 22\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),                                       // 23\n                                                                                                                       //\n  resetPassword: {                                                                                                     // 25\n    subject: function (user) {                                                                                         // 26\n      return \"How to reset your password on \" + Accounts.emailTemplates.siteName;                                      // 27\n    },                                                                                                                 //\n    text: function (user, url) {                                                                                       // 29\n      var greeting = user.profile && user.profile.name ? \"Hello \" + user.profile.name + \",\" : \"Hello,\";                // 30\n      return greeting + \"\\n\\nTo reset your password, simply click the link below.\\n\\n\" + url + \"\\n\\nThanks.\\n\";        // 32\n    }                                                                                                                  //\n  },                                                                                                                   //\n  verifyEmail: {                                                                                                       // 42\n    subject: function (user) {                                                                                         // 43\n      return \"How to verify email address on \" + Accounts.emailTemplates.siteName;                                     // 44\n    },                                                                                                                 //\n    text: greet(\"To verify your account email\")                                                                        // 46\n  },                                                                                                                   //\n  enrollAccount: {                                                                                                     // 48\n    subject: function (user) {                                                                                         // 49\n      return \"An account has been created for you on \" + Accounts.emailTemplates.siteName;                             // 50\n    },                                                                                                                 //\n    text: greet(\"To start using the service\")                                                                          // 52\n  }                                                                                                                    //\n};                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/accounts-password/password_server.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/// BCRYPT                                                                                                             //\n                                                                                                                       //\nvar bcrypt = NpmModuleBcrypt;                                                                                          // 3\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);                                                                        // 4\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare);                                                                  // 5\n                                                                                                                       //\n// User records have a 'services.password.bcrypt' field on them to hold                                                //\n// their hashed passwords (unless they have a 'services.password.srp'                                                  //\n// field, in which case they will be upgraded to bcrypt the next time                                                  //\n// they log in).                                                                                                       //\n//                                                                                                                     //\n// When the client sends a password to the server, it can either be a                                                  //\n// string (the plaintext password) or an object with keys 'digest' and                                                 //\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends                                             //\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients                                               //\n// that don't have access to SHA can just send plaintext passwords as                                                  //\n// strings.                                                                                                            //\n//                                                                                                                     //\n// When the server receives a plaintext password as a string, it always                                                //\n// hashes it with SHA256 before passing it into bcrypt. When the server                                                //\n// receives a password as an object, it asserts that the algorithm is                                                  //\n// \"sha-256\" and then passes the digest to bcrypt.                                                                     //\n                                                                                                                       //\nAccounts._bcryptRounds = 10;                                                                                           // 25\n                                                                                                                       //\n// Given a 'password' from the client, extract the string that we should                                               //\n// bcrypt. 'password' can be one of:                                                                                   //\n//  - String (the plaintext password)                                                                                  //\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".                                        //\n//                                                                                                                     //\nvar getPasswordString = function (password) {                                                                          // 32\n  if (typeof password === \"string\") {                                                                                  // 33\n    password = SHA256(password);                                                                                       // 34\n  } else {                                                                                                             //\n    // 'password' is an object                                                                                         //\n    if (password.algorithm !== \"sha-256\") {                                                                            // 36\n      throw new Error(\"Invalid password hash algorithm. \" + \"Only 'sha-256' is allowed.\");                             // 37\n    }                                                                                                                  //\n    password = password.digest;                                                                                        // 40\n  }                                                                                                                    //\n  return password;                                                                                                     // 42\n};                                                                                                                     //\n                                                                                                                       //\n// Use bcrypt to hash the password for storage in the database.                                                        //\n// `password` can be a string (in which case it will be run through                                                    //\n// SHA256 before bcrypt) or an object with properties `digest` and                                                     //\n// `algorithm` (in which case we bcrypt `password.digest`).                                                            //\n//                                                                                                                     //\nvar hashPassword = function (password) {                                                                               // 50\n  password = getPasswordString(password);                                                                              // 51\n  return bcryptHash(password, Accounts._bcryptRounds);                                                                 // 52\n};                                                                                                                     //\n                                                                                                                       //\n// Check whether the provided password matches the bcrypt'ed password in                                               //\n// the database user record. `password` can be a string (in which case                                                 //\n// it will be run through SHA256 before bcrypt) or an object with                                                      //\n// properties `digest` and `algorithm` (in which case we bcrypt                                                        //\n// `password.digest`).                                                                                                 //\n//                                                                                                                     //\nAccounts._checkPassword = function (user, password) {                                                                  // 61\n  var result = {                                                                                                       // 62\n    userId: user._id                                                                                                   // 63\n  };                                                                                                                   //\n                                                                                                                       //\n  password = getPasswordString(password);                                                                              // 66\n                                                                                                                       //\n  if (!bcryptCompare(password, user.services.password.bcrypt)) {                                                       // 68\n    result.error = new Meteor.Error(403, \"Incorrect password\");                                                        // 69\n  }                                                                                                                    //\n                                                                                                                       //\n  return result;                                                                                                       // 72\n};                                                                                                                     //\nvar checkPassword = Accounts._checkPassword;                                                                           // 74\n                                                                                                                       //\n///                                                                                                                    //\n/// LOGIN                                                                                                              //\n///                                                                                                                    //\n                                                                                                                       //\nAccounts._findUserByQuery = function (query) {                                                                         // 80\n  var user = null;                                                                                                     // 81\n                                                                                                                       //\n  if (query.id) {                                                                                                      // 83\n    user = Meteor.users.findOne({ _id: query.id });                                                                    // 84\n  } else {                                                                                                             //\n    var fieldName;                                                                                                     // 86\n    var fieldValue;                                                                                                    // 87\n    if (query.username) {                                                                                              // 88\n      fieldName = 'username';                                                                                          // 89\n      fieldValue = query.username;                                                                                     // 90\n    } else if (query.email) {                                                                                          //\n      fieldName = 'emails.address';                                                                                    // 92\n      fieldValue = query.email;                                                                                        // 93\n    } else {                                                                                                           //\n      throw new Error(\"shouldn't happen (validation missed something)\");                                               // 95\n    }                                                                                                                  //\n    var selector = {};                                                                                                 // 97\n    selector[fieldName] = fieldValue;                                                                                  // 98\n    user = Meteor.users.findOne(selector);                                                                             // 99\n    // If user is not found, try a case insensitive lookup                                                             //\n    if (!user) {                                                                                                       // 101\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);                                          // 102\n      var candidateUsers = Meteor.users.find(selector).fetch();                                                        // 103\n      // No match if multiple candidates are found                                                                     //\n      if (candidateUsers.length === 1) {                                                                               // 105\n        user = candidateUsers[0];                                                                                      // 106\n      }                                                                                                                //\n    }                                                                                                                  //\n  }                                                                                                                    //\n                                                                                                                       //\n  return user;                                                                                                         // 111\n};                                                                                                                     //\n                                                                                                                       //\n/**                                                                                                                    //\n * @summary Finds the user with the specified username.                                                                //\n * First tries to match username case sensitively; if that fails, it                                                   //\n * tries case insensitively; but if more than one user matches the case                                                //\n * insensitive search, it returns null.                                                                                //\n * @locus Server                                                                                                       //\n * @param {String} username The username to look for                                                                   //\n * @returns {Object} A user if found, else null                                                                        //\n */                                                                                                                    //\nAccounts.findUserByUsername = function (username) {                                                                    // 123\n  return Accounts._findUserByQuery({                                                                                   // 124\n    username: username                                                                                                 // 125\n  });                                                                                                                  //\n};                                                                                                                     //\n                                                                                                                       //\n/**                                                                                                                    //\n * @summary Finds the user with the specified email.                                                                   //\n * First tries to match email case sensitively; if that fails, it                                                      //\n * tries case insensitively; but if more than one user matches the case                                                //\n * insensitive search, it returns null.                                                                                //\n * @locus Server                                                                                                       //\n * @param {String} email The email address to look for                                                                 //\n * @returns {Object} A user if found, else null                                                                        //\n */                                                                                                                    //\nAccounts.findUserByEmail = function (email) {                                                                          // 138\n  return Accounts._findUserByQuery({                                                                                   // 139\n    email: email                                                                                                       // 140\n  });                                                                                                                  //\n};                                                                                                                     //\n                                                                                                                       //\n// Generates a MongoDB selector that can be used to perform a fast case                                                //\n// insensitive lookup for the given fieldName and string. Since MongoDB does                                           //\n// not support case insensitive indexes, and case insensitive regex queries                                            //\n// are slow, we construct a set of prefix selectors for all permutations of                                            //\n// the first 4 characters ourselves. We first attempt to matching against                                              //\n// these, and because 'prefix expression' regex queries do use indexes (see                                            //\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),                                            //\n// this has been found to greatly improve performance (from 1200ms to 5ms in a                                         //\n// test with 1.000.000 users).                                                                                         //\nvar selectorForFastCaseInsensitiveLookup = function (fieldName, string) {                                              // 153\n  // Performance seems to improve up to 4 prefix characters                                                            //\n  var prefix = string.substring(0, Math.min(string.length, 4));                                                        // 155\n  var orClause = _.map(generateCasePermutationsForString(prefix), function (prefixPermutation) {                       // 156\n    var selector = {};                                                                                                 // 158\n    selector[fieldName] = new RegExp('^' + Meteor._escapeRegExp(prefixPermutation));                                   // 159\n    return selector;                                                                                                   // 161\n  });                                                                                                                  //\n  var caseInsensitiveClause = {};                                                                                      // 163\n  caseInsensitiveClause[fieldName] = new RegExp('^' + Meteor._escapeRegExp(string) + '$', 'i');                        // 164\n  return { $and: [{ $or: orClause }, caseInsensitiveClause] };                                                         // 166\n};                                                                                                                     //\n                                                                                                                       //\n// Generates permutations of all case variations of a given string.                                                    //\nvar generateCasePermutationsForString = function (string) {                                                            // 170\n  var permutations = [''];                                                                                             // 171\n  for (var i = 0; i < string.length; i++) {                                                                            // 172\n    var ch = string.charAt(i);                                                                                         // 173\n    permutations = _.flatten(_.map(permutations, function (prefix) {                                                   // 174\n      var lowerCaseChar = ch.toLowerCase();                                                                            // 175\n      var upperCaseChar = ch.toUpperCase();                                                                            // 176\n      // Don't add unneccesary permutations when ch is not a letter                                                    //\n      if (lowerCaseChar === upperCaseChar) {                                                                           // 178\n        return [prefix + ch];                                                                                          // 179\n      } else {                                                                                                         //\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];                                                       // 181\n      }                                                                                                                //\n    }));                                                                                                               //\n  }                                                                                                                    //\n  return permutations;                                                                                                 // 185\n};                                                                                                                     //\n                                                                                                                       //\nvar checkForCaseInsensitiveDuplicates = function (fieldName, displayName, fieldValue, ownUserId) {                     // 188\n  // Some tests need the ability to add users with the same case insensitive                                           //\n  // value, hence the _skipCaseInsensitiveChecksForTest check                                                          //\n  var skipCheck = _.has(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);                                       // 191\n                                                                                                                       //\n  if (fieldValue && !skipCheck) {                                                                                      // 193\n    var matchedUsers = Meteor.users.find(selectorForFastCaseInsensitiveLookup(fieldName, fieldValue)).fetch();         // 194\n                                                                                                                       //\n    if (matchedUsers.length > 0 && (                                                                                   // 197\n    // If we don't have a userId yet, any match we find is a duplicate                                                 //\n    !ownUserId || (                                                                                                    // 199\n    // Otherwise, check to see if there are multiple matches or a match                                                //\n    // that is not us                                                                                                  //\n    matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId))) {                                                  // 202\n      throw new Meteor.Error(403, displayName + \" already exists.\");                                                   // 203\n    }                                                                                                                  //\n  }                                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\n// XXX maybe this belongs in the check package                                                                         //\nvar NonEmptyString = Match.Where(function (x) {                                                                        // 209\n  check(x, String);                                                                                                    // 210\n  return x.length > 0;                                                                                                 // 211\n});                                                                                                                    //\n                                                                                                                       //\nvar userQueryValidator = Match.Where(function (user) {                                                                 // 214\n  check(user, {                                                                                                        // 215\n    id: Match.Optional(NonEmptyString),                                                                                // 216\n    username: Match.Optional(NonEmptyString),                                                                          // 217\n    email: Match.Optional(NonEmptyString)                                                                              // 218\n  });                                                                                                                  //\n  if (_.keys(user).length !== 1) throw new Match.Error(\"User property must have exactly one field\");                   // 220\n  return true;                                                                                                         // 222\n});                                                                                                                    //\n                                                                                                                       //\nvar passwordValidator = Match.OneOf(String, { digest: String, algorithm: String });                                    // 225\n                                                                                                                       //\n// Handler to login with a password.                                                                                   //\n//                                                                                                                     //\n// The Meteor client sets options.password to an object with keys                                                      //\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").                                                     //\n//                                                                                                                     //\n// For other DDP clients which don't have access to SHA, the handler                                                   //\n// also accepts the plaintext password in options.password as a string.                                                //\n//                                                                                                                     //\n// (It might be nice if servers could turn the plaintext password                                                      //\n// option off. Or maybe it should be opt-in, not opt-out?                                                              //\n// Accounts.config option?)                                                                                            //\n//                                                                                                                     //\n// Note that neither password option is secure without SSL.                                                            //\n//                                                                                                                     //\nAccounts.registerLoginHandler(\"password\", function (options) {                                                         // 244\n  if (!options.password || options.srp) return undefined; // don't handle                                              // 245\n                                                                                                                       //\n  check(options, {                                                                                                     // 248\n    user: userQueryValidator,                                                                                          // 249\n    password: passwordValidator                                                                                        // 250\n  });                                                                                                                  //\n                                                                                                                       //\n  var user = Accounts._findUserByQuery(options.user);                                                                  // 254\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 255\n                                                                                                                       //\n  if (!user.services || !user.services.password || !(user.services.password.bcrypt || user.services.password.srp)) throw new Meteor.Error(403, \"User has no password set\");\n                                                                                                                       //\n  if (!user.services.password.bcrypt) {                                                                                // 262\n    if (typeof options.password === \"string\") {                                                                        // 263\n      // The client has presented a plaintext password, and the user is                                                //\n      // not upgraded to bcrypt yet. We don't attempt to tell the client                                               //\n      // to upgrade to bcrypt, because it might be a standalone DDP                                                    //\n      // client doesn't know how to do such a thing.                                                                   //\n      var verifier = user.services.password.srp;                                                                       // 268\n      var newVerifier = SRP.generateVerifier(options.password, {                                                       // 269\n        identity: verifier.identity, salt: verifier.salt });                                                           // 270\n                                                                                                                       //\n      if (verifier.verifier !== newVerifier.verifier) {                                                                // 272\n        return {                                                                                                       // 273\n          userId: user._id,                                                                                            // 274\n          error: new Meteor.Error(403, \"Incorrect password\")                                                           // 275\n        };                                                                                                             //\n      }                                                                                                                //\n                                                                                                                       //\n      return { userId: user._id };                                                                                     // 279\n    } else {                                                                                                           //\n      // Tell the client to use the SRP upgrade process.                                                               //\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({                                             // 282\n        format: 'srp',                                                                                                 // 283\n        identity: user.services.password.srp.identity                                                                  // 284\n      }));                                                                                                             //\n    }                                                                                                                  //\n  }                                                                                                                    //\n                                                                                                                       //\n  return checkPassword(user, options.password);                                                                        // 289\n});                                                                                                                    //\n                                                                                                                       //\n// Handler to login using the SRP upgrade path. To use this login                                                      //\n// handler, the client must provide:                                                                                   //\n//   - srp: H(identity + \":\" + password)                                                                               //\n//   - password: a string or an object with properties 'digest' and 'algorithm'                                        //\n//                                                                                                                     //\n// We use `options.srp` to verify that the client knows the correct                                                    //\n// password without doing a full SRP flow. Once we've checked that, we                                                 //\n// upgrade the user to bcrypt and remove the SRP information from the                                                  //\n// user document.                                                                                                      //\n//                                                                                                                     //\n// The client ends up using this login handler after trying the normal                                                 //\n// login handler (above), which throws an error telling the client to                                                  //\n// try the SRP upgrade path.                                                                                           //\n//                                                                                                                     //\n// XXX COMPAT WITH 0.8.1.3                                                                                             //\nAccounts.registerLoginHandler(\"password\", function (options) {                                                         // 310\n  if (!options.srp || !options.password) return undefined; // don't handle                                             // 311\n                                                                                                                       //\n  check(options, {                                                                                                     // 314\n    user: userQueryValidator,                                                                                          // 315\n    srp: String,                                                                                                       // 316\n    password: passwordValidator                                                                                        // 317\n  });                                                                                                                  //\n                                                                                                                       //\n  var user = Accounts._findUserByQuery(options.user);                                                                  // 320\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 321\n                                                                                                                       //\n  // Check to see if another simultaneous login has already upgraded                                                   //\n  // the user record to bcrypt.                                                                                        //\n  if (user.services && user.services.password && user.services.password.bcrypt) return checkPassword(user, options.password);\n                                                                                                                       //\n  if (!(user.services && user.services.password && user.services.password.srp)) throw new Meteor.Error(403, \"User has no password set\");\n                                                                                                                       //\n  var v1 = user.services.password.srp.verifier;                                                                        // 332\n  var v2 = SRP.generateVerifier(null, {                                                                                // 333\n    hashedIdentityAndPassword: options.srp,                                                                            // 336\n    salt: user.services.password.srp.salt                                                                              // 337\n  }).verifier;                                                                                                         //\n  if (v1 !== v2) return {                                                                                              // 340\n    userId: user._id,                                                                                                  // 342\n    error: new Meteor.Error(403, \"Incorrect password\")                                                                 // 343\n  };                                                                                                                   //\n                                                                                                                       //\n  // Upgrade to bcrypt on successful login.                                                                            //\n  var salted = hashPassword(options.password);                                                                         // 347\n  Meteor.users.update(user._id, {                                                                                      // 348\n    $unset: { 'services.password.srp': 1 },                                                                            // 351\n    $set: { 'services.password.bcrypt': salted }                                                                       // 352\n  });                                                                                                                  //\n                                                                                                                       //\n  return { userId: user._id };                                                                                         // 356\n});                                                                                                                    //\n                                                                                                                       //\n///                                                                                                                    //\n/// CHANGING                                                                                                           //\n///                                                                                                                    //\n                                                                                                                       //\n/**                                                                                                                    //\n * @summary Change a user's username. Use this instead of updating the                                                 //\n * database directly. The operation will fail if there is an existing user                                             //\n * with a username only differing in case.                                                                             //\n * @locus Server                                                                                                       //\n * @param {String} userId The ID of the user to update.                                                                //\n * @param {String} newUsername A new username for the user.                                                            //\n */                                                                                                                    //\nAccounts.setUsername = function (userId, newUsername) {                                                                // 372\n  check(userId, NonEmptyString);                                                                                       // 373\n  check(newUsername, NonEmptyString);                                                                                  // 374\n                                                                                                                       //\n  var user = Meteor.users.findOne(userId);                                                                             // 376\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 377\n                                                                                                                       //\n  var oldUsername = user.username;                                                                                     // 380\n                                                                                                                       //\n  // Perform a case insensitive check fro duplicates before update                                                     //\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);                                    // 383\n                                                                                                                       //\n  Meteor.users.update({ _id: user._id }, { $set: { username: newUsername } });                                         // 385\n                                                                                                                       //\n  // Perform another check after update, in case a matching user has been                                              //\n  // inserted in the meantime                                                                                          //\n  try {                                                                                                                // 389\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);                                  // 390\n  } catch (ex) {                                                                                                       //\n    // Undo update if the check fails                                                                                  //\n    Meteor.users.update({ _id: user._id }, { $set: { username: oldUsername } });                                       // 393\n    throw ex;                                                                                                          // 394\n  }                                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\n// Let the user change their own password if they know the old                                                         //\n// password. `oldPassword` and `newPassword` should be objects with keys                                               //\n// `digest` and `algorithm` (representing the SHA256 of the password).                                                 //\n//                                                                                                                     //\n// XXX COMPAT WITH 0.8.1.3                                                                                             //\n// Like the login method, if the user hasn't been upgraded from SRP to                                                 //\n// bcrypt yet, then this method will throw an 'old password format'                                                    //\n// error. The client should call the SRP upgrade login handler and then                                                //\n// retry this method again.                                                                                            //\n//                                                                                                                     //\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade                                               //\n// errors thrown. The reasoning for this is that clients using this                                                    //\n// method directly will need to be updated anyway because we no longer                                                 //\n// support the SRP flow that they would have been doing to use this                                                    //\n// method previously.                                                                                                  //\nMeteor.methods({ changePassword: function (oldPassword, newPassword) {                                                 // 413\n    check(oldPassword, passwordValidator);                                                                             // 414\n    check(newPassword, passwordValidator);                                                                             // 415\n                                                                                                                       //\n    if (!this.userId) throw new Meteor.Error(401, \"Must be logged in\");                                                // 417\n                                                                                                                       //\n    var user = Meteor.users.findOne(this.userId);                                                                      // 420\n    if (!user) throw new Meteor.Error(403, \"User not found\");                                                          // 421\n                                                                                                                       //\n    if (!user.services || !user.services.password || !user.services.password.bcrypt && !user.services.password.srp) throw new Meteor.Error(403, \"User has no password set\");\n                                                                                                                       //\n    if (!user.services.password.bcrypt) {                                                                              // 428\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({                                             // 429\n        format: 'srp',                                                                                                 // 430\n        identity: user.services.password.srp.identity                                                                  // 431\n      }));                                                                                                             //\n    }                                                                                                                  //\n                                                                                                                       //\n    var result = checkPassword(user, oldPassword);                                                                     // 435\n    if (result.error) throw result.error;                                                                              // 436\n                                                                                                                       //\n    var hashed = hashPassword(newPassword);                                                                            // 439\n                                                                                                                       //\n    // It would be better if this removed ALL existing tokens and replaced                                             //\n    // the token for the current connection with a new one, but that would                                             //\n    // be tricky, so we'll settle for just replacing all tokens other than                                             //\n    // the one for the current connection.                                                                             //\n    var currentToken = Accounts._getLoginToken(this.connection.id);                                                    // 445\n    Meteor.users.update({ _id: this.userId }, {                                                                        // 446\n      $set: { 'services.password.bcrypt': hashed },                                                                    // 449\n      $pull: {                                                                                                         // 450\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }                                          // 451\n      },                                                                                                               //\n      $unset: { 'services.password.reset': 1 }                                                                         // 453\n    });                                                                                                                //\n                                                                                                                       //\n    return { passwordChanged: true };                                                                                  // 457\n  } });                                                                                                                //\n                                                                                                                       //\n// Force change the users password.                                                                                    //\n                                                                                                                       //\n/**                                                                                                                    //\n * @summary Forcibly change the password for a user.                                                                   //\n * @locus Server                                                                                                       //\n * @param {String} userId The id of the user to update.                                                                //\n * @param {String} newPassword A new password for the user.                                                            //\n * @param {Object} [options]                                                                                           //\n * @param {Object} options.logout Logout all current connections with this userId (default: true)                      //\n */                                                                                                                    //\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {                                              // 471\n  options = _.extend({ logout: true }, options);                                                                       // 472\n                                                                                                                       //\n  var user = Meteor.users.findOne(userId);                                                                             // 474\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 475\n                                                                                                                       //\n  var update = {                                                                                                       // 478\n    $unset: {                                                                                                          // 479\n      'services.password.srp': 1, // XXX COMPAT WITH 0.8.1.3                                                           // 480\n      'services.password.reset': 1                                                                                     // 481\n    },                                                                                                                 //\n    $set: { 'services.password.bcrypt': hashPassword(newPlaintextPassword) }                                           // 483\n  };                                                                                                                   //\n                                                                                                                       //\n  if (options.logout) {                                                                                                // 486\n    update.$unset['services.resume.loginTokens'] = 1;                                                                  // 487\n  }                                                                                                                    //\n                                                                                                                       //\n  Meteor.users.update({ _id: user._id }, update);                                                                      // 490\n};                                                                                                                     //\n                                                                                                                       //\n///                                                                                                                    //\n/// RESETTING VIA EMAIL                                                                                                //\n///                                                                                                                    //\n                                                                                                                       //\n// Method called by a user to request a password reset email. This is                                                  //\n// the start of the reset process.                                                                                     //\nMeteor.methods({ forgotPassword: function (options) {                                                                  // 500\n    check(options, { email: String });                                                                                 // 501\n                                                                                                                       //\n    var user = Meteor.users.findOne({ \"emails.address\": options.email });                                              // 503\n    if (!user) throw new Meteor.Error(403, \"User not found\");                                                          // 504\n                                                                                                                       //\n    Accounts.sendResetPasswordEmail(user._id, options.email);                                                          // 507\n  } });                                                                                                                //\n                                                                                                                       //\n// send the user an email with a link that when opened allows the user                                                 //\n// to set a new password, without the old password.                                                                    //\n                                                                                                                       //\n/**                                                                                                                    //\n * @summary Send an email with a link the user can use to reset their password.                                        //\n * @locus Server                                                                                                       //\n * @param {String} userId The id of the user to send email to.                                                         //\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n */                                                                                                                    //\nAccounts.sendResetPasswordEmail = function (userId, email) {                                                           // 519\n  // Make sure the user exists, and email is one of their addresses.                                                   //\n  var user = Meteor.users.findOne(userId);                                                                             // 521\n  if (!user) throw new Error(\"Can't find user\");                                                                       // 522\n  // pick the first email if we weren't passed an email.                                                               //\n  if (!email && user.emails && user.emails[0]) email = user.emails[0].address;                                         // 525\n  // make sure we have a valid email                                                                                   //\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) throw new Error(\"No such email for user.\");\n                                                                                                                       //\n  var token = Random.secret();                                                                                         // 531\n  var when = new Date();                                                                                               // 532\n  var tokenRecord = {                                                                                                  // 533\n    token: token,                                                                                                      // 534\n    email: email,                                                                                                      // 535\n    when: when                                                                                                         // 536\n  };                                                                                                                   //\n  Meteor.users.update(userId, { $set: {                                                                                // 538\n      \"services.password.reset\": tokenRecord                                                                           // 539\n    } });                                                                                                              //\n  // before passing to template, update user object with new token                                                     //\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;                                                    // 542\n                                                                                                                       //\n  var resetPasswordUrl = Accounts.urls.resetPassword(token);                                                           // 544\n                                                                                                                       //\n  var options = {                                                                                                      // 546\n    to: email,                                                                                                         // 547\n    from: Accounts.emailTemplates.resetPassword.from ? Accounts.emailTemplates.resetPassword.from(user) : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.resetPassword.subject(user)                                                       // 551\n  };                                                                                                                   //\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.resetPassword.text === 'function') {                                              // 554\n    options.text = Accounts.emailTemplates.resetPassword.text(user, resetPasswordUrl);                                 // 555\n  }                                                                                                                    //\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.resetPassword.html === 'function') options.html = Accounts.emailTemplates.resetPassword.html(user, resetPasswordUrl);\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.headers === 'object') {                                                           // 563\n    options.headers = Accounts.emailTemplates.headers;                                                                 // 564\n  }                                                                                                                    //\n                                                                                                                       //\n  Email.send(options);                                                                                                 // 567\n};                                                                                                                     //\n                                                                                                                       //\n// send the user an email informing them that their account was created, with                                          //\n// a link that when opened both marks their email as verified and forces them                                          //\n// to choose their password. The email must be one of the addresses in the                                             //\n// user's emails field, or undefined to pick the first email automatically.                                            //\n//                                                                                                                     //\n// This is not called automatically. It must be called manually if you                                                 //\n// want to use enrollment emails.                                                                                      //\n                                                                                                                       //\n/**                                                                                                                    //\n * @summary Send an email with a link the user can use to set their initial password.                                  //\n * @locus Server                                                                                                       //\n * @param {String} userId The id of the user to send email to.                                                         //\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n */                                                                                                                    //\nAccounts.sendEnrollmentEmail = function (userId, email) {                                                              // 584\n  // XXX refactor! This is basically identical to sendResetPasswordEmail.                                              //\n                                                                                                                       //\n  // Make sure the user exists, and email is in their addresses.                                                       //\n  var user = Meteor.users.findOne(userId);                                                                             // 588\n  if (!user) throw new Error(\"Can't find user\");                                                                       // 589\n  // pick the first email if we weren't passed an email.                                                               //\n  if (!email && user.emails && user.emails[0]) email = user.emails[0].address;                                         // 592\n  // make sure we have a valid email                                                                                   //\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) throw new Error(\"No such email for user.\");\n                                                                                                                       //\n  var token = Random.secret();                                                                                         // 598\n  var when = new Date();                                                                                               // 599\n  var tokenRecord = {                                                                                                  // 600\n    token: token,                                                                                                      // 601\n    email: email,                                                                                                      // 602\n    when: when                                                                                                         // 603\n  };                                                                                                                   //\n  Meteor.users.update(userId, { $set: {                                                                                // 605\n      \"services.password.reset\": tokenRecord                                                                           // 606\n    } });                                                                                                              //\n                                                                                                                       //\n  // before passing to template, update user object with new token                                                     //\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;                                                    // 610\n                                                                                                                       //\n  var enrollAccountUrl = Accounts.urls.enrollAccount(token);                                                           // 612\n                                                                                                                       //\n  var options = {                                                                                                      // 614\n    to: email,                                                                                                         // 615\n    from: Accounts.emailTemplates.enrollAccount.from ? Accounts.emailTemplates.enrollAccount.from(user) : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.enrollAccount.subject(user)                                                       // 619\n  };                                                                                                                   //\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.enrollAccount.text === 'function') {                                              // 622\n    options.text = Accounts.emailTemplates.enrollAccount.text(user, enrollAccountUrl);                                 // 623\n  }                                                                                                                    //\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.enrollAccount.html === 'function') options.html = Accounts.emailTemplates.enrollAccount.html(user, enrollAccountUrl);\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.headers === 'object') {                                                           // 631\n    options.headers = Accounts.emailTemplates.headers;                                                                 // 632\n  }                                                                                                                    //\n                                                                                                                       //\n  Email.send(options);                                                                                                 // 635\n};                                                                                                                     //\n                                                                                                                       //\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change                                               //\n// the users password, and log them in.                                                                                //\nMeteor.methods({ resetPassword: function (token, newPassword) {                                                        // 641\n    var self = this;                                                                                                   // 642\n    return Accounts._loginMethod(self, \"resetPassword\", arguments, \"password\", function () {                           // 643\n      check(token, String);                                                                                            // 649\n      check(newPassword, passwordValidator);                                                                           // 650\n                                                                                                                       //\n      var user = Meteor.users.findOne({                                                                                // 652\n        \"services.password.reset.token\": token });                                                                     // 653\n      if (!user) throw new Meteor.Error(403, \"Token expired\");                                                         // 654\n      var email = user.services.password.reset.email;                                                                  // 656\n      if (!_.include(_.pluck(user.emails || [], 'address'), email)) return {                                           // 657\n        userId: user._id,                                                                                              // 659\n        error: new Meteor.Error(403, \"Token has invalid email address\")                                                // 660\n      };                                                                                                               //\n                                                                                                                       //\n      var hashed = hashPassword(newPassword);                                                                          // 663\n                                                                                                                       //\n      // NOTE: We're about to invalidate tokens on the user, who we might be                                           //\n      // logged in as. Make sure to avoid logging ourselves out if this                                                //\n      // happens. But also make sure not to leave the connection in a state                                            //\n      // of having a bad token set if things fail.                                                                     //\n      var oldToken = Accounts._getLoginToken(self.connection.id);                                                      // 669\n      Accounts._setLoginToken(user._id, self.connection, null);                                                        // 670\n      var resetToOldToken = function () {                                                                              // 671\n        Accounts._setLoginToken(user._id, self.connection, oldToken);                                                  // 672\n      };                                                                                                               //\n                                                                                                                       //\n      try {                                                                                                            // 675\n        // Update the user record by:                                                                                  //\n        // - Changing the password to the new one                                                                      //\n        // - Forgetting about the reset token that was just used                                                       //\n        // - Verifying their email, since they got the password reset via email.                                       //\n        var affectedRecords = Meteor.users.update({                                                                    // 680\n          _id: user._id,                                                                                               // 682\n          'emails.address': email,                                                                                     // 683\n          'services.password.reset.token': token                                                                       // 684\n        }, { $set: { 'services.password.bcrypt': hashed,                                                               //\n            'emails.$.verified': true },                                                                               // 687\n          $unset: { 'services.password.reset': 1,                                                                      // 688\n            'services.password.srp': 1 } });                                                                           // 689\n        if (affectedRecords !== 1) return {                                                                            // 690\n          userId: user._id,                                                                                            // 692\n          error: new Meteor.Error(403, \"Invalid email\")                                                                // 693\n        };                                                                                                             //\n      } catch (err) {                                                                                                  //\n        resetToOldToken();                                                                                             // 696\n        throw err;                                                                                                     // 697\n      }                                                                                                                //\n                                                                                                                       //\n      // Replace all valid login tokens with new ones (changing                                                        //\n      // password should invalidate existing sessions).                                                                //\n      Accounts._clearAllLoginTokens(user._id);                                                                         // 702\n                                                                                                                       //\n      return { userId: user._id };                                                                                     // 704\n    });                                                                                                                //\n  } });                                                                                                                //\n                                                                                                                       //\n///                                                                                                                    //\n/// EMAIL VERIFICATION                                                                                                 //\n///                                                                                                                    //\n                                                                                                                       //\n// send the user an email with a link that when opened marks that                                                      //\n// address as verified                                                                                                 //\n                                                                                                                       //\n/**                                                                                                                    //\n * @summary Send an email with a link the user can use verify their email address.                                     //\n * @locus Server                                                                                                       //\n * @param {String} userId The id of the user to send email to.                                                         //\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n */                                                                                                                    //\nAccounts.sendVerificationEmail = function (userId, address) {                                                          // 723\n  // XXX Also generate a link using which someone can delete this                                                      //\n  // account if they own said address but weren't those who created                                                    //\n  // this account.                                                                                                     //\n                                                                                                                       //\n  // Make sure the user exists, and address is one of their addresses.                                                 //\n  var user = Meteor.users.findOne(userId);                                                                             // 729\n  if (!user) throw new Error(\"Can't find user\");                                                                       // 730\n  // pick the first unverified address if we weren't passed an address.                                                //\n  if (!address) {                                                                                                      // 733\n    var email = _.find(user.emails || [], function (e) {                                                               // 734\n      return !e.verified;                                                                                              // 735\n    });                                                                                                                //\n    address = (email || {}).address;                                                                                   // 736\n  }                                                                                                                    //\n  // make sure we have a valid address                                                                                 //\n  if (!address || !_.contains(_.pluck(user.emails || [], 'address'), address)) throw new Error(\"No such email address for user.\");\n                                                                                                                       //\n  var tokenRecord = {                                                                                                  // 743\n    token: Random.secret(),                                                                                            // 744\n    address: address,                                                                                                  // 745\n    when: new Date() };                                                                                                // 746\n  Meteor.users.update({ _id: userId }, { $push: { 'services.email.verificationTokens': tokenRecord } });               // 747\n                                                                                                                       //\n  // before passing to template, update user object with new token                                                     //\n  Meteor._ensure(user, 'services', 'email');                                                                           // 752\n  if (!user.services.email.verificationTokens) {                                                                       // 753\n    user.services.email.verificationTokens = [];                                                                       // 754\n  }                                                                                                                    //\n  user.services.email.verificationTokens.push(tokenRecord);                                                            // 756\n                                                                                                                       //\n  var verifyEmailUrl = Accounts.urls.verifyEmail(tokenRecord.token);                                                   // 758\n                                                                                                                       //\n  var options = {                                                                                                      // 760\n    to: address,                                                                                                       // 761\n    from: Accounts.emailTemplates.verifyEmail.from ? Accounts.emailTemplates.verifyEmail.from(user) : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.verifyEmail.subject(user)                                                         // 765\n  };                                                                                                                   //\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.verifyEmail.text === 'function') {                                                // 768\n    options.text = Accounts.emailTemplates.verifyEmail.text(user, verifyEmailUrl);                                     // 769\n  }                                                                                                                    //\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.verifyEmail.html === 'function') options.html = Accounts.emailTemplates.verifyEmail.html(user, verifyEmailUrl);\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.headers === 'object') {                                                           // 777\n    options.headers = Accounts.emailTemplates.headers;                                                                 // 778\n  }                                                                                                                    //\n                                                                                                                       //\n  Email.send(options);                                                                                                 // 781\n};                                                                                                                     //\n                                                                                                                       //\n// Take token from sendVerificationEmail, mark the email as verified,                                                  //\n// and log them in.                                                                                                    //\nMeteor.methods({ verifyEmail: function (token) {                                                                       // 786\n    var self = this;                                                                                                   // 787\n    return Accounts._loginMethod(self, \"verifyEmail\", arguments, \"password\", function () {                             // 788\n      check(token, String);                                                                                            // 794\n                                                                                                                       //\n      var user = Meteor.users.findOne({ 'services.email.verificationTokens.token': token });                           // 796\n      if (!user) throw new Meteor.Error(403, \"Verify email link expired\");                                             // 798\n                                                                                                                       //\n      var tokenRecord = _.find(user.services.email.verificationTokens, function (t) {                                  // 801\n        return t.token == token;                                                                                       // 803\n      });                                                                                                              //\n      if (!tokenRecord) return {                                                                                       // 805\n        userId: user._id,                                                                                              // 807\n        error: new Meteor.Error(403, \"Verify email link expired\")                                                      // 808\n      };                                                                                                               //\n                                                                                                                       //\n      var emailsRecord = _.find(user.emails, function (e) {                                                            // 811\n        return e.address == tokenRecord.address;                                                                       // 812\n      });                                                                                                              //\n      if (!emailsRecord) return {                                                                                      // 814\n        userId: user._id,                                                                                              // 816\n        error: new Meteor.Error(403, \"Verify email link is for unknown address\")                                       // 817\n      };                                                                                                               //\n                                                                                                                       //\n      // By including the address in the query, we can use 'emails.$' in the                                           //\n      // modifier to get a reference to the specific object in the emails                                              //\n      // array. See                                                                                                    //\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)                              //\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull                                                 //\n      Meteor.users.update({ _id: user._id,                                                                             // 825\n        'emails.address': tokenRecord.address }, { $set: { 'emails.$.verified': true },                                // 827\n        $pull: { 'services.email.verificationTokens': { address: tokenRecord.address } } });                           // 829\n                                                                                                                       //\n      return { userId: user._id };                                                                                     // 831\n    });                                                                                                                //\n  } });                                                                                                                //\n                                                                                                                       //\n/**                                                                                                                    //\n * @summary Add an email address for a user. Use this instead of directly                                              //\n * updating the database. The operation will fail if there is a different user                                         //\n * with an email only differing in case. If the specified user has an existing                                         //\n * email only differing in case however, we replace it.                                                                //\n * @locus Server                                                                                                       //\n * @param {String} userId The ID of the user to update.                                                                //\n * @param {String} newEmail A new email address for the user.                                                          //\n * @param {Boolean} [verified] Optional - whether the new email address should                                         //\n * be marked as verified. Defaults to false.                                                                           //\n */                                                                                                                    //\nAccounts.addEmail = function (userId, newEmail, verified) {                                                            // 847\n  check(userId, NonEmptyString);                                                                                       // 848\n  check(newEmail, NonEmptyString);                                                                                     // 849\n  check(verified, Match.Optional(Boolean));                                                                            // 850\n                                                                                                                       //\n  if (_.isUndefined(verified)) {                                                                                       // 852\n    verified = false;                                                                                                  // 853\n  }                                                                                                                    //\n                                                                                                                       //\n  var user = Meteor.users.findOne(userId);                                                                             // 856\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 857\n                                                                                                                       //\n  // Allow users to change their own email to a version with a different case                                          //\n                                                                                                                       //\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case                                              //\n  // insensitive check across all emails in the database here because: (1) if                                          //\n  // there is no case-insensitive duplicate between this user and other users,                                         //\n  // then we are OK and (2) if this would create a conflict with other users                                           //\n  // then there would already be a case-insensitive duplicate and we can't fix                                         //\n  // that in this code anyway.                                                                                         //\n  var caseInsensitiveRegExp = new RegExp('^' + Meteor._escapeRegExp(newEmail) + '$', 'i');                             // 868\n                                                                                                                       //\n  var didUpdateOwnEmail = _.any(user.emails, function (email, index) {                                                 // 871\n    if (caseInsensitiveRegExp.test(email.address)) {                                                                   // 872\n      Meteor.users.update({                                                                                            // 873\n        _id: user._id,                                                                                                 // 874\n        'emails.address': email.address                                                                                // 875\n      }, { $set: {                                                                                                     //\n          'emails.$.address': newEmail,                                                                                // 877\n          'emails.$.verified': verified                                                                                // 878\n        } });                                                                                                          //\n      return true;                                                                                                     // 880\n    }                                                                                                                  //\n                                                                                                                       //\n    return false;                                                                                                      // 883\n  });                                                                                                                  //\n                                                                                                                       //\n  // In the other updates below, we have to do another call to                                                         //\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values                                         //\n  // were added to the database in the meantime. We don't have to do this for                                          //\n  // the case where the user is updating their email address to one that is the                                        //\n  // same as before, but only different because of capitalization. Read the                                            //\n  // big comment above to understand why.                                                                              //\n                                                                                                                       //\n  if (didUpdateOwnEmail) {                                                                                             // 893\n    return;                                                                                                            // 894\n  }                                                                                                                    //\n                                                                                                                       //\n  // Perform a case insensitive check for duplicates before update                                                     //\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);                                    // 898\n                                                                                                                       //\n  Meteor.users.update({                                                                                                // 900\n    _id: user._id                                                                                                      // 901\n  }, {                                                                                                                 //\n    $addToSet: {                                                                                                       // 903\n      emails: {                                                                                                        // 904\n        address: newEmail,                                                                                             // 905\n        verified: verified                                                                                             // 906\n      }                                                                                                                //\n    }                                                                                                                  //\n  });                                                                                                                  //\n                                                                                                                       //\n  // Perform another check after update, in case a matching user has been                                              //\n  // inserted in the meantime                                                                                          //\n  try {                                                                                                                // 913\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);                                  // 914\n  } catch (ex) {                                                                                                       //\n    // Undo update if the check fails                                                                                  //\n    Meteor.users.update({ _id: user._id }, { $pull: { emails: { address: newEmail } } });                              // 917\n    throw ex;                                                                                                          // 919\n  }                                                                                                                    //\n};                                                                                                                     //\n                                                                                                                       //\n/**                                                                                                                    //\n * @summary Remove an email address for a user. Use this instead of updating                                           //\n * the database directly.                                                                                              //\n * @locus Server                                                                                                       //\n * @param {String} userId The ID of the user to update.                                                                //\n * @param {String} email The email address to remove.                                                                  //\n */                                                                                                                    //\nAccounts.removeEmail = function (userId, email) {                                                                      // 930\n  check(userId, NonEmptyString);                                                                                       // 931\n  check(email, NonEmptyString);                                                                                        // 932\n                                                                                                                       //\n  var user = Meteor.users.findOne(userId);                                                                             // 934\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 935\n                                                                                                                       //\n  Meteor.users.update({ _id: user._id }, { $pull: { emails: { address: email } } });                                   // 938\n};                                                                                                                     //\n                                                                                                                       //\n///                                                                                                                    //\n/// CREATING USERS                                                                                                     //\n///                                                                                                                    //\n                                                                                                                       //\n// Shared createUser function called from the createUser method, both                                                  //\n// if originates in client or server code. Calls user provided hooks,                                                  //\n// does the actual user insertion.                                                                                     //\n//                                                                                                                     //\n// returns the user id                                                                                                 //\nvar createUser = function (options) {                                                                                  // 951\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary                                               //\n  // options.                                                                                                          //\n  check(options, Match.ObjectIncluding({                                                                               // 954\n    username: Match.Optional(String),                                                                                  // 955\n    email: Match.Optional(String),                                                                                     // 956\n    password: Match.Optional(passwordValidator)                                                                        // 957\n  }));                                                                                                                 //\n                                                                                                                       //\n  var username = options.username;                                                                                     // 960\n  var email = options.email;                                                                                           // 961\n  if (!username && !email) throw new Meteor.Error(400, \"Need to set a username or email\");                             // 962\n                                                                                                                       //\n  var user = { services: {} };                                                                                         // 965\n  if (options.password) {                                                                                              // 966\n    var hashed = hashPassword(options.password);                                                                       // 967\n    user.services.password = { bcrypt: hashed };                                                                       // 968\n  }                                                                                                                    //\n                                                                                                                       //\n  if (username) user.username = username;                                                                              // 971\n  if (email) user.emails = [{ address: email, verified: false }];                                                      // 973\n                                                                                                                       //\n  // Perform a case insensitive check before insert                                                                    //\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);                                                 // 977\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);                                                 // 978\n                                                                                                                       //\n  var userId = Accounts.insertUserDoc(options, user);                                                                  // 980\n  // Perform another check after insert, in case a matching user has been                                              //\n  // inserted in the meantime                                                                                          //\n  try {                                                                                                                // 983\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);                                       // 984\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);                                       // 985\n  } catch (ex) {                                                                                                       //\n    // Remove inserted user if the check fails                                                                         //\n    Meteor.users.remove(userId);                                                                                       // 988\n    throw ex;                                                                                                          // 989\n  }                                                                                                                    //\n  return userId;                                                                                                       // 991\n};                                                                                                                     //\n                                                                                                                       //\n// method for create user. Requests come from the client.                                                              //\nMeteor.methods({ createUser: function (options) {                                                                      // 995\n    var self = this;                                                                                                   // 996\n    return Accounts._loginMethod(self, \"createUser\", arguments, \"password\", function () {                              // 997\n      // createUser() above does more checking.                                                                        //\n      check(options, Object);                                                                                          // 1004\n      if (Accounts._options.forbidClientAccountCreation) return {                                                      // 1005\n        error: new Meteor.Error(403, \"Signups forbidden\")                                                              // 1007\n      };                                                                                                               //\n                                                                                                                       //\n      // Create user. result contains id and token.                                                                    //\n      var userId = createUser(options);                                                                                // 1011\n      // safety belt. createUser is supposed to throw on error. send 500 error                                         //\n      // instead of sending a verification email with empty userid.                                                    //\n      if (!userId) throw new Error(\"createUser failed to insert new user\");                                            // 1014\n                                                                                                                       //\n      // If `Accounts._options.sendVerificationEmail` is set, register                                                 //\n      // a token to verify the user's primary email, and send it to                                                    //\n      // that address.                                                                                                 //\n      if (options.email && Accounts._options.sendVerificationEmail) Accounts.sendVerificationEmail(userId, options.email);\n                                                                                                                       //\n      // client gets logged in as the new user afterwards.                                                             //\n      return { userId: userId };                                                                                       // 1024\n    });                                                                                                                //\n  } });                                                                                                                //\n                                                                                                                       //\n// Create user directly on the server.                                                                                 //\n//                                                                                                                     //\n// Unlike the client version, this does not log you in as this user                                                    //\n// after creation.                                                                                                     //\n//                                                                                                                     //\n// returns userId or throws an error if it can't create                                                                //\n//                                                                                                                     //\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,                                         //\n// which is always empty when called from the createUser method? eg, \"admin:                                           //\n// true\", which we want to prevent the client from setting, but which a custom                                         //\n// method calling Accounts.createUser could set?                                                                       //\n//                                                                                                                     //\nAccounts.createUser = function (options, callback) {                                                                   // 1041\n  options = _.clone(options);                                                                                          // 1042\n                                                                                                                       //\n  // XXX allow an optional callback?                                                                                   //\n  if (callback) {                                                                                                      // 1045\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");                             // 1046\n  }                                                                                                                    //\n                                                                                                                       //\n  return createUser(options);                                                                                          // 1049\n};                                                                                                                     //\n                                                                                                                       //\n///                                                                                                                    //\n/// PASSWORD-SPECIFIC INDEXES ON USERS                                                                                 //\n///                                                                                                                    //\nMeteor.users._ensureIndex('services.email.verificationTokens.token', { unique: 1, sparse: 1 });                        // 1055\nMeteor.users._ensureIndex('services.password.reset.token', { unique: 1, sparse: 1 });                                  // 1057\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['accounts-password'] = {};\n\n})();\n","servePath":"/packages/accounts-password.js","sourceMap":{"version":3,"sources":["/email_templates.js","/password_server.js"],"names":[],"mappings":"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","file":"/packages/accounts-password.js","sourcesContent":["/**\n * @summary Options to customize emails sent from the Accounts system.\n * @locus Server\n */\n\nfunction greet(welcomeMsg) {\n  return function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return `${greeting}\n\n${welcomeMsg}, simply click the link below.\n\n${url}\n\nThanks.\n`;\n  };\n}\n\nAccounts.emailTemplates = {\n  from: \"Meteor Accounts <no-reply@meteor.com>\",\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),\n\n  resetPassword: {\n    subject: function(user) {\n      return \"How to reset your password on \" + Accounts.emailTemplates.siteName;\n    },\n    text: function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return `${greeting}\n\nTo reset your password, simply click the link below.\n\n${url}\n\nThanks.\n`;\n    }\n  },\n  verifyEmail: {\n    subject: function(user) {\n      return \"How to verify email address on \" + Accounts.emailTemplates.siteName;\n    },\n    text: greet(\"To verify your account email\")\n  },\n  enrollAccount: {\n    subject: function(user) {\n      return \"An account has been created for you on \" + Accounts.emailTemplates.siteName;\n    },\n    text: greet(\"To start using the service\")\n  }\n};\n","/// BCRYPT\n\nvar bcrypt = NpmModuleBcrypt;\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare);\n\n// User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords (unless they have a 'services.password.srp'\n// field, in which case they will be upgraded to bcrypt the next time\n// they log in).\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\n\nAccounts._bcryptRounds = 10;\n\n// Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\nvar getPasswordString = function (password) {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else { // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" +\n                      \"Only 'sha-256' is allowed.\");\n    }\n    password = password.digest;\n  }\n  return password;\n};\n\n// Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\nvar hashPassword = function (password) {\n  password = getPasswordString(password);\n  return bcryptHash(password, Accounts._bcryptRounds);\n};\n\n// Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\nAccounts._checkPassword = function (user, password) {\n  var result = {\n    userId: user._id\n  };\n\n  password = getPasswordString(password);\n\n  if (! bcryptCompare(password, user.services.password.bcrypt)) {\n    result.error = new Meteor.Error(403, \"Incorrect password\");\n  }\n\n  return result;\n};\nvar checkPassword = Accounts._checkPassword;\n\n///\n/// LOGIN\n///\n\nAccounts._findUserByQuery = function (query) {\n  var user = null;\n\n  if (query.id) {\n    user = Meteor.users.findOne({ _id: query.id });\n  } else {\n    var fieldName;\n    var fieldValue;\n    if (query.username) {\n      fieldName = 'username';\n      fieldValue = query.username;\n    } else if (query.email) {\n      fieldName = 'emails.address';\n      fieldValue = query.email;\n    } else {\n      throw new Error(\"shouldn't happen (validation missed something)\");\n    }\n    var selector = {};\n    selector[fieldName] = fieldValue;\n    user = Meteor.users.findOne(selector);\n    // If user is not found, try a case insensitive lookup\n    if (!user) {\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);\n      var candidateUsers = Meteor.users.find(selector).fetch();\n      // No match if multiple candidates are found\n      if (candidateUsers.length === 1) {\n        user = candidateUsers[0];\n      }\n    }\n  }\n\n  return user;\n};\n\n/**\n * @summary Finds the user with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @returns {Object} A user if found, else null\n */\nAccounts.findUserByUsername = function (username) {\n  return Accounts._findUserByQuery({\n    username: username\n  });\n};\n\n/**\n * @summary Finds the user with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @returns {Object} A user if found, else null\n */\nAccounts.findUserByEmail = function (email) {\n  return Accounts._findUserByQuery({\n    email: email\n  });\n};\n\n// Generates a MongoDB selector that can be used to perform a fast case\n// insensitive lookup for the given fieldName and string. Since MongoDB does\n// not support case insensitive indexes, and case insensitive regex queries\n// are slow, we construct a set of prefix selectors for all permutations of\n// the first 4 characters ourselves. We first attempt to matching against\n// these, and because 'prefix expression' regex queries do use indexes (see\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),\n// this has been found to greatly improve performance (from 1200ms to 5ms in a\n// test with 1.000.000 users).\nvar selectorForFastCaseInsensitiveLookup = function (fieldName, string) {\n  // Performance seems to improve up to 4 prefix characters\n  var prefix = string.substring(0, Math.min(string.length, 4));\n  var orClause = _.map(generateCasePermutationsForString(prefix),\n    function (prefixPermutation) {\n      var selector = {};\n      selector[fieldName] =\n        new RegExp('^' + Meteor._escapeRegExp(prefixPermutation));\n      return selector;\n    });\n  var caseInsensitiveClause = {};\n  caseInsensitiveClause[fieldName] =\n    new RegExp('^' + Meteor._escapeRegExp(string) + '$', 'i')\n  return {$and: [{$or: orClause}, caseInsensitiveClause]};\n}\n\n// Generates permutations of all case variations of a given string.\nvar generateCasePermutationsForString = function (string) {\n  var permutations = [''];\n  for (var i = 0; i < string.length; i++) {\n    var ch = string.charAt(i);\n    permutations = _.flatten(_.map(permutations, function (prefix) {\n      var lowerCaseChar = ch.toLowerCase();\n      var upperCaseChar = ch.toUpperCase();\n      // Don't add unneccesary permutations when ch is not a letter\n      if (lowerCaseChar === upperCaseChar) {\n        return [prefix + ch];\n      } else {\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];\n      }\n    }));\n  }\n  return permutations;\n}\n\nvar checkForCaseInsensitiveDuplicates = function (fieldName, displayName, fieldValue, ownUserId) {\n  // Some tests need the ability to add users with the same case insensitive\n  // value, hence the _skipCaseInsensitiveChecksForTest check\n  var skipCheck = _.has(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);\n\n  if (fieldValue && !skipCheck) {\n    var matchedUsers = Meteor.users.find(\n      selectorForFastCaseInsensitiveLookup(fieldName, fieldValue)).fetch();\n\n    if (matchedUsers.length > 0 &&\n        // If we don't have a userId yet, any match we find is a duplicate\n        (!ownUserId ||\n        // Otherwise, check to see if there are multiple matches or a match\n        // that is not us\n        (matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId))) {\n      throw new Meteor.Error(403, displayName + \" already exists.\");\n    }\n  }\n};\n\n// XXX maybe this belongs in the check package\nvar NonEmptyString = Match.Where(function (x) {\n  check(x, String);\n  return x.length > 0;\n});\n\nvar userQueryValidator = Match.Where(function (user) {\n  check(user, {\n    id: Match.Optional(NonEmptyString),\n    username: Match.Optional(NonEmptyString),\n    email: Match.Optional(NonEmptyString)\n  });\n  if (_.keys(user).length !== 1)\n    throw new Match.Error(\"User property must have exactly one field\");\n  return true;\n});\n\nvar passwordValidator = Match.OneOf(\n  String,\n  { digest: String, algorithm: String }\n);\n\n// Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (! options.password || options.srp)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    password: passwordValidator\n  });\n\n\n  var user = Accounts._findUserByQuery(options.user);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  if (!user.services || !user.services.password ||\n      !(user.services.password.bcrypt || user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  if (!user.services.password.bcrypt) {\n    if (typeof options.password === \"string\") {\n      // The client has presented a plaintext password, and the user is\n      // not upgraded to bcrypt yet. We don't attempt to tell the client\n      // to upgrade to bcrypt, because it might be a standalone DDP\n      // client doesn't know how to do such a thing.\n      var verifier = user.services.password.srp;\n      var newVerifier = SRP.generateVerifier(options.password, {\n        identity: verifier.identity, salt: verifier.salt});\n\n      if (verifier.verifier !== newVerifier.verifier) {\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Incorrect password\")\n        };\n      }\n\n      return {userId: user._id};\n    } else {\n      // Tell the client to use the SRP upgrade process.\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n  }\n\n  return checkPassword(\n    user,\n    options.password\n  );\n});\n\n// Handler to login using the SRP upgrade path. To use this login\n// handler, the client must provide:\n//   - srp: H(identity + \":\" + password)\n//   - password: a string or an object with properties 'digest' and 'algorithm'\n//\n// We use `options.srp` to verify that the client knows the correct\n// password without doing a full SRP flow. Once we've checked that, we\n// upgrade the user to bcrypt and remove the SRP information from the\n// user document.\n//\n// The client ends up using this login handler after trying the normal\n// login handler (above), which throws an error telling the client to\n// try the SRP upgrade path.\n//\n// XXX COMPAT WITH 0.8.1.3\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (!options.srp || !options.password)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    srp: String,\n    password: passwordValidator\n  });\n\n  var user = Accounts._findUserByQuery(options.user);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  // Check to see if another simultaneous login has already upgraded\n  // the user record to bcrypt.\n  if (user.services && user.services.password && user.services.password.bcrypt)\n    return checkPassword(user, options.password);\n\n  if (!(user.services && user.services.password && user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  var v1 = user.services.password.srp.verifier;\n  var v2 = SRP.generateVerifier(\n    null,\n    {\n      hashedIdentityAndPassword: options.srp,\n      salt: user.services.password.srp.salt\n    }\n  ).verifier;\n  if (v1 !== v2)\n    return {\n      userId: user._id,\n      error: new Meteor.Error(403, \"Incorrect password\")\n    };\n\n  // Upgrade to bcrypt on successful login.\n  var salted = hashPassword(options.password);\n  Meteor.users.update(\n    user._id,\n    {\n      $unset: { 'services.password.srp': 1 },\n      $set: { 'services.password.bcrypt': salted }\n    }\n  );\n\n  return {userId: user._id};\n});\n\n\n///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n */\nAccounts.setUsername = function (userId, newUsername) {\n  check(userId, NonEmptyString);\n  check(newUsername, NonEmptyString);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  var oldUsername = user.username;\n\n  // Perform a case insensitive check fro duplicates before update\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n\n  Meteor.users.update({_id: user._id}, {$set: {username: newUsername}});\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id}, {$set: {username: oldUsername}});\n    throw ex;\n  }\n};\n\n// Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\n//\n// XXX COMPAT WITH 0.8.1.3\n// Like the login method, if the user hasn't been upgraded from SRP to\n// bcrypt yet, then this method will throw an 'old password format'\n// error. The client should call the SRP upgrade login handler and then\n// retry this method again.\n//\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade\n// errors thrown. The reasoning for this is that clients using this\n// method directly will need to be updated anyway because we no longer\n// support the SRP flow that they would have been doing to use this\n// method previously.\nMeteor.methods({changePassword: function (oldPassword, newPassword) {\n  check(oldPassword, passwordValidator);\n  check(newPassword, passwordValidator);\n\n  if (!this.userId)\n    throw new Meteor.Error(401, \"Must be logged in\");\n\n  var user = Meteor.users.findOne(this.userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  if (!user.services || !user.services.password ||\n      (!user.services.password.bcrypt && !user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  if (! user.services.password.bcrypt) {\n    throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n      format: 'srp',\n      identity: user.services.password.srp.identity\n    }));\n  }\n\n  var result = checkPassword(user, oldPassword);\n  if (result.error)\n    throw result.error;\n\n  var hashed = hashPassword(newPassword);\n\n  // It would be better if this removed ALL existing tokens and replaced\n  // the token for the current connection with a new one, but that would\n  // be tricky, so we'll settle for just replacing all tokens other than\n  // the one for the current connection.\n  var currentToken = Accounts._getLoginToken(this.connection.id);\n  Meteor.users.update(\n    { _id: this.userId },\n    {\n      $set: { 'services.password.bcrypt': hashed },\n      $pull: {\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }\n      },\n      $unset: { 'services.password.reset': 1 }\n    }\n  );\n\n  return {passwordChanged: true};\n}});\n\n\n// Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n */\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {\n  options = _.extend({logout: true}, options);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  var update = {\n    $unset: {\n      'services.password.srp': 1, // XXX COMPAT WITH 0.8.1.3\n      'services.password.reset': 1\n    },\n    $set: {'services.password.bcrypt': hashPassword(newPlaintextPassword)}\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  Meteor.users.update({_id: user._id}, update);\n};\n\n\n///\n/// RESETTING VIA EMAIL\n///\n\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\nMeteor.methods({forgotPassword: function (options) {\n  check(options, {email: String});\n\n  var user = Meteor.users.findOne({\"emails.address\": options.email});\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  Accounts.sendResetPasswordEmail(user._id, options.email);\n}});\n\n// send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n */\nAccounts.sendResetPasswordEmail = function (userId, email) {\n  // Make sure the user exists, and email is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0])\n    email = user.emails[0].address;\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))\n    throw new Error(\"No such email for user.\");\n\n  var token = Random.secret();\n  var when = new Date();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: when\n  };\n  Meteor.users.update(userId, {$set: {\n    \"services.password.reset\": tokenRecord\n  }});\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  var resetPasswordUrl = Accounts.urls.resetPassword(token);\n\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates.resetPassword.from\n      ? Accounts.emailTemplates.resetPassword.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.resetPassword.subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates.resetPassword.text === 'function') {\n    options.text =\n      Accounts.emailTemplates.resetPassword.text(user, resetPasswordUrl);\n  }\n\n  if (typeof Accounts.emailTemplates.resetPassword.html === 'function')\n    options.html =\n      Accounts.emailTemplates.resetPassword.html(user, resetPasswordUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n// send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n */\nAccounts.sendEnrollmentEmail = function (userId, email) {\n  // XXX refactor! This is basically identical to sendResetPasswordEmail.\n\n  // Make sure the user exists, and email is in their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0])\n    email = user.emails[0].address;\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))\n    throw new Error(\"No such email for user.\");\n\n  var token = Random.secret();\n  var when = new Date();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: when\n  };\n  Meteor.users.update(userId, {$set: {\n    \"services.password.reset\": tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  var enrollAccountUrl = Accounts.urls.enrollAccount(token);\n\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates.enrollAccount.from\n      ? Accounts.emailTemplates.enrollAccount.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.enrollAccount.subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates.enrollAccount.text === 'function') {\n    options.text =\n      Accounts.emailTemplates.enrollAccount.text(user, enrollAccountUrl);\n  }\n\n  if (typeof Accounts.emailTemplates.enrollAccount.html === 'function')\n    options.html =\n      Accounts.emailTemplates.enrollAccount.html(user, enrollAccountUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\nMeteor.methods({resetPassword: function (token, newPassword) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"resetPassword\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n      check(newPassword, passwordValidator);\n\n      var user = Meteor.users.findOne({\n        \"services.password.reset.token\": token});\n      if (!user)\n        throw new Meteor.Error(403, \"Token expired\");\n      var email = user.services.password.reset.email;\n      if (!_.include(_.pluck(user.emails || [], 'address'), email))\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Token has invalid email address\")\n        };\n\n      var hashed = hashPassword(newPassword);\n\n      // NOTE: We're about to invalidate tokens on the user, who we might be\n      // logged in as. Make sure to avoid logging ourselves out if this\n      // happens. But also make sure not to leave the connection in a state\n      // of having a bad token set if things fail.\n      var oldToken = Accounts._getLoginToken(self.connection.id);\n      Accounts._setLoginToken(user._id, self.connection, null);\n      var resetToOldToken = function () {\n        Accounts._setLoginToken(user._id, self.connection, oldToken);\n      };\n\n      try {\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        var affectedRecords = Meteor.users.update(\n          {\n            _id: user._id,\n            'emails.address': email,\n            'services.password.reset.token': token\n          },\n          {$set: {'services.password.bcrypt': hashed,\n                  'emails.$.verified': true},\n           $unset: {'services.password.reset': 1,\n                    'services.password.srp': 1}});\n        if (affectedRecords !== 1)\n          return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Invalid email\")\n          };\n      } catch (err) {\n        resetToOldToken();\n        throw err;\n      }\n\n      // Replace all valid login tokens with new ones (changing\n      // password should invalidate existing sessions).\n      Accounts._clearAllLoginTokens(user._id);\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n///\n/// EMAIL VERIFICATION\n///\n\n\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n */\nAccounts.sendVerificationEmail = function (userId, address) {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n\n  // Make sure the user exists, and address is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first unverified address if we weren't passed an address.\n  if (!address) {\n    var email = _.find(user.emails || [],\n                       function (e) { return !e.verified; });\n    address = (email || {}).address;\n  }\n  // make sure we have a valid address\n  if (!address || !_.contains(_.pluck(user.emails || [], 'address'), address))\n    throw new Error(\"No such email address for user.\");\n\n\n  var tokenRecord = {\n    token: Random.secret(),\n    address: address,\n    when: new Date()};\n  Meteor.users.update(\n    {_id: userId},\n    {$push: {'services.email.verificationTokens': tokenRecord}});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'email');\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n  user.services.email.verificationTokens.push(tokenRecord);\n\n  var verifyEmailUrl = Accounts.urls.verifyEmail(tokenRecord.token);\n\n  var options = {\n    to: address,\n    from: Accounts.emailTemplates.verifyEmail.from\n      ? Accounts.emailTemplates.verifyEmail.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.verifyEmail.subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates.verifyEmail.text === 'function') {\n    options.text =\n      Accounts.emailTemplates.verifyEmail.text(user, verifyEmailUrl);\n  }\n\n  if (typeof Accounts.emailTemplates.verifyEmail.html === 'function')\n    options.html =\n      Accounts.emailTemplates.verifyEmail.html(user, verifyEmailUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n// Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\nMeteor.methods({verifyEmail: function (token) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"verifyEmail\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n\n      var user = Meteor.users.findOne(\n        {'services.email.verificationTokens.token': token});\n      if (!user)\n        throw new Meteor.Error(403, \"Verify email link expired\");\n\n      var tokenRecord = _.find(user.services.email.verificationTokens,\n                               function (t) {\n                                 return t.token == token;\n                               });\n      if (!tokenRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link expired\")\n        };\n\n      var emailsRecord = _.find(user.emails, function (e) {\n        return e.address == tokenRecord.address;\n      });\n      if (!emailsRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n        };\n\n      // By including the address in the query, we can use 'emails.$' in the\n      // modifier to get a reference to the specific object in the emails\n      // array. See\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n      Meteor.users.update(\n        {_id: user._id,\n         'emails.address': tokenRecord.address},\n        {$set: {'emails.$.verified': true},\n         $pull: {'services.email.verificationTokens': {address: tokenRecord.address}}});\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n/**\n * @summary Add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n */\nAccounts.addEmail = function (userId, newEmail, verified) {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n\n  if (_.isUndefined(verified)) {\n    verified = false;\n  }\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  // Allow users to change their own email to a version with a different case\n\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n  var caseInsensitiveRegExp =\n    new RegExp('^' + Meteor._escapeRegExp(newEmail) + '$', 'i');\n\n  var didUpdateOwnEmail = _.any(user.emails, function(email, index) {\n    if (caseInsensitiveRegExp.test(email.address)) {\n      Meteor.users.update({\n        _id: user._id,\n        'emails.address': email.address\n      }, {$set: {\n        'emails.$.address': newEmail,\n        'emails.$.verified': verified\n      }});\n      return true;\n    }\n\n    return false;\n  });\n\n  // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n  if (didUpdateOwnEmail) {\n    return;\n  }\n\n  // Perform a case insensitive check for duplicates before update\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $addToSet: {\n      emails: {\n        address: newEmail,\n        verified: verified\n      }\n    }\n  });\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id},\n      {$pull: {emails: {address: newEmail}}});\n    throw ex;\n  }\n}\n\n/**\n * @summary Remove an email address for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n */\nAccounts.removeEmail = function (userId, email) {\n  check(userId, NonEmptyString);\n  check(email, NonEmptyString);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  Meteor.users.update({_id: user._id},\n    {$pull: {emails: {address: email}}});\n}\n\n///\n/// CREATING USERS\n///\n\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\nvar createUser = function (options) {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n\n  var username = options.username;\n  var email = options.email;\n  if (!username && !email)\n    throw new Meteor.Error(400, \"Need to set a username or email\");\n\n  var user = {services: {}};\n  if (options.password) {\n    var hashed = hashPassword(options.password);\n    user.services.password = { bcrypt: hashed };\n  }\n\n  if (username)\n    user.username = username;\n  if (email)\n    user.emails = [{address: email, verified: false}];\n\n  // Perform a case insensitive check before insert\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);\n\n  var userId = Accounts.insertUserDoc(options, user);\n  // Perform another check after insert, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);\n  } catch (ex) {\n    // Remove inserted user if the check fails\n    Meteor.users.remove(userId);\n    throw ex;\n  }\n  return userId;\n};\n\n// method for create user. Requests come from the client.\nMeteor.methods({createUser: function (options) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"createUser\",\n    arguments,\n    \"password\",\n    function () {\n      // createUser() above does more checking.\n      check(options, Object);\n      if (Accounts._options.forbidClientAccountCreation)\n        return {\n          error: new Meteor.Error(403, \"Signups forbidden\")\n        };\n\n      // Create user. result contains id and token.\n      var userId = createUser(options);\n      // safety belt. createUser is supposed to throw on error. send 500 error\n      // instead of sending a verification email with empty userid.\n      if (! userId)\n        throw new Error(\"createUser failed to insert new user\");\n\n      // If `Accounts._options.sendVerificationEmail` is set, register\n      // a token to verify the user's primary email, and send it to\n      // that address.\n      if (options.email && Accounts._options.sendVerificationEmail)\n        Accounts.sendVerificationEmail(userId, options.email);\n\n      // client gets logged in as the new user afterwards.\n      return {userId: userId};\n    }\n  );\n}});\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\nAccounts.createUser = function (options, callback) {\n  options = _.clone(options);\n\n  // XXX allow an optional callback?\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n\n  return createUser(options);\n};\n\n///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\nMeteor.users._ensureIndex('services.email.verificationTokens.token',\n                          {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('services.password.reset.token',\n                          {unique: 1, sparse: 1});\n"]}}]